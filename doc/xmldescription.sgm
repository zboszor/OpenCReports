<chapter id="xmldescriptor" xreflabel="XML description">
	<title>Report XML description</title>
	<sect1>
		<title>XML description structure</title>
		<para>
			OpenCReports uses an RLIB-compatible report description
			with extensions.
		</para>
		<para>
			The report XML description, like all XML files start with
			declaring that it's an XML file and the optional declaration
			of the Document Type Definition that the XML file can be
			checked against. For an OpenCReports report description,
			the first two lines are:
			<programlisting>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE OpenCReport SYSTEM "opencreport.dtd"&gt;
			</programlisting>
			The DTD file <literal>opencreport.dtd</literal> can be
			found in the sources of OpenCReports.
		</para>
		<para>
			After the XML header lines, a fully specified report
			description looks like this:
			<programlisting>
&lt;OpenCReport&gt;
    &lt;Datasources&gt;
        ...
    &lt;/Datasources&gt;
    &lt;Queries&gt;
        ...
    &lt;/Queries&gt;
    &lt;Part&gt;
        &lt;pr&gt;
            &lt;pd&gt;
                &lt;Report&gt;
                    ...
                &lt;/Report&gt;
            &lt;/pd&gt;
        &lt;/pr&gt;
    &lt;/Part&gt;
&lt;/OpenCReport&gt;
			</programlisting>
			or like this:
			<programlisting>
&lt;OpenCReport&gt;
    &lt;Datasources&gt;
        ...
    &lt;/Datasources&gt;
    &lt;Queries&gt;
        ...
    &lt;/Queries&gt;
    &lt;Report&gt;
        ...
    &lt;/Report&gt;
&lt;/OpenCReport&gt;
			</programlisting>
		</para>
		<para>
			The XML sections <literal>&lt;Datasources&gt;</literal>
			and <literal>&lt;Queries&gt;</literal> are optional
			in the report XML description. They can be substituted
			by program code using the datasource and query related
			calls in the <xref linkend="lowlevelapi"/>, similarly
			to RLIB.
		</para>
		<para>
			For RLIB compatibility, a report description may start
			with either <literal>&lt;Part&gt;</literal> or
			<literal>&lt;Report&gt;</literal> as the toplevel node.
			In this case, there's no other way to add datasources
			and queries, but through program code, like the
			<xref linkend="lowlevelapi"/>.
		</para>
		<sect2>
			<title>Notes about XML syntax and attributes</title>
			<para>
				Most (if not all) XML attributes in the report
				description file are handled with the expression
				parser (see <xref linkend="expressions"/>), with fallback
				to literal strings if the the location of expression
				wouldn't allow identifier references at that location.
			</para>
			<para>
				For example, the datasource name may be declared this way:
				<programlisting>
&lt;Datasource name="mysource" ... /&gt;
				</programlisting>
				where the name is a literal string. Or this way:
				<programlisting>
&lt;Datasource name="'mysource'" ... /&gt;
				</programlisting>
				where the name is a string expression. (Note the
				extra quotes.) Or even this way:
				<programlisting>
&lt;Datasource name="&amp;quot;mysource&amp;quot;" ... /&gt;
				</programlisting>
				where name is a string expression which uses the
				<literal>"</literal> double quote character which
				must be "escaped" according to XML rules. This last
				variant is less readable than the first two.
				Nevertheless, it is usable and it works, so machine
				generated XML files may also be used.
			</para>
			<para>
				The first form is a regular XML string value.
				Since expression parsing would find that
				<literal>mysource</literal> is an identifier
				which may be a query column name and this is not
				a valid place for a query reference, the non-parsed
				string value is used.
			</para>
			<para>
				The second form is a single quoted OpenCReports
				string constant. The parsed string constant's
				value is used.
			</para>
			<para>
				The third form is a double quoted OpenCReports
				string constant, but in XML the double quote
				character must be substituted with
				<literal>&amp;quot;</literal> because they are
				reserved for quoting the attribute values.
				The parsed string constant's value is used.
			</para>
			<para>
				To make the XML easier to read, the second form
				is recommended because it still allows
				embedding the single quote character inside
				a string (see <xref linkend="xmldescriptor"/>)
				in case e.g. a strong password contains this.
				For security-by-obscurity, the third form may
				be used because it is harder to read. For all
				special characters that should be escaped in
				XML, see
				<ulink url="https://stackoverflow.com/a/46637835/290085"><citetitle>Simplified XML Escaping</citetitle></ulink>.
			</para>
		</sect2>
	</sect1>
	<sect1 id="ocrpttopxml" xreflabel="OpenCReport element">
		<title>OpenCReport element</title>
		<para>
			The toplevel <literal>&lt;OpenCReport&gt;</literal>
			element controls some global settings and serves
			as the topmost XML element for child elements.
		</para>
		<sect2 id="sizeunit" xreflabel="Size unit attribute">
			<title>Size unit attribute</title>
			<para>
				<programlisting>
size_unit="default"
size_unit="rlib"
size_unit="points"
				</programlisting>
				The <literal>size_unit</literal> attribute
				specifies whether all size related settings
				in the report are in points, a.k.a. 1/72th inch.
			</para>
			<para>
				The <literal>default</literal> is <literal>rlib</literal>
				which is the legacy RLIB behavior, leading
				to some inconsistency in size related settings.
				For example, width for <literal>field</literal>
				and <literal>literal</literal> (see later in the
				Output section) are in number of characters.
				This is influenced by the font size set for these
				text fields. On the other hand, width of horizontal
				lines and border width around some reports are
				specified in points.
			</para>
			<para>
			</para>
		</sect2>
		<sect2 id="rlibcompat" xreflabel="RLIB compatibility attribute">
			<title>RLIB compatibility attribute</title>
			<para>
				<programlisting>
rlib_compat="yes"
				</programlisting>
				The <literal>rlib_compat</literal> attribute
				specifies whether RLIB compatibility is switched on.
			</para>
			<para>
				It controls two subtle behavioural details
				in tabular report rendering with PDF output.
				See TODO.
			</para>
		</sect2>
	</sect1>
	<sect1 id="datasources" xreflabel="Datasources">
		<title>Datasources</title>
		<para>
			Datasources in OpenCReports are either database
			connections, or accessors (mini-drivers) for data
			files in certain formats.
		</para>
		<para>
			Datasource descriptions are in the following format:
			<programlisting>
&lt;Datasources&gt;
    &lt;Datasource name="mysource" type="..." ... /&gt;
&lt;/Datasources&gt;
			</programlisting>
		</para>
		<para>
			A report may have multiple datasources, i.e.
			the description may list multiple
			<literal>&lt;Datasource&gt;</literal> lines.
		</para>
		<para>
			Datasources must have unique names in a report and
			their type may be: <literal>mariadb</literal>,
			<literal>mariadb</literal> (or <literal>mysql</literal>),
			<literal>postgresql</literal>, <literal>odbc</literal>,
			<literal>csv</literal>, <literal>json</literal>,
			<literal>xml</literal> or <literal>array</literal>.
		</para>
		<sect2>
			<title>MariaDB (MySQL) database connection</title>
			<para>
				A MariaDB database connection may be declared in three
				ways. Either by using the database host and port
				database name, user name and password directly:
				<programlisting>
&lt;Datasource
    name="mysource" type="mariadb"
    host="..." port="..."
    dbname="..." user="..." password="..." /&gt;
				</programlisting>
				or alternatively, instead of the host and port,
				specifying the the UNIX Domain Socket file for
				a local connection if it's not in the standard
				location:
				<programlisting>
&lt;Datasource
    name="mysource" type="mariadb"
    unix_socket="..."
    dbname="..." user="..." password="..." /&gt;
				</programlisting>
				or moving these details out to an external
				configuration file in an INI file format:
				<programlisting>
&lt;Datasource
    name="mysource" type="mariadb"
    optionfile="myconn.cnf" group="myconn" /&gt;
				</programlisting>
			</para>
			<para>
				In the second case, the configuration file <literal>myconn.cnf</literal>
				would contain something like this:
				<programlisting>
[myconn]
!include /etc/my.cnf
database=mydb
user=myuser
#password=
#host=
#port=
#unix_socket=
				</programlisting>
				Please note that the INI group name <literal>[myconn]</literal>
				matches <literal>group="myconn"</literal> in the above
				datasource declaration.
			</para>
			<para>
				The database name and user name are mandatory. The
				user password is optional, depending on the database
				security authentication setup.
			</para>
			<para>
				The database host and port, or the socket file location
				are all optional. Without these, a local connection is
				attempted using the default settings.
			</para>
		</sect2>
		<sect2>
			<title>PostgreSQL database connection</title>
			<para>
				A PostgreSQL database connection may be declared in three
				ways. Either by using the database host and port
				database name, user name and password directly:
				<programlisting>
&lt;Datasource
    name="mysource" type="postgresql"
    host="..." port="..."
    dbname="..." user="..." password="..." /&gt;
				</programlisting>
				or alternatively, instead of the host and port,
				specifying the the UNIX Domain Socket file for
				a local connection if it's not in the standard
				location:
				<programlisting>
&lt;Datasource
    name="mysource" type="postgresql"
    unix_socket="..."
    dbname="..." user="..." password="..." /&gt;
				</programlisting>
				or using a so called connection string:
				<programlisting>
&lt;Datasource
    name="mysource" type="postgresql"
    connstr="..." /&gt;
				</programlisting>
			</para>
			<para>
				For the connection string format, see the
				<ulink url="https://www.postgresql.org/docs"><citetitle>PostgreSQL documentation</citetitle></ulink>.
			</para>
			<para>
				The database name and user name are mandatory. The
				user password is optional, depending on the database
				security authentication setup.
			</para>
			<para>
				The database host and port, or the socket file location
				are all optional. Without these, a local connection is
				attempted using the default settings.
			</para>
		</sect2>
		<sect2>
			<title>ODBC database connection</title>
			<para>
				The above described MariaDB and PostgreSQL database
				connection types are using their respective client
				libraries. There is a more generic way, i.e. ODBC.
				ODBC was invented by Microsoft in the 1990s for Windows.
				See
				<ulink url="https://docs.microsoft.com/en-us/sql/odbc/microsoft-open-database-connectivity-odbc"><citetitle>Microsoft Open Database Connectivity (ODBC)</citetitle></ulink>
				In their solution, there's an abstract client library
				and individual database drivers adhere to the APIs
				offered by ODBC toplevel library. Since then, UNIX and
				UNIX-like systems also gained their ODBC client libraries
				in two different implementations, both of which are
				supported by OpenCReports:
				<ulink url="https://www.unixodbc.org"><citetitle>unixODBC</citetitle></ulink>
				and
				<ulink url="https://www.iodbc.org"><citetitle>iODBC</citetitle></ulink>.
			</para>
			<para>
				An ODBC database setup is done a differently. There are
				two system-wide configuration files. The first one is
				<literal>odbcinst.ini</literal> that lists the database
				drivers installed into the system. The second one is
				<literal>odbc.ini</literal> which references the first
				one and lists pre-defined database connections. These
				database connections are named. In ODBC speak, these
				are called Data Source Names or DSNs. The DSNs specify
				the low level connection parameters, like the database
				host and port, and optionally the user name and
				password, too.
			</para>
			<para>
				Thus, an ODBC database connection may be declared in two
				ways. The first way is by using the DSN name, and
				optionally the user name and password:
				<programlisting>
&lt;Datasource
    name="mysource" type="odbc"
    dbname="..." user="..." password="..." /&gt;
				</programlisting>
				In this case, the <literal>dbname</literal> attribute
				is not the low level database name, but the ODBC
				abstract DSN name.
			</para>
			<para>
				There's also a way to use the so called connection string
				which contain the same connection information:
				<programlisting>
&lt;Datasource
    name="mysource" type="odbc"
    connstr="..." /&gt;
				</programlisting>
			</para>
			<para>
				For the connection string format, see the
				<ulink url="https://www.connectionstrings.com/"><citetitle>public examples</citetitle></ulink>.
			</para>
		</sect2>
		<sect2>
			<title>CSV file datasource</title>
			<para>
				CSV ("Comma Separated Values") is a simple tabulated
				file format. Every line must have the same number of
				columns, for which the values are separated by commas.
				The first line in the file contains the column names.
			</para>
			<para>
				A CSV file datasource is declared very simply:
				<programlisting>
&lt;Datasource name="mysource" type="'csv'" /&gt;
				</programlisting>
				In this case, the actual CSV file is not declared,
				only that a "query" using a CSV file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				This datasource is less smart than others, in that
				is cannot specify data type for columns. Every column
				is assumed to be a string, regardless if the values
				themselves are quoted or not in the file. Data
				conversion functions must be used, like
				<literal>val()</literal>, <literal>stodt()</literal>
				or <literal>interval()</literal>.
			</para>
		</sect2>
		<sect2>
			<title>JSON file datasource</title>
			<para>
				Similarly to CSV, the JSON file datasource is also declared
				very simply:
				<programlisting>
&lt;Datasource name="mysource" type="'json'" /&gt;
				</programlisting>
				In this case, the actual JSON file is not declared,
				only that a "query" using a JSON file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				A JSON file datasource is expected in this format:
				<programlisting>
{
    "columns": ["colname1", ... ],
    "coltypes": ["type", ... ],
    "rows": [
	    { "colname1": value1, ...  },
        ...
    ]
}
				</programlisting>
			</para>
			<para>
				The JSON file is expected to list the column
				names in a string array called <literal>columns</literal>.
			</para>
			<para>
				The column types are optionally listed in the string
				array called <literal>coltypes</literal>. If they are
				listed, the <literal>coltypes</literal> array must have
				the same number of strings as the <literal>columns</literal>
				array. The types may be <literal>string</literal>,
				<literal>number</literal> or <literal>datatime</literal>.
				If the column type array is missing, then all data
				values are assumed to be strings and data conversion
				functions must be used, like <literal>val()</literal>,
				<literal>stodt()</literal> or <literal>interval()</literal>.
			</para>
			<para>
				The rows are listed in an array called <literal>rows</literal>
				and column data values for each row are in a collection
				with data names from the <literal>columns</literal> and
				data types from the <literal>coltypes</literal> arrays.
			</para>
		</sect2>
		<sect2>
			<title>XML file datasource</title>
			<para>
				Similarly to CSV and JSON, the XML file datasource is also declared
				very simply:
				<programlisting>
&lt;Datasource name="mysource" type="'xml'" /&gt;
				</programlisting>
				In this case, the actual XML file is not declared,
				only that a "query" using an XML file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				An XML file datasource is expected in this format:
				<programlisting>
&lt;?xml version="1.0"?&gt;
&lt;data&gt;
	&lt;rows&gt;
		&lt;row&gt;
			&lt;col&gt;value&lt;/col&gt;
            ...
		&lt;/row&gt;
        ...
	&lt;/rows&gt;
	&lt;fields&gt;
		&lt;field&gt;column1&lt;/field&gt;
        ...
	&lt;/fields&gt;
	&lt;coltypes&gt;
		&lt;col&gt;type1&lt;/col&gt;
        ...
	&lt;/coltypes&gt;
&lt;/data&gt;
				</programlisting>
				The XML section names <literal>&lt;data&gt;</literal>,
				<literal>&lt;rows&gt;</literal> and
				<literal>&lt;fields&gt;</literal>
				are the same as they were in RLIB for its XML data
				source. The order of <literal>&lt;rows&gt;</literal>
				and <literal>&lt;fields&gt;</literal> is not important.
				But the order of field names in <literal>&lt;fields&gt;</literal>
				must match the column value order in each
				<literal>&lt;row&gt;</literal>.
			</para>
			<para>
				The section &lt;coltypes&gt; is new in OpenCReports and
				is optional. If it's present, then it must list
				the data types in the same order as the section
				<literal>&lt;fields&gt;</literal>.
				The types may be <literal>string</literal>,
				<literal>number</literal> or <literal>datatime</literal>.
				If this section is not present, all values are assumed
				to be strings and data conversion functions must be
				used, like <literal>val()</literal>, <literal>stodt()</literal>
				or <literal>interval()</literal>.
			</para>
		</sect2>
		<sect2>
			<title>Array datasource</title>
			<para>
				Arrays are global in-memory structures in the
				application that should be accessible to the
				OpenCReports library. For example, when using
				the C programming language, global non-static
				symbols are visible to libraries if the application
				is compiled with <literal>-rdynamic</literal>.
			</para>
			<para>
				Similarly to file based datasources, the array
				datasource is declared very simply:
				<programlisting>
&lt;Datasource name="mysource" type="'array'" /&gt;
				</programlisting>
				In this case, the actual array is not declared,
				only that a "query" using an array will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				A C array is declared in this format:
				<programlisting>
const char *array[ROWS + 1][COLUMNS] = {
    { "column1", ... },
    { "value1",  ... },
    ...
};
				</programlisting>
				The array is declared as a two-dimensional array of
				C strings. The first row of the array is the column
				names, <literal>[ROWS + 1]</literal> in the array
				declaration accounts for the title row.
			</para>
			<para>
				All rows have the same number of columns. Column values
				may be NULL, in which case they will be treated the same
				as SQL NULLs in SQL query results.
			</para>
			<para>
				Optionally, a column types array is declared
				separately:
				<programlisting>
#include &lt;opencreport.h&gt;

const enum ocrpt_result_type coltypes[COLUMNS] = {
    ...
};
				</programlisting>
				If this array is present, it must have the same number
				of <literal>COLUMNS</literal> as the matching data
				array. The <literal>enum ocrpt_result_type</literal>
				usable in data array type declaration are
				<literal>OCRPT_RESULT_STRING</literal>,
				<literal>OCRPT_RESULT_NUMBER</literal> and
				<literal>OCRPT_RESULT_DATETIME</literal>. 
			</para>
		</sect2>
	</sect1>
	<sect1 id="queries" xreflabel="Queries">
		<title>Queries</title>
		<para>
			Queries in OpenCReports are SQL queries for database
			connections, or data files files in certain formats.
			The queries are declared like this:
			<programlisting>
&lt;Queries&gt;
    &lt;Query name="..." ... /&gt;
    ...
&lt;/Queries&gt;
			</programlisting>
		</para>
		<sect2>
			<title>SQL queries for SQL datasources</title>
			<para>
				SQL queries for MariaDB, PostgreSQL and ODBC
				datasources may be declared two ways, either
				as the XML value for <literal>&lt;Query&gt;</literal>:
				<programlisting>
&lt;Query
    name="myquery"
    datasource="mysource"&gt;
SELECT * FROM some_table
&lt;/Query&gt;
				</programlisting>
				or as the <literal>value</literal> attribute:
				<programlisting>
&lt;Query
    name="myquery"
    datasource="mysource"
    value="SELECT * FROM some_table" /&gt;
				</programlisting>
			</para>
			<para>
				Note, that the XML attribute <literal>datasource="..."</literal>
				must match a previously declared datasource.
			</para>
			<para>
				The SQL query can be any <literal>SELECT</literal>
				statement.
			</para>
			<sect3>
				<title>Special note for SQL datasources</title>
				<para>
					The database client libraries for MariaDB,
					PostgreSQL and ODBC return all the query rows
					from the database server at once by default.
					As such, it is possible that a long query result
					doesn't fit into the computer memory.
				</para>
				<para>
					The report needs to traverse the query result twice
					to pre-compute "delayed" values, so it needs to
					be able to rewind the data set once it was read
					to the end.
				</para>
				<para>
					The alternative API in MariaDB to load the rows one by
					one doesn't allow rewinding, so it's not usable
					for the report's purposes.
				</para>
				<para>
					It is only PostgreSQL that allows using an
					<emphasis>SQL cursor</emphasis> as a standalone entity,
					i.e. outside SQL procedures as defined by the SQL
					standard. This PostgreSQL extension to the standard
					allows saving memory in such a way that it allows
					processing very long queries. Behind the scenes,
					a <literal>WITH HOLD</literal> cursor is used and
					1024 rows are loaded in one go from the server.
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Queries for file based datasources</title>
			<para>
				Queries for CSV, XML and JSON datasources may
				be declared two ways. Either as the XML value for
				<literal>&lt;Query&gt;</literal>:
				<programlisting>
&lt;Query
    name="myquery"
    datasource="mysource"
&gt;xmldata.xml&lt;/Query&gt;
					</programlisting>
					or as the <literal>value</literal> attribute:
					<programlisting>
&lt;Query
    name="myquery"
    datasource="mysource"
    value="'xmldata.xml'" /&gt;
				</programlisting>
			</para>
			<para>
				Notes:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The XML attribute <literal>datasource="..."</literal>
							must match a previously declared datasource.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							It is recommended that the <literal>value="..."</literal>
							form is used, since it's not ensured that
							whitespace before or after the file name
							is trimmed in the first variant if the XML
							is "beautified". The file name that the
							OpenCReports library receives must be correct
							in order to use it.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The declaration must specify a file in the
							correct format for the datasource type.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The optional type declaration for columns
							in the XML and JSON file formats, or for CSV,
							the complete lack of it can be supplemented
							with a memory array using the optional
							<literal>coltypes="..."</literal> attribute.
							For details, see the <xref linkend="arrayqueries"/>.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2 id="arrayqueries" xreflabel="Array queries">
			<title>Queries for array based datasources</title>
			<para>
				Queries for array datasources may be declared two ways.
				Either as the XML value for
				<literal>&lt;Query&gt;</literal>:
				<programlisting>
&lt;Query
    name="myquery"
    datasource="mysource"
    coltypes="'coltypes'"
    rows="30"
    cols="6"
&gt;array&lt;/Query&gt;
					</programlisting>
					or as the <literal>value</literal> attribute:
					<programlisting>
&lt;Query
    name="myquery"
    datasource="mysource"
    value="'array'"
    coltypes="'coltypes'"
    rows="30"
    cols="6" /&gt;
				</programlisting>
			</para>
			<para>
				Notes:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The XML attribute <literal>datasource="..."</literal>
							must match a previously declared datasource.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							It is recommended that the <literal>value="..."</literal>
							form is used, since it's not ensured that
							whitespace before or after the symbol name
							is trimmed in the first variant if the XML
							is "beautified". The symbol name that the
							OpenCReports library receives must be correct
							in order to use it. The array name must match
							the correct global symbol name. It will be
							looked up via <literal>dlsym()</literal>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							Similarly to the array symbol name, the
							<literal>coltypes="..."</literal> array name
							must match the correct global symbol name.
							It will be looked up via <literal>dlsym()</literal>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The value for <literal>cols</literal>
							must match the second dimension of the
							data array.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The value for <literal>rows</literal>
							must be one less than the first dimension
							of the C data array. (The title row is not
							counted in the XML description.)
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Failing to fulfill the above may cause crashes
				or wrong data to be used in the report.
			</para>
		</sect2>
		<sect2 id="followerqueries" xreflabel="Follower queries">
			<title>Follower queries</title>
			<para>
				Multiple queries may be declared. But by default,
				only the first one is actually used by a report.
			</para>
			<para>
				Secondary queries may be associated with the
				primary query as so called "follower" queries.
				Any query may be a follower to the primary query.
			</para>
			<para>
				There are two kinds of follower queries:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							regular, or basic follower queries, and
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							so called N:1 (N-to-one) followers in RLIB
							speak.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<sect3>
				<title>Regular follower queries</title>
				<para>
					A follower query is run along the primary query and
					their rows are laid out side by side. The first row
					of the follower query is assigned the first row of the
					primary query. The second row of the follower query
					is assigned to the second row of the primary query,
					and so on. The number of rows of the complete data
					set is determined by the primary query. If the
					follower query runs out of rows before the primary,
					the columns values will be presented as SQL NULLs.
				</para>
				<para>
					This is similar to using <literal>LEFT OUTER JOIN</literal>
					and using <literal>ROWNUM</literal> in Oracle or
					the <literal>row_number()</literal> SQL function
					in PostgreSQL as the matching value between the
					primary query and the follower query.
				</para>
				<para>
					A regular follower query is declared by adding
					the <literal>follower_for="..."</literal> attribute.
					The value for <literal>follower_for="..."</literal>
					is the <literal>name</literal> of a previously
					declared query. Example:
					<programlisting>
&lt;Query
    name="myquery1"
    datasource="mysource1"
    value="'SELECT * FROM table1'" /&gt;

&lt;Query
    name="myquery2"
    datasource="mysource2"
    value="'SELECT * FROM table1'"
    follower_for="myquery1" /&gt;
					</programlisting>
				</para>
				<para>
					In this example, two queries of two different
					datasources are used. This is one of the advantages
					of using follower queries, i.e. data from different
					databases may be used. Nowadays, with foreign
					queries implemented in e.g. PostgreSQL, its use
					case is more limited.
				</para>
			</sect3>
			<sect3>
				<title>N:1 follower queries</title>
				<para>
					An N:1 follower query, for all intents and
					purposes, is the right side query in a
					<literal>LEFT OUTER JOIN</literal> query, with
					the primary query on the left side. Rows of the
					main query and the follower query are matched
					according to the boolean expression specified
					with the <literal>follower_expr="..."</literal>
					attribute. Example:
					<programlisting>
&lt;Query
    name="myquery1"
    datasource="mysource1"
    value="'SELECT * FROM table1'" /&gt;

&lt;Query
    name="myquery2"
    datasource="mysource2"
    value="'SELECT * FROM table1'"
    follower_for="myquery1"
    follower_expr="myquery1.id = myquery2.id" /&gt;
					</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="parts" xreflabel="Report parts">
		<title>Report parts</title>
		<para>
			A report XML may contain multiple actual reports.
			Such a <literal>&lt;Part&gt;</literal> may be
			under the toplevel <literal>&lt;OpenCReport&gt;</literal>
			node, in which case multiple report parts may exist
			in the same XML, or it may be the toplevel node of
			the XML. In the latter case, only a single
			<literal>&lt;Part&gt;</literal>	may exist in the XML.
			<programlisting>
&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
            ...
        &lt;/pd&gt;
        ...
    &lt;/pr&gt;
    ...
&lt;/Part&gt;
			</programlisting>
		</para>
		<para>
			A report <literal>&lt;Part&gt;</literal> may consist
			multiple reports, arranged in
			<itemizedlist>
				<listitem override="bullet">
					<para>
						rows (<literal>&lt;pr&gt;</literal>),
					</para>
				</listitem>
				<listitem override="bullet">
					<para>
						columns in rows (<literal>&lt;pd&gt;</literal>), and
					</para>
				</listitem>
				<listitem override="bullet">
					<para>
						reports (<literal>&lt;Report&gt;</literal>) arranged
						vertically in a column.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			The rows and columns in rows do not form a grid as rows are
			independent of each other. E.g. one row may contain two columns,
			the next one may contain three, the next one may contain one.
			It is completely freeform.
		</para>
		<para>
			This allows very complex report layouts.
			One possible application of such a complex layout is printed forms.
		</para>
		<sect2 id="partattribs" xreflabel="Part attributes">
			<title>Part attributes</title>
			<sect3 id="partfontname" xreflabel="Part font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the report part's global scope. It can be
					overridden by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>
&lt;Part font_name="Arial"&gt;
&lt;Part fontName="Arial"&gt;
					</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is <literal>Courier</literal>.
				</para>
			</sect3>
			<sect3 id="partfontsize" xreflabel="Part font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the report part's global scope. It can be
					overridden by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>
&lt;Part font_size="10"&gt;
&lt;Part fontSize="10"&gt;
					</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font size is 12.
				</para>
			</sect3>
			<sect3>
				<title>Size unit</title>
				<para>
					Shortcut for the <xref linkend="sizeunit"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>
&lt;Part size_unit="default"&gt;
&lt;Part size_unit="rlib"&gt;
&lt;Part size_unit="points"&gt;
					</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> is the
					toplevel node in the XML, this attribute for
					<literal>&lt;Part&gt;</literal> is ignored.
				</para>
			</sect3>
			<sect3>
				<title>RLIB compatibility</title>
				<para>
					Shortcut for the <xref linkend="rlibcompat"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>
&lt;Part rlib_compat="yes"&gt;
&lt;Part rlib_compat="no"&gt;
					</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> is the
					toplevel node in the XML, this attribute for
					<literal>&lt;Part&gt;</literal> is ignored.
				</para>
				<para>
					When <literal>&lt;Part&gt;</literal> is the toplevel
					node, the default is <literal>yes</literal>.
					This helps using OpenCReports as a drop-in replacement
					for RLIB.
				</para>
			</sect3>
			<sect3 id="partpageorientation" xreflabel="Part page orientation">
				<title>Orientation</title>
				<para>
					Page orientation for the whole
					<literal>&lt;Part&gt;</literal>.
					<programlisting>
&lt;Part orientation="portrait"&gt;
&lt;Part orientation="landscape"&gt;
					</programlisting>
				</para>
				<para>
					Default is portrait orientation.
				</para>
			</sect3>
			<sect3 id="marginsettings" xreflabel="Margin settings">
				<title>Margin settings</title>
				<para>
					Margin settings for the page for the whole
					<literal>&lt;Part&gt;</literal>. Individual
					settings exist for the top, bottom, left and
					right margins of the page. Every setting
					exist in two forms: the RLIB compatible
					"lowerCamelCase" variant and the all lowercase
					with underscore. The lowecase-with-underscore
					variants are the preferred ones.
					<programlisting>
&lt;Part top_margin="0.2"&gt;
&lt;Part topMargin="0.2"&gt;
&lt;Part bottom_margin="0.2"&gt;
&lt;Part bottomMargin="0.2"&gt;
&lt;Part left_margin="0.2"&gt;
&lt;Part leftMargin="0.2"&gt;
&lt;Part right_margin="0.2"&gt;
&lt;Part rightMargin="0.2"&gt;
					</programlisting>
				</para>
				<para>
					When <literal>size_unit="rlib"</literal> is in effect
					(the default case) the margin unit is inches.
					The margin unit is points (1/72th inches) when
					<literal>size_unit="points"</literal> is in effect.
				</para>
				<para>
					Default values for the top, bottom, left and right
					margins are all 0.2, regardless of the unit.
				</para>
				<para>
					Note that <literal>rightMargin</literal> didn't exist
					in RLIB.
				</para>
			</sect3>
			<sect3 id="papertype" xreflabel="Paper type">
				<title>Paper type</title>
				<para>
					Paper type (implicitly: page size) for the whole
					<literal>&lt;Part&gt;</literal>. It exists in
					two forms: the RLIB compatible "lowerCamelCase"
					variant and the all lowercase with underscore.
					The lowecase-with-underscore variant is preferred.
					<programlisting>
&lt;Part paper_type="A4"&gt;
&lt;Part paperType="A4"&gt;
					</programlisting>
				</para>
				<para>
					Default value is the current system paper type
					that <ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>
					uses. E.g. if the system is set to US English,
					the default paper type is implicitly
					<literal>letter</literal>. In most of Europe,
					the default paper type is <literal>A4</literal>
				</para>
				<para>
					The paper type can be specified in either lower case
					or upper case, both are accepted.
				</para>
			</sect3>
			<sect3>
				<title>Iterations</title>
				<para>
					The same <literal>&lt;Part&gt;</literal> may be
					executed multiple times.
					<programlisting>
&lt;Part iterations="3"&gt;
					</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
				<para>
					Note that <literal>&lt;Part&gt;</literal>s and
					every iteration of one starts on a new page.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Report parts may be suppressed.
					<programlisting>
&lt;Part suppress="yes"&gt;
&lt;Part suppress="val(m.suppress_part)"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
			<sect3 id="suppresspageheaderfirstpage" xreflabel="Suppress page header on the first page">
				<title>Suppress page header on the first page</title>
				<para>
					The <literal>&lt;PageHeader&gt;</literal> section
					(see <xref linkend="pageheader"/> below)
					for <literal>&lt;Part&gt;</literal> may be
					suppressed on the first page.
					<programlisting>
&lt;Part suppressPageHeaderFirstPage="yes"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>.
				</para>
				<para>
					Note that this suppression applies only to
					the first page of the complete result (e.g. PDF)
					and not to the first page of an iteration, which
					may fall on a later page of the result.  
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Part subsections</title>
			<para>
				As described in <xref linkend="parts"/>,
				a <literal>&lt;Part&gt;</literal> may contain
				one or more report rows (<literal>&lt;pr&gt;</literal>)
				which in turn may contain one or more columns
				(<literal>&lt;pr&gt;</literal>). See
				<xref linkend="partrow"/> and <xref linkend="partcol"/>.
			</para>
			<sect3 id="pageheader" xreflabel="Page header">
				<title>Page header</title>
				<para>
					This is the description of the page header.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>
&lt;Part&gt;
    &lt;PageHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageHeader&gt;
&lt;/Part&gt;
					</programlisting>					
				</para>
			</sect3>
			<sect3 id="pagefooter" xreflabel="Page footer">
				<title>Page footer</title>
				<para>
					This is the description of the page footer.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>
&lt;Part&gt;
    &lt;PageFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageFooter&gt;
&lt;/Part&gt;
					</programlisting>					
				</para>
			</sect3>
			<sect3>
				<title>Part row</title>
				<para>
					See <xref linkend="partrow"/>.
					<programlisting>
&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            ...
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
				<sect4>
					<title>Part row subsections</title>
					<sect5>
						<title>Part column</title>
						<para>
							See <xref linkend="partcol"/>.
						</para>
					</sect5>
				</sect4>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="partrow" xreflabel="Part row">
		<title>Part row</title>
		<para>
			A part row (<literal>&lt;pr&gt;</literal>) may
			contain one or more <xref linkend="partcol"/>s
			(<literal>&lt;pd&gt;</literal>) which are layed out
			side by side horizontally. The longest running column
			will control the height of the row. The next row will
			be continuous from that vertical page position.
		</para>
		<sect2>
			<title>Part row attributes</title>
			<sect3>
				<title>Layout</title>
				<para>
					The <literal>layout</literal> attribute exists mainly
					for RLIB compatibility, it's ignored.
					It accepts two values: <literal>flow</literal> and
					<literal>fixed</literal>.
					<programlisting>
&lt;pr layout="flow"&gt;
&lt;pr layout="fixed"&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>New page</title>
				<para>
					The <literal>newpage</literal> attribute controls
					whether the part row starts from the point where
					the previous row in the same part ended, or it
					should start on a new page.
					<programlisting>
&lt;pr newpage="yes"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Report rows may be suppressed.
					<programlisting>
&lt;pr suppress="yes"&gt;
&lt;pr suppress="val(m.suppress_row)"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="partcol" xreflabel="Part column">
		<title>Part column</title>
		<para>
			A part column (<literal>&lt;pd&gt;</literal>) may
			contain one or more <xref linkend="report"/>s
			(<literal>&lt;Report&gt;</literal>) which are layed
			out vertically in this column continuously.
		</para>
		<para>
			Such a report may be inlined:
			<programlisting>
&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;
			</programlisting>
		</para>
		<para>
			A report may also be loaded from a separate file.
			For details, see <xref linkend="loadedreport"/>.
			<programlisting>
&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;load ... /&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;
			</programlisting>
		</para>
		<sect2>
			<title>Part column attributes</title>
			<sect3>
				<title>Width</title>
				<para>
					Width of the part column.
			<programlisting>
&lt;pd width="60"&gt;
			</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the column width is measured in characters,
					which is controlled by <xref linkend="partfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="partfontname"/>. Width is computed
					from the font width.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, width is measured
					in points.
				</para>
				<para>
					Columns without explicitly specified width are
					dynamically sized according to
					<xref linkend="papertype"/>,
					<xref linkend="marginsettings"/>
					and columns with explicitly specified width.
				</para>
				<para>
					Columns that exceed the total page width
					(according to <xref linkend="papertype"/> and
					<xref linkend="marginsettings"/>) will be shown
					partially, or won't be shown at all.
				</para>
			</sect3>
			<sect3>
				<title>Height</title>
				<para>
					Height of the part column.
			<programlisting>
&lt;pd height="120"&gt;
			</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the column height is measured in characters,
					which is controlled by <xref linkend="partfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="partfontname"/>. Column height is
					computed from the font height.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, height is measured
					in points.
				</para>
				<para>
					Report details in this part column are layed out
					up to the the specified height. See
					<xref linkend="reportheight"/> for further explanation.
				</para>
				<para>
					Note, that OpenCReports allows fixed height
					columns to break over page boundaries. This is a
					deviation from RLIB.
				</para>
			</sect3>
			<sect3 id="pdborderwidth" xreflabel="Part column border width">
				<title>Border width</title>
				<para>
					Border width around the part column.
					It is measured in points.
			<programlisting>
&lt;pd border_width="2"&gt;
			</programlisting>
				</para>
				<para>
					When set, a rectangle around the part column
					will be drawn. The width of outline of the
					rectangle is measured in points.
				</para>
				<para>
					This is a deviation from RLIB where the width
					of the outline was a fixed 0.1 points and an
					inner margin (all of top, bottom, left and right)
					inside the column border was used.
				</para>
				<para>
					If the column breaks over a page boundary,
					the border will be drawn the column parts
					on every page. 
				</para>
			</sect3>
			<sect3 id="pdbordercolor" xreflabel="Part column border color">
				<title>Border color</title>
				<para>
					When <literal>border_width</literal> is set,
					this color is used to draw the border rectangle.
					<programlisting>
&lt;pd border_color="'blue'"&gt;
					</programlisting>
				</para>
				<para>
					See <xref linkend="colorspec"/>
				</para>
			</sect3>
			<sect3 id="detailcolumns" xreflabel="Detail columns">
				<title>Detail columns</title>
				<para>
					Inner <literal>&lt;Report&gt;</literal>s
					are layed out in one or more columns.
					<programlisting>
&lt;pd detail_columns="3"&gt;
					</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
			</sect3>
			<sect3 id="columnpadding" xreflabel="Column padding">
				<title>Column padding</title>
				<para>
					When <literal>detail_columns</literal>
					is set to higher than 1, inner padding
					between the detail columns may be specified.
					<programlisting>
&lt;pd column_pad="0.2"&gt;
					</programlisting>
				</para>
				<para>
					Default value is 0, i.e. no padding.
				</para>
				<para>
					The unit of padding is inches if
					<xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (default), points
					otherwise.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Report columns may be suppressed.
					<programlisting>
&lt;pd suppress="yes"&gt;
&lt;pd suppress="val(m.suppress_column)"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="report" xreflabel="Report">
		<title>Report</title>
		<para>
			This section may occur in a wider context or
			standalone in an XML description file.
		</para>
		<para>
			Example XML skeleton structure with
			<literal>&lt;OpenCReport&gt;</literal> as
			the toplevel node:
			<programlisting>
&lt;OpenCReport&gt;
    &lt;Part&gt;
        &lt;pr&gt;
            &lt;pd&gt;
                &lt;Report&gt;
                    ...
                &lt;/Report&gt;
            &lt;/pd&gt;
        &lt;/pr&gt;
    &lt;/Part&gt;
&lt;/OpenCReport&gt;
			</programlisting>
		</para>
		<para>
			Example XML skeleton structure with
			<literal>&lt;Part&gt;</literal> as
			the toplevel node:
			<programlisting>
&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;
			</programlisting>
		</para>
		<para>
			Example XML skeleton structure with
			a standalone <literal>&lt;Report&gt;</literal> node:
			<programlisting>
&lt;Report&gt;
    ...
&lt;/Report&gt;
			</programlisting>
		</para>
		<para>
			When <literal>&lt;Report&gt;</literal> is the
			toplevel node, parent nodes for
			<literal>&lt;Part&gt;</literal>, <literal>&lt;pr&gt;</literal>
			and <literal>&lt;pd&gt;</literal> are implicitly
			created. Subsections and many attributes specific to
			these parent nodes can be used as shortcuts in the
			<literal>&lt;Report&gt;</literal> node.
		</para>
		<sect2 id="reportattribs" xreflabel="Report attributes">
			<title>Report attributes</title>
			<sect3 id="reportfontname" xreflabel="Report font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the report's scope. It can be overridden by
					child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>
&lt;Report font_name="Arial"&gt;
&lt;Report fontName="Arial"&gt;
					</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is what's set for
					<xref linkend="partfontname"/>, or
					<literal>Courier</literal> if both are unset.
				</para>
			</sect3>
			<sect3 id="reportfontsize" xreflabel="Report font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the report's scope. It can be overridden by
					child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>
&lt;Report font_size="10"&gt;
&lt;Report fontSize="10"&gt;
					</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font name is what's set for
					<xref linkend="partfontsize"/>, or
					<literal>12</literal> if both are unset.
				</para>
			</sect3>
			<sect3>
				<title>Size unit</title>
				<para>
					Shortcut for the <xref linkend="sizeunit"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Report&gt;</literal> is the toplevel node.
					<programlisting>
&lt;Report size_unit="default"&gt;
&lt;Report size_unit="rlib"&gt;
&lt;Report size_unit="points"&gt;
					</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> or
					<literal>&lt;Part&gt;</literal> is the toplevel
					node in the report XML description, this attribute
					for <literal>&lt;Report&gt;</literal> is ignored.
				</para>
			</sect3>
			<sect3>
				<title>RLIB compatibility</title>
				<para>
					Shortcut for the <xref linkend="rlibcompat"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Report&gt;</literal> is the toplevel node.
					<programlisting>
&lt;Report rlib_compat="yes"&gt;
&lt;Report rlib_compat="no"&gt;
					</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> is the
					toplevel node in the XML, this attribute for
					<literal>&lt;Report&gt;</literal> is ignored.
				</para>
				<para>
					When <literal>&lt;Report&gt;</literal> is the toplevel
					node, the default is <literal>yes</literal>.
					This helps using OpenCReports as a drop-in replacement
					for RLIB.
				</para>
			</sect3>
			<sect3>
				<title>Orientation</title>
				<para>
					Shortcut for <xref linkend="partpageorientation"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node when
					<literal>&lt;Report&gt;</literal> is standalone.
					<programlisting>
&lt;Report orientation="portrait"&gt;
&lt;Report orientation="landscape"&gt;
					</programlisting>
				</para>
				<para>
					Default is portrait orientation.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3>
				<title>Margin settings</title>
				<para>
					Shortcuts for <xref linkend="marginsettings"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node. Individual
					settings exist for the top, bottom, left and
					right margins of the page. Every setting
					exist in two forms: the RLIB compatible
					"lowerCamelCase" variant and the all lowercase
					with underscore. The lowecase-with-underscore
					variants are the preferred ones.
					<programlisting>
&lt;Report top_margin="0.2"&gt;
&lt;Report topMargin="0.2"&gt;
&lt;Report bottom_margin="0.2"&gt;
&lt;Report bottomMargin="0.2"&gt;
&lt;Report left_margin="0.2"&gt;
&lt;Report leftMargin="0.2"&gt;
&lt;Report right_margin="0.2"&gt;
&lt;Report rightMargin="0.2"&gt;
					</programlisting>
				</para>
				<para>
					When <literal>size_unit="rlib"</literal> is in effect
					(the default case) the margin unit is inches.
					The margin unit is points (1/72th inches) when
					<literal>size_unit="points"</literal> is in effect.
				</para>
				<para>
					Default values for the top, bottom, left and right
					margins are all 0.2, regardless of the unit.
				</para>
				<para>
					Note that <literal>rightMargin</literal> didn't exist
					in RLIB.
				</para>
				<para>
					These settings for <literal>&lt;Report&gt;</literal>
					are ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3>
				<title>Paper type</title>
				<para>
					Shortcut for <xref linkend="papertype"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node. It exists in
					two forms: the RLIB compatible "lowerCamelCase"
					variant and the all lowercase with underscore.
					The lowecase-with-underscore variant is preferred.
					<programlisting>
&lt;Part paper_type="A4"&gt;
&lt;Part paperType="A4"&gt;
					</programlisting>
				</para>
				<para>
					Default value is the current system paper type
					that <ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>
					uses. E.g. if the system is set to US English,
					the default paper type is implicitly
					<literal>letter</literal>. In most of Europe,
					the default paper type is <literal>A4</literal>
				</para>
				<para>
					The paper type can be specified in either lower case
					or upper case, both are accepted.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="reportheight" xreflabel="Report height">
				<title>Height</title>
				<para>
					Height of the report.
			<programlisting>
&lt;Report height="120"&gt;
			</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the report height is measured in characters,
					which is controlled by <xref linkend="reportfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="reportfontname"/>. Report height is
					computed from the font height.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, height is measured
					in points.
				</para>
				<para>
					Report details are layed out up to the the
					specified height. When the whole report
					fits in the specified height, the next report's
					starting point on the page depends on
					<xref linkend="rlibcompat"/>.
				</para>
				<para>
					When RLIB compatibility is not set, then the height
					of this report is unconditionally applied, i.e.
					any subsequent <literal>&lt;Report&gt;</literal>
					follows with the vertical padding, i.e. the remaining
					empty space is added up to the fixed height.
					If height is unset for the parent
					<literal>&lt;pd&gt;</literal> node, it is expanded
					with this vertical padding.
				</para>
				<para>
					When RLIB compatibility is set, the vertical
					padding is only applied between 
					<literal>&lt;Report&gt;</literal>s in the parent
					<literal>&lt;pd&gt;</literal> node but not
					after the last <literal>&lt;Report&gt;</literal>
					if it is shorter than the specified height.
					The specified height would still limit the displayed
					rows for the last <literal>&lt;Report&gt;</literal>
					if it would run longer than the specified height.
				</para>
				<para>
					In case height is set for both the parent
					<literal>&lt;pd&gt;</literal> node and the
					<literal>&lt;Report&gt;</literal> nodes in it,
					the height value for <literal>&lt;pd&gt;</literal>
					is applied first. It would limit the displayed
					rows in whichever <literal>&lt;Report&gt;</literal> node
					is terminated by it. Subsequent
					<literal>&lt;Report&gt;</literal> nodes would
					no be displayed in that <literal>&lt;pd&gt;</literal>
					node.
				</para>
				<para>
					Note, that OpenCReports allows fixed-height
					reports to break over page boundaries.
					This is a deviation from RLIB.
				</para>
			</sect3>
			<sect3>
				<title>Iterations</title>
				<para>
					The same <literal>&lt;Report&gt;</literal> may be
					executed multiple times.
					<programlisting>
&lt;Report iterations="3"&gt;
					</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Reports may be suppressed.
					<programlisting>
&lt;Report suppress="yes"&gt;
&lt;Report suppress="val(m.suppress_report)"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
			<sect3>
				<title>Suppress page header on the first page</title>
				<para>
					Shortcut for <xref linkend="suppresspageheaderfirstpage"/>
					in the implicitly created parent
					<literal>&lt;Part&gt;</literal> node when
					<literal>&lt;Report&gt;</literal> is the
					toplevel node.
					<programlisting>
&lt;Report suppressPageHeaderFirstPage="yes"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="reportqueryname" xreflabel="Report query name">
				<title>Query</title>
				<para>
					Set the primary query name for <literal>&lt;Report&gt;</literal>
					from the list of <xref linkend="queries"/>.
					<programlisting>
&lt;Report query="query1"&gt;
					</programlisting>
				</para>
				<para>
					Default value is unset, i.e. use the first
					query from the list of <xref linkend="queries"/>.
				</para>
			</sect3>
			<sect3>
				<title>Field header priority</title>
				<para>
					Set the field header priority for the report versus
					break (header and footer) priority. This setting
					selects which report detail is encompassing the other.
					<programlisting>
&lt;Report field_header_priority="low"&gt;
					</programlisting>
				</para>
				<para>
					Default value is <literal>high</literal>. In this
					mode, the field header is printed on the top of every
					page of the report and break headers and footers are
					encompassed by it. The default is chosen for RLIB
					compatibility.
				</para>
				<para>
					When this setting is <literal>low</literal>,
					field headers are handled with lower priority
					compared to break headers and footers. In this
					mode, a break header is followed by the field header,
					then data rows (field details), followed by the break
					footer. This brings the field header closer to the field
					details.
				</para>
			</sect3>
			<sect3>
				<title>Border width</title>
				<para>
					This is a shortcut for <xref linkend="pdborderwidth"/>
					for the implicitly created <literal>&lt;pd&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					It is measured in points.
			<programlisting>
&lt;Report border_width="2"&gt;
			</programlisting>
				</para>
				<para>
					When set, a rectangle around the part column
					(in this case, around the single report in the
					part column) will be drawn. The width of outline
					of the rectangle is measured in points.
				</para>
				<para>
					This is a deviation from RLIB where the width
					of the outline was a fixed 0.1 points and an
					inner margin (all of top, bottom, left and right)
					inside the column border was used. Also, this shortcut
					didn't exist in RLIB, the <literal>&lt;pd&gt;</literal>
					node had to be present.
				</para>
				<para>
					If the report (column) breaks over a page boundary,
					the border will be drawn the column parts
					on every page. 
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;pd&gt;</literal> node.
				</para>
			</sect3>
			<sect3>
				<title>Border color</title>
				<para>
					This is a shortcut for <xref linkend="pdbordercolor"/>
					for the implicitly created <literal>&lt;pd&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					When <literal>border_width</literal> is set,
					this color is used to draw the border rectangle.
					<programlisting>
&lt;Report border_color="'blue'"&gt;
					</programlisting>
				</para>
				<para>
					See <xref linkend="colorspec"/>
				</para>
			</sect3>
			<sect3>
				<title>Detail columns</title>
				<para>
					Shortcut for <xref linkend="detailcolumns"/>
					in the implicitly created parent
					<literal>&lt;pd&gt;</literal> when
					<literal>&lt;Parent&gt;</literal> is the
					toplevel node.
					<programlisting>
&lt;Report detail_columns="3"&gt;
					</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
				<para>
					This setting for <literal>&lt;Parent&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;pd&gt;</literal> node in the report
					XML description.
				</para>
			</sect3>
			<sect3>
				<title>Column padding</title>
				<para>
					Shortcut for <xref linkend="columnpadding"/>
					in the implicitly created parent
					<literal>&lt;pd&gt;</literal> node when
					<literal>&lt;Parent&gt;</literal> is the
					toplevel node.
					<programlisting>
&lt;Report column_pad="0.2"&gt;
					</programlisting>
				</para>
				<para>
					Default value is 0, i.e. no padding.
				</para>
				<para>
					The unit of padding is inches if
					<xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (default), points
					otherwise.
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Report subsections</title>
			<sect3>
				<title>Page header</title>
				<para>
					This is a shortcut for <xref linkend="pageheader"/>
					in the implicitly created <literal>&lt;Part&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>
&lt;Report&gt;
    &lt;PageHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageHeader&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
				<para>
					This subsection for <literal>&lt;Report&gt;</literal>
					is ignored when there is a page footer section
					defined for the <literal>&lt;Part&gt;</literal> node,
					either in the <literal>&lt;Part&gt;</literal> node
					itself or in a previous child <literal>&lt;Report&gt;</literal>
					node for the same <literal>&lt;Part&gt;</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Page footer</title>
				<para>
					This is a shortcut for <xref linkend="pagefooter"/>
					in the implicitly created <literal>&lt;Part&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>
&lt;Report&gt;
    &lt;PageFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageFooter&gt;
&lt;/Part&gt;
					</programlisting>					
				</para>
				<para>
					This subsection for <literal>&lt;Report&gt;</literal>
					is ignored when there is a page footer section
					defined for the <literal>&lt;Part&gt;</literal> node,
					either in the <literal>&lt;Part&gt;</literal> node
					itself or in a previous child <literal>&lt;Report&gt;</literal>
					node for the same <literal>&lt;Part&gt;</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Report header</title>
				<para>
					This is the description of the report header that is
					emitted at the start of the report.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>
&lt;Report&gt;
    &lt;ReportHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/ReportHeader&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Report footer</title>
				<para>
					This is the description of the report footer that is
					emitted at the end of the report.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>
&lt;Report&gt;
    &lt;ReportFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/ReportFooter&gt;
&lt;/Part&gt;
					</programlisting>					
				</para>
			</sect3>
			<sect3>
				<title>Variables</title>
				<para>
					This section describes the
					<xref linkend="variablesnode"/> in the report.
					<programlisting>
&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable ... /&gt;
        ...
    &lt;/Variables&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Breaks</title>
				<para>
					This section describes the
					<xref linkend="breaksnode"/> in the report.
					<programlisting>
&lt;Report&gt;
    &lt;Breaks&gt;
        &lt;Break ... &gt;
            ...
        &lt;/Break&gt;
        ...
    &lt;/Breaks&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detail</title>
				<para>
					This section describes the tabular details of the report.
					There are two subsections in this node, both contain
					an <xref linkend="outputnode"/>.
					<programlisting>
&lt;Report&gt;
    &lt;Detail&gt;
        &lt;FieldHeaders&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/FieldHeaders&gt;
        &lt;FieldDetails&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/FieldDetails&gt;
    &lt;/Detail&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
				<para>
					<literal>&lt;FieldHeaders&gt;</literal> is used
					to describe the header for data rows.
				</para>
				<para>
					<literal>&lt;FieldDetails&gt;</literal> is used
					to show data that is derived from the current data row
					produced by the report query.
				</para>
			</sect3>
			<sect3>
				<title>Alternate output for no data</title>
				<para>
					This section describes the alternate output of the report
					when the query has no data rows, or there is no such
					query name defined that's set in
					<xref linkend="reportqueryname"/>.
					It contains an <xref linkend="outputnode"/>.
				</para>
				<para>
					This section may be declared in two ways. One way is to
					spell out the <literal>&lt;Alternate&gt;</literal> node:
					<programlisting>
&lt;Report&gt;
    &lt;Alternate&gt;
        &lt;NoData&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/NoData&gt;
    &lt;/Alternate&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
				<para>
					The other way is without the
					<literal>&lt;Alternate&gt;</literal> node:
					<programlisting>
&lt;Report&gt;
    &lt;NoData&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/NoData&gt;
&lt;/Part&gt;
					</programlisting>
				</para>
				<para>
					When the <xref linkend="reportqueryname"/>
					does not exist in in the global list of
					<xref linkend="queries"/> and the
					<xref linkend="rlibcompat"/> is set, then
					the <literal>&lt;NoData&gt;</literal> section
					is not displayed.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="loadedreport" xreflabel="Loaded report">
		<title>Loaded report</title>
		<para>
			It is like an inline report, but the
			<xref linkend="report"/> is loaded from
			a different file.
		</para>
		<sect2>
			<title>Loaded Report attributes</title>
			<sect3>
				<title>File name</title>
				<para>
					<programlisting>
&lt;load name="report1.xml" /&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Query</title>
				<para>
					The <literal>query</literal> attribute overrides
					the same attribute of <literal>&lt;Report&gt;</literal>.
					This way, the report in the separate file can be reused
					for a different data set.
					<programlisting>
&lt;load query="query1" /&gt;
					</programlisting>
				</para>
				<para>
					When <xref linkend="rlibcompat"/> is set and the
					<xref linkend="reportqueryname"/> is set to
					a non-existing name in the global list of
					<xref linkend="queries"/>, the
					<literal>&lt;NoData&gt;</literal> section
					is not displayed.
				</para>
			</sect3>
			<sect3>
				<title>Iterations</title>
				<para>
					The <literal>iterations</literal> attribute overrides
					the same attribute of <literal>&lt;Report&gt;</literal>.
					<programlisting>
&lt;load iterations="5" /&gt;
					</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="variablesnode" xreflabel="Variables">
		<title>Variables</title>
		<para>
			This is the parent node for individual
			<literal>&lt;Variable&gt;</literal> nodes
			that describe each variable.
			<programlisting>
&lt;Variables&gt;
    &lt;Variable ... /&gt;
    ...
&lt;/Variables&gt;
			</programlisting>
		</para>
	</sect1>
	<sect1 id="variablenode" xreflabel="Variable node">
		<title>Variable</title>
		<para>
			This node describes one
			<literal>&lt;Variable&gt;</literal> node.
			It has no children nodes, only attributes.
			<programlisting>
&lt;Variable ... /&gt;
			</programlisting>
		</para>
		<sect2>
			<title>Variable attributes</title>
			<sect3>
				<title>Name</title>
				<para>
					The name of the variable. It must be
					unique in the list of variables for
					the parent <literal>&lt;Report&gt;</literal> node.
					<programlisting>
&lt;Variable name="var1" /&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Value</title>
				<para>
					The "value" of the variable, or rather,
					the expression from which the value is
					computed. Variables' values are computed
					for every data row produced by the report
					query. The expression may therefore reference
					field names of queries that are declared
					in the XML description or in programming code.
					<programlisting>
&lt;Variable value="q1.field1 + 2 * q2.field2" /&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Type</title>
				<para>
					The type of the variable. Several variable
					types exist:
					<programlisting>
&lt;Variable value="q1.field" type="expression"/&gt;

&lt;Variable value="q1.field" type="count"/&gt;
&lt;Variable value="q1.field" type="countall"/&gt;

&lt;Variable value="q1.field" type="sum"/&gt;

&lt;Variable value="q1.field" type="average"/&gt;
&lt;Variable value="q1.field" type="averageall"/&gt;

&lt;Variable value="q1.field" type="highest"/&gt;
&lt;Variable value="q1.field" type="lowest"/&gt;

&lt;Variable value="q1.field" type="custom"/&gt;
					</programlisting>
				</para>
				<para>
					Default type is <literal>expression</literal>,
					this is just a shortcut for the value expression
					that saves both typing and time to generate the
					report.
				</para>
				<para>
					The <literal>count</literal> and
					<literal>countall</literal> variable
					types count the the number of expression
					results for the data set. The former
					leaves out NULL values, the latter includes them.
					This is equivalent to COUNT(field) and COUNT(*)
					in SQL.
				</para>
				<para>
					The <literal>sum</literal> variable type
					sums the non-NULL values of the expression
					results for the data set.
				</para>
				<para>
					The <literal>average</literal> and
					<literal>averageall</literal> variable types
					are combinations of <literal>sum</literal>
					and either <literal>count</literal> or
					<literal>countall</literal>. They take the value
					computed for each data row, sums them, and
					divide by the number of values. The result
					of <literal>average</literal> and
					<literal>averageall</literal> may differ if
					there is NULL data in the result set.
				</para>
				<para>
					The <literal>highest</literal> and
					<literal>lowest</literal> variable types
					return the highest and the lowest values
					for the data set, respectively.
				</para>
				<para>
					The <literal>custom</literal> variable type
					allow arbitrary user variables if the
					predefined types are not enough.
				</para>
			</sect3>
			<sect3>
				<title>Attributes to define a Custom variable</title>
				<para>
					These attributes below define a custom variable.
					A base expression, up to two intermediary expressions
					and one result expression may be defined, together
					with the expression type.
					<programlisting>
&lt;Variable
    baseexpr="..."
    intermedexpr="..."
    intermed2expr="..."
    resultexpr="..."
    basetype="..."
    type="custom"/&gt;
					</programlisting>
				</para>
				<para>
					<literal>baseexpr</literal>, <literal>intermedexpr</literal>,
					<literal>intermed2expr</literal> and <literal>resultexpr</literal>
					are <xref linkend="expressions"/>.
				</para>
				<para>
					Possible values for <literal>basetype</literal> are
					<literal>number</literal>, <literal>string</literal>
					or <literal>datetime</literal>.
				</para>
				<para>
					It's the user's responsibility to use expressions
					valid for the base type. Failing that, the result
					value will be an apppropriate error message.
				</para>
				<para>
					Note that the <literal>baseexpr</literal> attribute
					is an alias for <literal>value</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Reset on break</title>
				<para>
					A variable may reset on break boundaries to the
					<literal>baseexpr</literal> value. See
					<xref linkend="breaknode"/> and <xref linkend="breaks"/>
					<programlisting>
&lt;Variable resetonbreak="break1" /&gt;
					</programlisting>
				</para>
				<para>
					Default is unset, i.e. no reset on a break.
				</para>
			</sect3>
			<sect3>
				<title>Precalculate (delayed)</title>
				<para>
					A variable may work two ways. One is to generate
					the current value that lead to it up to the current row.
					Say, for a variable of the <literal>average</literal>
					type, the value of the variable for the 5th row
					is the average value of the base expression of the
					first 5 rows.
				</para>
				<para>
					The other way is to calculate the value for the last
					data row and provide that value for every data row.
					The attribute is accepted under two names:
					<programlisting>
&lt;Variable precalculate="yes" /&gt;
&lt;Variable delayed="yes" /&gt;
					</programlisting>
				</para>
				<para>
					Default is <literal>no</literal>.
				</para>
				<para>
					<literal>precalculate="yes"</literal> (or
					<literal>delayed="yes"</literal> may be combined
					with <literal>resetonbreak="..."</literal>.
					In this case, the "precalculated" value is computed
					for break periods.
				</para>
				<para>
					Precalculated values may be used to show values in
					<literal>&lt;ReportHeader&gt;</literal>,
					<literal>&lt;ReportFooter&gt;</literal>,
					<literal>&lt;FieldHeaders&gt;</literal>,
					<literal>&lt;BreakHeader&gt;</literal> and
					<literal>&lt;BreakFooter&gt;</literal>
					but not in
					<literal>&lt;PageHeader&gt;</literal> and
					<literal>&lt;PageFooter&gt;</literal>.
					The reason for this is that the former headers and
					footers are in <literal>&lt;Report&gt;</literal>
					scope with a query. On the other hand, the latter
					two are in <literal>&lt;Part&gt;</literal> scope
					that don't know about queries.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="breaksnode" xreflabel="Breaks">
		<title>Breaks</title>
		<para>
			This is the parent node for individual
			<literal>&lt;Break&gt;</literal> nodes
			that describe each break. See <xref linkend="breaks"/>
			<programlisting>
&lt;Breaks&gt;
    &lt;Break ... /&gt;
    ...
&lt;/Break&gt;
			</programlisting>
		</para>
	</sect1>
	<sect1 id="breaknode" xreflabel="Break node">
		<title>Break</title>
		<para>
			This node describes one
			<literal>&lt;Break&gt;</literal>.
			<programlisting>
&lt;Break ... &gt;
    &lt;BreakHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/BreakHeader&gt;
    &lt;BreakFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/BreakFooter&gt;
    &lt;BreakFields&gt;
        &lt;BreakField /&gt;
        ...
    &lt;/BreakFields&gt;
&lt;/Break&gt;
			</programlisting>
		</para>
		<sect2>
			<title>Break attributes</title>
			<sect3>
				<title>Name</title>
				<para>
					The name of the break. It must be
					unique in the list of breaks for
					the parent <literal>&lt;Report&gt;</literal> node.
					<programlisting>
&lt;Break name="break1" /&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Newpage</title>
				<para>
					Accepted as part of RLIB compatibility.
					Not implemented.
					<programlisting>
&lt;Break newpage="yes" /&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Header on new page</title>
				<para>
					Accepted as part of RLIB compatibility.
					Not implemented.
					<programlisting>
&lt;Break headernewpage="yes" /&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Suppress blank break contents</title>
				<para>
					Accepted as part of RLIB compatibility.
					Not implemented.
					<programlisting>
&lt;Break suppressblank="yes" /&gt;
					</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Break subsections</title>
			<sect3>
				<title>BreakHeader</title>
				<para>
					The break header is emitted before the new data row
					if there's a change for the values in the set of
					break fields.
					It contains an <xref linkend="outputnode"/> child node.
					<programlisting>
&lt;BreakHeader&gt;
    &lt;Output&gt;
        ...
    &lt;/Output&gt;
&lt;/BreakHeader&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>BreakFooter</title>
				<para>
					The break header is emitted after the previous data row
					if there's a change for the values in the set of
					break fields.
					It contains an <xref linkend="outputnode"/> child node.
					<programlisting>
&lt;BreakHeader&gt;
    &lt;Output&gt;
        ...
    &lt;/Output&gt;
&lt;/BreakHeader&gt;
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>BreakFields</title>
				<para>
					The break fields node contains one or more
					<xref linkend="breakfield"/> children nodes.
					<programlisting>
&lt;BreakFields&gt;
    &lt;BreakField ... /&gt;
    ...
&lt;/BreakFields&gt;
					</programlisting>
				</para>
				<sect4 id="breakfield" xreflabel="BreakField">
					<title>BreakField</title>
					<para>
						The break field node only has one attribute and
						contains no child nodes.
						<programlisting>
&lt;BreakField value="..."/&gt;
						</programlisting>
					</para>
					<para>
						The sole attribute in
						<literal>&lt;BreakField&gt;</literal> is
						<literal>&lt;value&gt;</literal> where the
						expression watched for changes is declared.
						See <xref linkend="expressions"/>.
					</para>
				</sect4>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="outputnode" xreflabel="Output node">
		<title>Output</title>
		<para>
			The <literal>&lt;Output&gt;</literal> section is used
			by many previously mentioned sections. This is the
			generic node that described how details are displayed
			in reports.
		</para>
	</sect1>
	<sect1 id="colorspec" xreflabel="Color specification">
		<title>Color specification</title>
		<para>
			Colors may be specified by name or in HTML notation.
		</para>
	</sect1>
</chapter>

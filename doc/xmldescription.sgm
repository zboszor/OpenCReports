<chapter id="xmldescriptor" xreflabel="XML description">
	<title>Report XML description</title>
	<sect1>
		<title>XML description structure</title>
		<para>
			<ulink url="https://github.com/zboszor/OpenCReports">OpenCReports</ulink>
			uses an
			<ulink url="https://github.com/SICOM/rlib">RLIB</ulink>-compatible
			report description with extensions.
		</para>
		<para>
			The report XML description, like all XML files start with
			declaring that it's an XML file and the optional declaration
			of the Document Type Definition that the XML file can be
			checked against. For an OpenCReports report description,
			the first two lines are:
			<programlisting>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE OpenCReport SYSTEM "opencreport.dtd"&gt;</programlisting>
			The DTD file <literal>opencreport.dtd</literal> can be
			found in the sources of OpenCReports
			<ulink url="https://github.com/zboszor/OpenCReports/blob/main/opencreport.dtd">here</ulink>.
		</para>
		<para>
			After the XML header lines, a fully specified report
			description looks like this:
			<programlisting>&lt;OpenCReport&gt;
    &lt;Datasources&gt;
        ...
    &lt;/Datasources&gt;
    &lt;Queries&gt;
        ...
    &lt;/Queries&gt;
    &lt;Part&gt;
        &lt;pr&gt;
            &lt;pd&gt;
                &lt;Report&gt;
                    ...
                &lt;/Report&gt;
            &lt;/pd&gt;
        &lt;/pr&gt;
    &lt;/Part&gt;
&lt;/OpenCReport&gt;</programlisting>
			or like this:
			<programlisting>&lt;OpenCReport&gt;
    &lt;Datasources&gt;
        ...
    &lt;/Datasources&gt;
    &lt;Queries&gt;
        ...
    &lt;/Queries&gt;
    &lt;Report&gt;
        ...
    &lt;/Report&gt;
&lt;/OpenCReport&gt;</programlisting>
		</para>
		<para>
			The XML sections <xref linkend="datasources"/>
			and <xref linkend="queries"/> are optional in the XML
			description. They can be substituted by program code
			using the datasource and query related calls in the
			<xref linkend="lowlevelapi"/>, similarly to RLIB.
		</para>
		<para>
			For RLIB compatibility, a report description may start
			with either <literal>&lt;Part&gt;</literal> or
			<literal>&lt;Report&gt;</literal> as the toplevel node.
			In this case, there's no other way to add datasources
			and queries, but through program code, like the
			<xref linkend="lowlevelapi"/>.
		</para>
		<para>
			Since XML files are hierarchical with a single toplevel
			node with child nodes, multiple
			<literal>&lt;Report&gt;</literal>s were only possible
			if using <literal>&lt;Part&gt;</literal> as the
			toplevel node with all the nodes having to be spelled
			out between <literal>&lt;Part&gt;</literal> and
			<literal>&lt;Report&gt;</literal>. With
			<literal>&lt;OpenCReport&gt;</literal> being the
			toplevel node, multiple <literal>&lt;Report&gt;</literal>
			child nodes can be used without the parent
			<literal>&lt;Part&gt;</literal> node.
		</para>
		<sect2>
			<title>Notes about XML syntax and attributes</title>
			<para>
				Most (if not all) XML attributes in the report
				description file are handled with the expression
				parser (see <xref linkend="expressions"/>), with fallback
				to literal strings if the the location of expression
				wouldn't allow identifier references at that location.
			</para>
			<para>
				For example, the datasource name may be declared this way:
				<programlisting>&lt;Datasource name="mysource" ... /&gt;</programlisting>
				where the name is a literal string. Or this way:
				<programlisting>&lt;Datasource name="'mysource'" ... /&gt;</programlisting>
				where the name is a string expression. (Note the
				extra quotes.) Or even this way:
				<programlisting>&lt;Datasource name="&amp;quot;mysource&amp;quot;" ... /&gt;</programlisting>
				where name is a string expression which uses the
				<literal>"</literal> double quote character which
				must be "escaped" according to XML rules. This last
				variant is less readable than the first two.
				Nevertheless, it is usable and it works, so machine
				generated XML files may also be used.
			</para>
			<para>
				The first form is a regular XML string value.
				Since expression parsing would find that
				<literal>mysource</literal> is an identifier
				which may be a query column name and this is not
				a valid place for a query reference, the non-parsed
				string value is used.
			</para>
			<para>
				The second form is a single quoted OpenCReports
				string constant. The parsed string constant's
				value is used.
			</para>
			<para>
				The third form is a double quoted OpenCReports
				string constant, but in XML the double quote
				character must be substituted with
				<literal>&amp;quot;</literal> because they are
				reserved for quoting the attribute values.
				The parsed string constant's value is used.
				(This substitution is called "string escaping"
				and various other formats require some kind of
				substutition for reserved characters.)
			</para>
			<para>
				To make the XML easier to read, the second form
				is recommended because it still allows
				embedding the single quote character inside
				a string (see <xref linkend="xmldescriptor"/>)
				in case e.g. a strong password contains this.
				For security-by-obscurity, the third form may
				be used because it is harder to read. For all
				special characters that should be escaped in
				XML, see
				<ulink url="https://stackoverflow.com/a/46637835/290085">Simplified XML Escaping</ulink>.
			</para>
		</sect2>
	</sect1>
	<sect1 id="ocrpttopxml" xreflabel="OpenCReport element">
		<title>OpenCReport element</title>
		<para>
			The toplevel <literal>&lt;OpenCReport&gt;</literal>
			element controls some global settings and serves
			as the topmost XML element for child elements.
		</para>
		<sect2 id="sizeunit" xreflabel="Size unit attribute">
			<title>Size unit attribute</title>
			<para>
				The <literal>size_unit</literal> attribute
				specifies report behaviour for size related
				settings:
				<programlisting>&lt;OpenCReport size_unit="rlib"&gt;
&lt;OpenCReport size_unit="points"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>rlib</literal>
				which is the legacy RLIB behavior, with the
				known inconsistency in size related settings:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							width for <literal>field</literal> and
							<literal>literal</literal> (see
							<xref linkend="outputnode"/>) are in
							number of characters. This is influenced
							by the font size set in either
							<xref linkend="partfontsize"/>,
							<xref linkend="reportfontsize"/> or
							<xref linkend="linefontsize"/>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							height for <xref linkend="partcol"/>
							is measured in number of characters
							influenced by <xref linkend="partfontsize"/>
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							height for <xref linkend="report"/>
							is measured in number of characters
							influenced by <xref linkend="partfontsize"/>
							and <xref linkend="reportfontsize"/>
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							width of horizontal lines and the
							optional border width around reports
							are specified in points
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							gaps between columns of multi-column
							reports is measured in inches
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Note that the default setting (as in RLIB)
				only ever expected monospace fonts that have the
				same width for every character. It also expected that
				the character height is identical to the character
				width. The latter detail is false for many monospace
				fonts, i.e. their height is usually greater than
				their width.
			</para>
			<para>
				With proportional fonts (where the width of
				characters depend on their image, i.e. an "i" is
				thinner than an "m") width of text fields cannot
				reliably be set in "number of characters" because
				it's not an exact value. There is a workaround for
				this in <literal>OpenCReports</literal> but it's
				an over-engineered solution and isn't available
				in RLIB so it's not backward compatible either.
				But it's there if someone wants to port reports
				from RLIB and only make superficial changes.
				See <xref linkend="textelemwidth"/>.
			</para>
			<para>
				When <literal>size_unit</literal> is set to
				<literal>points</literal>, all size related
				settings in the report are in points,
				a.k.a. 1/72th inch. Straightforward and consistent.
			</para>
		</sect2>
		<sect2 id="noqueryshownodata" xreflabel="No query show NoData attribute">
			<title>No query show NoData</title>
			<para>
				This controls whether <xref linkend="nodatanode"/>
				is shown when the report's <xref linkend="queryattr"/>
				is set to a non-existing query name.
				<programlisting>&lt;OpenCReport noquery_show_nodata="yes"&gt;
&lt;OpenCReport noquery_show_nodata="no"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>true</literal> when
				<literal>OpenCReport</literal> is the toplevel node,
				<literal>false</literal> when either
				<literal>&lt;Part&gt;</literal> or <literal>&lt;Report&gt;</literal>
				is the toplevel node for RLIB compatibility.
				See <xref linkend="nodatanode"/>.
			</para>
		</sect2>
		<sect2 id="reportheightafterlast" xreflabel="Report height after last attribute">
			<title>Report height after last</title>
			<para>
				It controls whether report height is applied
				after the last <literal>&lt;Report&gt;</literal>
				in the <literal>&lt;pd&gt;</literal> node.
				<programlisting>&lt;OpenCReport report_height_after_last="yes"&gt;
&lt;OpenCReport report_height_after_last="no"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>false</literal>.
			</para>
		</sect2>
	</sect1>
	<sect1 id="datasources" xreflabel="Datasources">
		<title>Datasources</title>
		<para>
			Datasources in OpenCReports are either database
			connections, or accessors (mini-drivers) for data
			files in certain formats.
		</para>
		<para>
			Datasource descriptions are in the following format:
			<programlisting>&lt;Datasources&gt;
    &lt;Datasource name="mysource" type="..." ... /&gt;
&lt;/Datasources&gt;</programlisting>
		</para>
		<para>
			A report may have multiple datasources, i.e.
			the description may list multiple
			<literal>&lt;Datasource&gt;</literal> lines.
		</para>
		<para>
			Datasources must have unique names in a report and
			their type may be:
			<literal>mariadb</literal> (or <literal>mysql</literal>),
			<literal>postgresql</literal>, <literal>odbc</literal>,
			<literal>csv</literal>, <literal>json</literal>,
			<literal>xml</literal> or <literal>array</literal>.
		</para>
		<sect2 id="mariadbds" xreflabel="MariaDB database connection">
			<title>MariaDB (MySQL) database connection</title>
			<para>
				A MariaDB database connection may be declared in three
				ways. Either by using the database host and port,
				the database name, user name and password directly:
				<programlisting>&lt;Datasource
    name="mysource" type="mariadb"
    host="..." port="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or alternatively, instead of the host and port,
				specifying the UNIX Domain Socket file for
				a local connection if it's not in the standard
				location:
				<programlisting>&lt;Datasource
    name="mysource" type="mariadb"
    unix_socket="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or moving these details out to an external
				configuration file in an INI file format:
				<programlisting>&lt;Datasource
    name="mysource" type="mariadb"
    optionfile="myconn.cnf" group="myconn" /&gt;</programlisting>
			</para>
			<para>
				In the second case, the configuration file <literal>myconn.cnf</literal>
				would contain something like this:
				<programlisting>[myconn]
!include /etc/my.cnf
database=mydb
user=myuser
#password=
#host=
#port=
#unix_socket=</programlisting>
				Please note that the INI group name <literal>[myconn]</literal>
				matches <literal>group="myconn"</literal> in the above
				datasource declaration.
			</para>
			<para>
				The database name and user name are mandatory. The
				user password is optional, depending on the database
				security authentication setup.
			</para>
			<para>
				The database host and port, or the socket file location
				are all optional. Without these, a local connection is
				attempted using the default settings. If the host name
				is specified but the port isn't, the remote host is
				used on the default port (as known by the local MariaDB
				database client library).
			</para>
		</sect2>
		<sect2 id="postgresqlds" xreflabel="PostgreSQL database connection">
			<title>PostgreSQL database connection</title>
			<para>
				A PostgreSQL database connection may be declared in three
				ways. Either by using the database host and port,
				the database name, user name and password directly:
				<programlisting>&lt;Datasource
    name="mysource" type="postgresql"
    host="..." port="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or alternatively, instead of the host and port,
				specifying the UNIX Domain Socket file for
				a local connection if it's not in the standard
				location:
				<programlisting>&lt;Datasource
    name="mysource" type="postgresql"
    unix_socket="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or using a so called connection string:
				<programlisting>&lt;Datasource
    name="mysource" type="postgresql"
    connstr="..." /&gt;</programlisting>
			</para>
			<para>
				For the connection string format, see the
				<ulink url="https://www.postgresql.org/docs">PostgreSQL documentation</ulink>.
			</para>
			<para>
				The database name and user name are mandatory. The
				user password is optional, depending on the database
				security authentication setup.
			</para>
			<para>
				The database host and port, or the socket file location
				are all optional. Without these, a local connection is
				attempted using the default settings. If the host name
				is specified but the port isn't, the remote host is
				used on the default port (as known by the local PostgreSQL
				database client library).
			</para>
		</sect2>
		<sect2 id="odbcds" xreflabel="ODBC database connection">
			<title>ODBC database connection</title>
			<para>
				The above described MariaDB and PostgreSQL database
				connection types are using their respective client
				libraries. There is a more generic way, i.e. ODBC.
				ODBC was invented by Microsoft in the 1990s for Windows.
				See
				<ulink url="https://docs.microsoft.com/en-us/sql/odbc/microsoft-open-database-connectivity-odbc">Microsoft Open Database Connectivity (ODBC)</ulink>
				In their solution, there's an abstract client library
				and individual database drivers adhere to the APIs
				offered by ODBC toplevel library. Since then, UNIX and
				UNIX-like systems also gained their ODBC client libraries
				in two different implementations, both of which are
				supported by OpenCReports:
				<ulink url="https://www.unixodbc.org">unixODBC</ulink>
				and
				<ulink url="https://www.iodbc.org">iODBC</ulink>.
			</para>
			<para>
				An ODBC database setup is done a differently. There are
				two system-wide configuration files. The first one is
				<literal>odbcinst.ini</literal> that lists the database
				drivers installed into the system. The second one is
				<literal>odbc.ini</literal> which references the first
				one and lists pre-defined database connections. These
				database connections are named. In ODBC speak, these
				are called Data Source Names or DSNs. The DSNs specify
				the low level connection parameters, like the database
				host and port, and optionally the user name and
				password, too.
			</para>
			<para>
				Thus, an ODBC database connection may be declared in two
				ways. The first way is by using the DSN name, and
				optionally the user name and password:
				<programlisting>&lt;Datasource
    name="mysource" type="odbc"
    dbname="..." user="..." password="..." /&gt;</programlisting>
				In this case, the <literal>dbname</literal> attribute
				is not the low level database name, but the ODBC
				abstract DSN name.
			</para>
			<para>
				There's also a way to use the so called connection string
				which contain the same connection information:
				<programlisting>&lt;Datasource
    name="mysource" type="odbc"
    connstr="..." /&gt;</programlisting>
			</para>
			<para>
				For the connection string format, see the
				<ulink url="https://www.connectionstrings.com/">public examples</ulink>.
			</para>
		</sect2>
		<sect2>
			<title>CSV file datasource</title>
			<para>
				CSV ("Comma Separated Values") is a simple tabulated
				file format. Every line must have the same number of
				columns, for which the values are separated by commas.
				The first line in the file contains the column names.
			</para>
			<para>
				A CSV file datasource is declared very simply:
				<programlisting>&lt;Datasource name="mysource" type="'csv'" /&gt;</programlisting>
				In this case, the actual CSV file is not declared,
				only that a "query" using a CSV file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				This datasource is less smart than others, in that
				is cannot specify data type for columns. Every column
				is assumed to be a string, regardless if the values
				themselves are quoted or not in the file. Data
				conversion functions must be used, like
				<literal>val()</literal>, <literal>stodt()</literal>
				or <literal>interval()</literal>.
			</para>
		</sect2>
		<sect2 id="jsonds" xreflabel="JSON file datasource">
			<title>JSON file datasource</title>
			<para>
				Similarly to CSV, the JSON file datasource is also declared
				very simply:
				<programlisting>&lt;Datasource name="mysource" type="'json'" /&gt;</programlisting>
				In this case, the actual JSON file is not declared,
				only that a "query" using a JSON file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				A JSON file datasource is expected in this format:
				<programlisting>{
    "columns": ["colname1", ... ],
    "coltypes": ["type", ... ],
    "rows": [
	    { "colname1": value1, ...  },
        ...
    ]
}</programlisting>
			</para>
			<para>
				The JSON file is expected to list the column
				names in a string array called <literal>columns</literal>.
			</para>
			<para>
				The column types are optionally listed in the string
				array called <literal>coltypes</literal>. If they are
				listed, the <literal>coltypes</literal> array must have
				the same number of strings as the <literal>columns</literal>
				array. The types may be <literal>string</literal>,
				<literal>number</literal> or <literal>datatime</literal>.
				If the column type array is missing, then all data
				values are assumed to be strings and data conversion
				functions must be used, like <literal>val()</literal>,
				<literal>stodt()</literal> or <literal>interval()</literal>.
			</para>
			<para>
				The rows are listed in an array called <literal>rows</literal>
				and column data values for each row are in a collection
				with data names from the <literal>columns</literal> and
				data types from the <literal>coltypes</literal> arrays.
			</para>
		</sect2>
		<sect2 id="xmlds" xreflabel="XML file datasource">
			<title>XML file datasource</title>
			<para>
				Similarly to CSV and JSON, the XML file datasource is also declared
				very simply:
				<programlisting>&lt;Datasource name="mysource" type="'xml'" /&gt;</programlisting>
				In this case, the actual XML file is not declared,
				only that a "query" using an XML file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				An XML file datasource is expected in this format:
				<programlisting>&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;rows&gt;
        &lt;row&gt;
            &lt;col&gt;value&lt;/col&gt;
            ...
        &lt;/row&gt;
        ...
    &lt;/rows&gt;
    &lt;fields&gt;
        &lt;field&gt;column1&lt;/field&gt;
        ...
    &lt;/fields&gt;
    &lt;coltypes&gt;
        &lt;col&gt;type1&lt;/col&gt;
        ...
    &lt;/coltypes&gt;
&lt;/data&gt;</programlisting>
				The XML section names <literal>&lt;data&gt;</literal>,
				<literal>&lt;rows&gt;</literal> and
				<literal>&lt;fields&gt;</literal>
				are the same as they were in RLIB for its XML data
				source. The order of <literal>&lt;rows&gt;</literal>
				and <literal>&lt;fields&gt;</literal> is not important.
				But the order of field names in <literal>&lt;fields&gt;</literal>
				must match the column value order in each
				<literal>&lt;row&gt;</literal>.
			</para>
			<para>
				The section &lt;coltypes&gt; is new in OpenCReports and
				is optional. If it's present, then it must list
				the data types in the same order as the section
				<literal>&lt;fields&gt;</literal>.
				The types may be <literal>string</literal>,
				<literal>number</literal> or <literal>datatime</literal>.
				If this section is not present, all values are assumed
				to be strings and data conversion functions must be
				used, like <literal>val()</literal>, <literal>stodt()</literal>
				or <literal>interval()</literal>.
			</para>
		</sect2>
		<sect2>
			<title>Array datasource</title>
			<para>
				Arrays are global in-memory structures in the
				application that should be accessible to the
				OpenCReports library. For example, when using
				the C programming language, global non-static
				symbols are visible to libraries if the application
				is compiled with <literal>-rdynamic</literal>.
			</para>
			<para>
				Similarly to file based datasources, the array
				datasource is declared very simply:
				<programlisting>&lt;Datasource name="mysource" type="'array'" /&gt;</programlisting>
				In this case, the actual array is not declared,
				only that a "query" using an array will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				A C array is declared in this format:
				<programlisting>const char *array[ROWS + 1][COLUMNS] = {
    { "column1", ... },
    { "value1",  ... },
    ...
};</programlisting>
				The array is declared as a two-dimensional array of
				C strings. The first row of the array is the column
				names, <literal>[ROWS + 1]</literal> in the array
				declaration accounts for the title row.
			</para>
			<para>
				All rows have the same number of columns. Column values
				may be NULL, in which case they will be treated the same
				as SQL NULLs in SQL query results.
			</para>
			<para>
				Optionally, a column types array is declared
				separately:
				<programlisting>#include &lt;opencreport.h&gt;

const enum ocrpt_result_type coltypes[COLUMNS] = {
    ...
};</programlisting>
				If this array is present, it must have the same number
				of <literal>COLUMNS</literal> as the matching data
				array. The <literal>enum ocrpt_result_type</literal>
				usable in data array type declaration are
				<literal>OCRPT_RESULT_STRING</literal>,
				<literal>OCRPT_RESULT_NUMBER</literal> and
				<literal>OCRPT_RESULT_DATETIME</literal>. 
			</para>
		</sect2>
	</sect1>
	<sect1 id="queries" xreflabel="Queries">
		<title>Queries</title>
		<para>
			Queries in OpenCReports are SQL queries for database
			connections, or data files files in certain formats.
			The queries are declared like this:
			<programlisting>&lt;Queries&gt;
    &lt;Query name="..." ... /&gt;
    ...
&lt;/Queries&gt;</programlisting>
		</para>
		<sect2>
			<title>SQL queries for SQL datasources</title>
			<para>
				SQL queries for MariaDB, PostgreSQL and ODBC
				datasources may be declared two ways, either
				as the XML value for <literal>&lt;Query&gt;</literal>:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"&gt;
SELECT * FROM some_table
&lt;/Query&gt;</programlisting>
				or as the <literal>value</literal> attribute:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    value="SELECT * FROM some_table" /&gt;</programlisting>
			</para>
			<para>
				Note, that the XML attribute <literal>datasource="..."</literal>
				must match a previously declared datasource.
			</para>
			<para>
				The SQL query can be any <literal>SELECT</literal>
				statement.
			</para>
			<sect3>
				<title>Special note for SQL datasources</title>
				<para>
					The database client libraries for MariaDB,
					PostgreSQL and ODBC return all the query rows
					from the database server at once by default.
					As such, it is possible that a long query result
					doesn't fit into the computer memory.
				</para>
				<para>
					The report needs to traverse the query result twice
					to pre-compute "delayed" values (see
					<xref linkend="precalcexpr"/> and
					<xref linkend="precalcvar"/>),
					so it needs to be able to rewind the data set
					once it was read to the end.
				</para>
				<para>
					The alternative API in MariaDB to load the rows one by
					one doesn't allow rewinding, so it's not usable
					for the report's purposes.
				</para>
				<para>
					It is only PostgreSQL that allows using an
					<emphasis>SQL cursor</emphasis> as a standalone entity,
					i.e. outside SQL procedures as defined by the SQL
					standard. This PostgreSQL extension to the standard
					allows saving memory in such a way that it allows
					processing very long queries. Behind the scenes,
					a <literal>WITH HOLD</literal> cursor is used and
					1024 rows are loaded in one go from the server.
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Queries for file based datasources</title>
			<para>
				Queries for CSV, XML and JSON datasources may
				be declared two ways. Either as the XML value for
				<literal>&lt;Query&gt;</literal>:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
&gt;xmldata.xml&lt;/Query&gt;</programlisting>
					or as the <literal>value</literal> attribute:
					<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    value="'xmldata.xml'" /&gt;</programlisting>
			</para>
			<para>
				Notes:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The XML attribute <literal>datasource="..."</literal>
							must match a previously declared datasource.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							It is recommended that the <literal>value="..."</literal>
							form is used, since it's not ensured that
							whitespace before or after the file name
							is trimmed in the first variant if the XML
							is "beautified". The file name that the
							OpenCReports library receives must be correct
							in order to use it.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The declaration must specify a file in the
							correct format for the datasource type.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The optional type declaration for columns
							in the XML and JSON file formats, or for CSV,
							the complete lack of it can be supplemented
							with a memory array using the optional
							<literal>coltypes="..."</literal> attribute.
							For details, see the <xref linkend="arrayqueries"/>.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2 id="arrayqueries" xreflabel="Array queries">
			<title>Queries for array based datasources</title>
			<para>
				Queries for array datasources may be declared two ways.
				Either as the XML value for
				<literal>&lt;Query&gt;</literal>:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    coltypes="'coltypes'"
    rows="30"
    cols="6"
&gt;array&lt;/Query&gt;</programlisting>
					or as the <literal>value</literal> attribute:
					<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    value="'array'"
    coltypes="'coltypes'"
    rows="30"
    cols="6" /&gt;</programlisting>
			</para>
			<para>
				Notes:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The XML attribute <literal>datasource="..."</literal>
							must match a previously declared datasource.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							It is recommended that the <literal>value="..."</literal>
							form is used, since it's not ensured that
							whitespace before or after the symbol name
							is trimmed in the first variant if the XML
							is "beautified". The symbol name that the
							OpenCReports library receives must be correct
							in order to use it. The array name must match
							the correct global symbol name. It will be
							looked up via <literal>dlsym()</literal>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							Similarly to the array symbol name, the
							<literal>coltypes="..."</literal> array name
							must match the correct global symbol name.
							It will be looked up via <literal>dlsym()</literal>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The value for <literal>cols</literal>
							must match the second dimension of the
							data array.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The value for <literal>rows</literal>
							must be one less than the first dimension
							of the C data array. (The title row is not
							counted in the XML description.)
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Failing to fulfill the above may cause crashes
				or wrong data to be used in the report.
			</para>
		</sect2>
		<sect2 id="followerqueries" xreflabel="Follower queries">
			<title>Follower queries</title>
			<para>
				Multiple queries may be declared. But by default,
				only the first one is actually used by a report.
			</para>
			<para>
				Secondary queries may be associated with the
				primary query as so called "follower" queries.
				Any query may be a follower to the primary query.
			</para>
			<para>
				There are two kinds of follower queries:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							regular, or basic follower queries, and
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							so called N:1 (N-to-one) followers in RLIB
							speak.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<sect3>
				<title>Regular follower queries</title>
				<para>
					A follower query is run along the primary query and
					their rows are laid out side by side. The first row
					of the follower query is assigned the first row of the
					primary query. The second row of the follower query
					is assigned to the second row of the primary query,
					and so on. The number of rows of the complete data
					set is determined by the primary query. If the
					follower query runs out of rows before the primary,
					the columns values will be presented as SQL NULLs.
				</para>
				<para>
					This is similar to using <literal>LEFT OUTER JOIN</literal>
					and using <literal>ROWNUM</literal> in Oracle or
					the <literal>row_number()</literal> SQL function
					in PostgreSQL as the matching value between the
					primary query and the follower query.
				</para>
				<para>
					A regular follower query is declared by adding
					the <literal>follower_for="..."</literal> attribute.
					The value for <literal>follower_for="..."</literal>
					is the <literal>name</literal> of a previously
					declared query. Example:
					<programlisting>&lt;Query
    name="myquery1"
    datasource="mysource1"
    value="'SELECT * FROM table1'" /&gt;

&lt;Query
    name="myquery2"
    datasource="mysource2"
    value="'SELECT * FROM table1'"
    follower_for="myquery1" /&gt;</programlisting>
				</para>
				<para>
					In this example, two queries of two different
					datasources are used. This is one of the advantages
					of using follower queries, i.e. data from different
					databases may be used. Nowadays, with foreign
					queries implemented in e.g. PostgreSQL, its use
					case is more limited.
				</para>
			</sect3>
			<sect3>
				<title>N:1 follower queries</title>
				<para>
					An N:1 follower query, for all intents and
					purposes, is the right side query in a
					<literal>LEFT OUTER JOIN</literal> query, with
					the primary query on the left side. Rows of the
					main query and the follower query are matched
					according to the boolean expression specified
					with the <literal>follower_expr="..."</literal>
					attribute. Example:
					<programlisting>&lt;Query
    name="myquery1"
    datasource="mysource1"
    value="'SELECT * FROM table1'" /&gt;

&lt;Query
    name="myquery2"
    datasource="mysource2"
    value="'SELECT * FROM table1'"
    follower_for="myquery1"
    follower_expr="myquery1.id = myquery2.id" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="parts" xreflabel="Report parts">
		<title>Report parts</title>
		<para>
			A report XML may contain multiple actual reports.
			Such a <literal>&lt;Part&gt;</literal> may be
			under the toplevel <literal>&lt;OpenCReport&gt;</literal>
			node, in which case multiple report parts may exist
			in the same XML, or it may be the toplevel node of
			the XML. In the latter case, only a single
			<literal>&lt;Part&gt;</literal>	may exist in the XML.
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
            ...
        &lt;/pd&gt;
        ...
    &lt;/pr&gt;
    ...
&lt;/Part&gt;</programlisting>
		</para>
		<para>
			A report <literal>&lt;Part&gt;</literal> may consist
			multiple reports, arranged in
			<itemizedlist>
				<listitem override="bullet">
					<para>
						rows (<literal>&lt;pr&gt;</literal>),
					</para>
				</listitem>
				<listitem override="bullet">
					<para>
						columns in rows (<literal>&lt;pd&gt;</literal>), and
					</para>
				</listitem>
				<listitem override="bullet">
					<para>
						reports (<literal>&lt;Report&gt;</literal>) arranged
						vertically in a column.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			The rows and columns in rows do not form a grid as rows are
			independent of each other. E.g. one row may contain two columns,
			the next one may contain three, the next one may contain one.
			It is completely freeform.
		</para>
		<para>
			This allows very complex report layouts.
			One possible application of such a complex layout is printed forms.
		</para>
		<sect2 id="partattribs" xreflabel="Part attributes">
			<title>Part attributes</title>
			<sect3 id="partfontname" xreflabel="Part font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the report part's global scope. It can be
					overridden by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_name="Arial"&gt;
&lt;Part fontName="Arial"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is <literal>Courier</literal>.
				</para>
			</sect3>
			<sect3 id="partfontsize" xreflabel="Part font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the report part's global scope. It can be
					overridden by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_size="10"&gt;
&lt;Part fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font size is 12.
				</para>
			</sect3>
			<sect3>
				<title>Size unit</title>
				<para>
					Shortcut for the <xref linkend="sizeunit"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>&lt;Part size_unit="default"&gt;
&lt;Part size_unit="rlib"&gt;
&lt;Part size_unit="points"&gt;</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> is the
					toplevel node in the XML, this attribute for
					<literal>&lt;Part&gt;</literal> is ignored.
				</para>
			</sect3>
			<sect3>
				<title>No query show NoData attribute</title>
				<para>
					Shortcut for <xref linkend="noqueryshownodata"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
                    <literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>noquery_show_nodata="yes"
noquery_show_nodata="no"</programlisting>
				</para>
				<para>
					See default in <xref linkend="noqueryshownodata"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3>
				<title>Report height after last attribute</title>
				<para>
					Shortcut for <xref linkend="reportheightafterlast"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>report_height_after_last="yes"
report_height_after_last="no"</programlisting>
				</para>
				<para>
					See default in <xref linkend="reportheightafterlast"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3 id="partpageorientation" xreflabel="Part page orientation">
				<title>Orientation</title>
				<para>
					Page orientation for the whole
					<literal>&lt;Part&gt;</literal>.
					<programlisting>&lt;Part orientation="portrait"&gt;
&lt;Part orientation="landscape"&gt;</programlisting>
				</para>
				<para>
					Default is portrait orientation.
				</para>
			</sect3>
			<sect3 id="marginsettings" xreflabel="Margin settings">
				<title>Margin settings</title>
				<para>
					Margin settings for the page for the whole
					<literal>&lt;Part&gt;</literal>. Individual
					settings exist for the top, bottom, left and
					right margins of the page. Every setting
					exist in two forms: the RLIB compatible
					"lowerCamelCase" variant and the all lowercase
					with underscore. The lowecase-with-underscore
					variants are the preferred ones.
					<programlisting>&lt;Part top_margin="0.2"&gt;
&lt;Part topMargin="0.2"&gt;
&lt;Part bottom_margin="0.2"&gt;
&lt;Part bottomMargin="0.2"&gt;
&lt;Part left_margin="0.2"&gt;
&lt;Part leftMargin="0.2"&gt;
&lt;Part right_margin="0.2"&gt;
&lt;Part rightMargin="0.2"&gt;</programlisting>
				</para>
				<para>
					When <literal>size_unit="rlib"</literal> is in effect
					(the default case) the margin unit is inches.
					The margin unit is points (1/72th inches) when
					<literal>size_unit="points"</literal> is in effect.
				</para>
				<para>
					Default values for the top, bottom, left and right
					margins are all 0.2, regardless of the unit.
				</para>
				<para>
					Note that <literal>rightMargin</literal> didn't exist
					in RLIB.
				</para>
			</sect3>
			<sect3 id="papertype" xreflabel="Paper type">
				<title>Paper type</title>
				<para>
					Paper type (implicitly: page size) for the whole
					<literal>&lt;Part&gt;</literal>. It exists in
					two forms: the RLIB compatible "lowerCamelCase"
					variant and the all lowercase with underscore.
					The lowecase-with-underscore variant is preferred.
					<programlisting>&lt;Part paper_type="A4"&gt;
&lt;Part paperType="A4"&gt;</programlisting>
				</para>
				<para>
					Default value is the current system paper type
					that <ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>
					uses. E.g. if the system is set to US English,
					the default paper type is implicitly
					<literal>letter</literal>. In most of Europe,
					the default paper type is <literal>A4</literal>
				</para>
				<para>
					The paper type can be specified in either lower case
					or upper case, both are accepted.
				</para>
			</sect3>
			<sect3>
				<title>Iterations</title>
				<para>
					The same <literal>&lt;Part&gt;</literal> may be
					executed multiple times.
					<programlisting>&lt;Part iterations="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
				<para>
					Note that <literal>&lt;Part&gt;</literal>s and
					every iteration of one starts on a new page.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Report parts may be suppressed.
					<programlisting>&lt;Part suppress="yes"&gt;
&lt;Part suppress="val(m.suppress_part)"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't - change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
			<sect3 id="suppresspageheaderfirstpage" xreflabel="Suppress page header on the first page">
				<title>Suppress page header on the first page</title>
				<para>
					The <literal>&lt;PageHeader&gt;</literal> section
					(see <xref linkend="pageheader"/> below)
					for <literal>&lt;Part&gt;</literal> may be
					suppressed on the first page.
					<programlisting>&lt;Part suppressPageHeaderFirstPage="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>.
				</para>
				<para>
					Note that this suppression applies only to
					the first page of the complete result (e.g. PDF)
					and not to the first page of an iteration, which
					may fall on a later page of the result.  
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Part subsections</title>
			<para>
				As described in <xref linkend="parts"/>,
				a <literal>&lt;Part&gt;</literal> may contain
				one or more report rows (<literal>&lt;pr&gt;</literal>)
				which in turn may contain one or more columns
				(<literal>&lt;pr&gt;</literal>). See
				<xref linkend="partrow"/> and <xref linkend="partcol"/>.
			</para>
			<sect3 id="pageheader" xreflabel="Page header">
				<title>Page header</title>
				<para>
					This is the description of the page header.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Part&gt;
    &lt;PageHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageHeader&gt;
&lt;/Part&gt;</programlisting>					
				</para>
			</sect3>
			<sect3 id="pagefooter" xreflabel="Page footer">
				<title>Page footer</title>
				<para>
					This is the description of the page footer.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Part&gt;
    &lt;PageFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageFooter&gt;
&lt;/Part&gt;</programlisting>					
				</para>
			</sect3>
			<sect3>
				<title>Part row</title>
				<para>
					See <xref linkend="partrow"/>.
					<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            ...
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<sect4>
					<title>Part row subsections</title>
					<sect5>
						<title>Part column</title>
						<para>
							See <xref linkend="partcol"/>.
						</para>
					</sect5>
				</sect4>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="partrow" xreflabel="Part row">
		<title>Part row</title>
		<para>
			A part row (<literal>&lt;pr&gt;</literal>) may
			contain one or more <xref linkend="partcol"/>s
			(<literal>&lt;pd&gt;</literal>) which are layed out
			side by side horizontally. The longest running column
			will control the height of the row. The next row will
			be continuous from that vertical page position.
		</para>
		<sect2>
			<title>Part row attributes</title>
			<sect3>
				<title>Layout</title>
				<para>
					The <literal>layout</literal> attribute exists mainly
					for RLIB compatibility, it's ignored.
					It accepts two values: <literal>flow</literal> and
					<literal>fixed</literal>.
					<programlisting>&lt;pr layout="flow"&gt;
&lt;pr layout="fixed"&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>New page</title>
				<para>
					The <literal>newpage</literal> attribute controls
					whether the part row starts from the point where
					the previous row in the same part ended, or it
					should start on a new page.
					<programlisting>&lt;pr newpage="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Report rows may be suppressed.
					<programlisting>&lt;pr suppress="yes"&gt;
&lt;pr suppress="val(m.suppress_row)"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't - change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="partcol" xreflabel="Part column">
		<title>Part column</title>
		<para>
			A part column (<literal>&lt;pd&gt;</literal>) may
			contain one or more <xref linkend="report"/>s
			(<literal>&lt;Report&gt;</literal>) which are layed
			out vertically in this column continuously.
		</para>
		<para>
			Such a report may be inlined:
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
		</para>
		<para>
			A report may also be loaded from a separate file.
			For details, see <xref linkend="loadedreport"/>.
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;load ... /&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
		</para>
		<sect2>
			<title>Part column attributes</title>
			<sect3>
				<title>Width</title>
				<para>
					Width of the part column.
			<programlisting>&lt;pd width="60"&gt;</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the column width is measured in characters,
					which is controlled by <xref linkend="partfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="partfontname"/>. Width is computed
					from the font width.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, width is measured
					in points.
				</para>
				<para>
					Columns without explicitly specified width are
					dynamically sized according to
					<xref linkend="papertype"/>,
					<xref linkend="marginsettings"/>
					and columns with explicitly specified width.
				</para>
				<para>
					Columns that exceed the total page width
					(according to <xref linkend="papertype"/> and
					<xref linkend="marginsettings"/>) will be shown
					partially, or won't be shown at all.
				</para>
			</sect3>
			<sect3>
				<title>Height</title>
				<para>
					Height of the part column.
			<programlisting>&lt;pd height="120"&gt;</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the column height is measured in characters,
					which is controlled by <xref linkend="partfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="partfontname"/>. Column height is
					computed from the font height.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, height is measured
					in points.
				</para>
				<para>
					Report details in this part column are layed out
					up to the specified height. See
					<xref linkend="reportheight"/> for further explanation.
				</para>
				<para>
					Note, that OpenCReports allows fixed height
					columns to break over page boundaries. This is a
					deviation from RLIB.
				</para>
			</sect3>
			<sect3 id="pdborderwidth" xreflabel="Part column border width">
				<title>Border width</title>
				<para>
					Border width around the part column.
					It is measured in points.
					<programlisting>&lt;pd border_width="2"&gt;</programlisting>
				</para>
				<para>
					When set, a rectangle around the part column
					will be drawn. The width of outline of the
					rectangle is measured in points.
				</para>
				<para>
					This is a deviation from RLIB where the width
					of the outline was a fixed 0.1 points and an
					inner margin (all of top, bottom, left and right)
					inside the column border was used.
				</para>
				<para>
					If the column breaks over a page boundary,
					the border will be drawn the column parts
					on every page. 
				</para>
			</sect3>
			<sect3 id="pdbordercolor" xreflabel="Part column border color">
				<title>Border color</title>
				<para>
					When <literal>border_width</literal> is set,
					this color is used to draw the border rectangle.
					<programlisting>&lt;pd border_color="'blue'"&gt;</programlisting>
				</para>
				<para>
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="detailcolumns" xreflabel="Detail columns">
				<title>Detail columns</title>
				<para>
					Inner <literal>&lt;Report&gt;</literal>s
					are layed out in one or more columns.
					<programlisting>&lt;pd detail_columns="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
			</sect3>
			<sect3 id="columnpadding" xreflabel="Column padding">
				<title>Column padding</title>
				<para>
					When <literal>detail_columns</literal>
					is set to higher than 1, inner padding
					between the detail columns may be specified.
					<programlisting>&lt;pd column_pad="0.2"&gt;</programlisting>
				</para>
				<para>
					Default value is 0, i.e. no padding.
				</para>
				<para>
					The unit of padding is inches if
					<xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (default), points
					otherwise.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Report columns may be suppressed.
					<programlisting>&lt;pd suppress="yes"&gt;
&lt;pd suppress="val(m.suppress_column)"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't - change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="report" xreflabel="Report">
		<title>Report</title>
		<para>
			This section may occur in a wider context or
			standalone in an XML description file.
		</para>
		<para>
			Example XML skeleton structure with
			<literal>&lt;OpenCReport&gt;</literal> as
			the toplevel node:
			<programlisting>&lt;OpenCReport&gt;
    &lt;Part&gt;
        &lt;pr&gt;
            &lt;pd&gt;
                &lt;Report&gt;
                    ...
                &lt;/Report&gt;
            &lt;/pd&gt;
        &lt;/pr&gt;
    &lt;/Part&gt;
&lt;/OpenCReport&gt;</programlisting>
		</para>
		<para>
			Example XML skeleton structure with
			<literal>&lt;Part&gt;</literal> as
			the toplevel node:
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
		</para>
		<para>
			Example XML skeleton structure with
			a standalone <literal>&lt;Report&gt;</literal> node:
			<programlisting>&lt;Report&gt;
    ...
&lt;/Report&gt;</programlisting>
		</para>
		<para>
			When <literal>&lt;Report&gt;</literal> is the
			toplevel node, parent nodes for
			<literal>&lt;Part&gt;</literal>, <literal>&lt;pr&gt;</literal>
			and <literal>&lt;pd&gt;</literal> are implicitly
			created. Subsections and many attributes specific to
			these parent nodes can be used as shortcuts in the
			<literal>&lt;Report&gt;</literal> node.
		</para>
		<sect2 id="reportattribs" xreflabel="Report attributes">
			<title>Report attributes</title>
			<sect3 id="reportfontname" xreflabel="Report font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the report's scope. It can be overridden by
					child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Report font_name="Arial"&gt;
&lt;Report fontName="Arial"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is what's set for
					<xref linkend="partfontname"/>, or
					<literal>Courier</literal> if both are unset.
				</para>
			</sect3>
			<sect3 id="reportfontsize" xreflabel="Report font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the report's scope. It can be overridden by
					child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Report font_size="10"&gt;
&lt;Report fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font name is what's set for
					<xref linkend="partfontsize"/>, or
					<literal>12</literal> if both are unset.
				</para>
			</sect3>
			<sect3>
				<title>Size unit</title>
				<para>
					Shortcut for the <xref linkend="sizeunit"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Report&gt;</literal> is the toplevel node.
					<programlisting>&lt;Report size_unit="default"&gt;
&lt;Report size_unit="rlib"&gt;
&lt;Report size_unit="points"&gt;</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> or
					<literal>&lt;Part&gt;</literal> is the toplevel
					node in the report XML description, this attribute
					for <literal>&lt;Report&gt;</literal> is ignored.
				</para>
			</sect3>
			<sect3>
				<title>No query show NoData attribute</title>
				<para>
					Shortcut for <xref linkend="noqueryshownodata"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
                    <literal>&lt;Report&gt;</literal> is the toplevel node.
					<programlisting>&lt;Report noquery_show_nodata="yes"&gt;
&lt;Report noquery_show_nodata="no&gt;</programlisting>
				</para>
				<para>
					See default in <xref linkend="noqueryshownodata"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3>
				<title>Report height after last attribute</title>
				<para>
					Shortcut for <xref linkend="reportheightafterlast"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>&lt;Report report_height_after_last="yes"&gt;
&lt;Report report_height_after_last="no"&gt;</programlisting>
				</para>
				<para>
					See default in <xref linkend="reportheightafterlast"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3>
				<title>Orientation</title>
				<para>
					Shortcut for <xref linkend="partpageorientation"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node when
					<literal>&lt;Report&gt;</literal> is standalone.
					<programlisting>&lt;Report orientation="portrait"&gt;
&lt;Report orientation="landscape"&gt;</programlisting>
				</para>
				<para>
					Default is portrait orientation.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3>
				<title>Margin settings</title>
				<para>
					Shortcuts for <xref linkend="marginsettings"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node. Individual
					settings exist for the top, bottom, left and
					right margins of the page. Every setting
					exist in two forms: the RLIB compatible
					"lowerCamelCase" variant and the all lowercase
					with underscore. The lowecase-with-underscore
					variants are the preferred ones.
					<programlisting>&lt;Report top_margin="0.2"&gt;
&lt;Report topMargin="0.2"&gt;
&lt;Report bottom_margin="0.2"&gt;
&lt;Report bottomMargin="0.2"&gt;
&lt;Report left_margin="0.2"&gt;
&lt;Report leftMargin="0.2"&gt;
&lt;Report right_margin="0.2"&gt;
&lt;Report rightMargin="0.2"&gt;</programlisting>
				</para>
				<para>
					When <literal>size_unit="rlib"</literal> is in effect
					(the default case) the margin unit is inches.
					The margin unit is points (1/72th inches) when
					<literal>size_unit="points"</literal> is in effect.
				</para>
				<para>
					Default values for the top, bottom, left and right
					margins are all 0.2, regardless of the unit.
				</para>
				<para>
					Note that <literal>rightMargin</literal> didn't exist
					in RLIB.
				</para>
				<para>
					These settings for <literal>&lt;Report&gt;</literal>
					are ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3>
				<title>Paper type</title>
				<para>
					Shortcut for <xref linkend="papertype"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node. It exists in
					two forms: the RLIB compatible "lowerCamelCase"
					variant and the all lowercase with underscore.
					The lowecase-with-underscore variant is preferred.
					<programlisting>&lt;Part paper_type="A4"&gt;
&lt;Part paperType="A4"&gt;</programlisting>
				</para>
				<para>
					Default value is the current system paper type
					that <ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>
					uses. E.g. if the system is set to US English,
					the default paper type is implicitly
					<literal>letter</literal>. In most of Europe,
					the default paper type is <literal>A4</literal>
				</para>
				<para>
					The paper type can be specified in either lower case
					or upper case, both are accepted.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="reportheight" xreflabel="Report height">
				<title>Height</title>
				<para>
					Height of the report.
					<programlisting>&lt;Report height="120"&gt;</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the report height is measured in characters,
					which is controlled by <xref linkend="reportfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="reportfontname"/>. Report height is
					computed from the font height.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, height is measured
					in points.
				</para>
				<para>
					Report details are layed out up to the
					specified height. If the report would run longer
					than the specified height, it gets truncated.
					When the report fits in the specified height,
					the next report's starts with the remaining height
					added as padding before it.
				</para>
				<para>
					If the <literal>&lt;Report&gt;</literal> is the last
					one in the <literal>&lt;pd&gt;</literal> node, then
					the report may or may not be padded with the remaining
					height, depending on the
					<xref linkend="reportheightafterlast"/>.
				</para>
				<para>
					If height is unset for the parent
					<literal>&lt;pd&gt;</literal> node, it is expanded
					with this vertical padding.
				</para>
				<para>
					In case height is set for both the parent
					<literal>&lt;pd&gt;</literal> node and the
					<literal>&lt;Report&gt;</literal> nodes in it,
					the height value for <literal>&lt;pd&gt;</literal>
					is applied first. It would limit the displayed
					rows in whichever <literal>&lt;Report&gt;</literal> node
					is terminated by it. Subsequent
					<literal>&lt;Report&gt;</literal> nodes would
					no be displayed in that <literal>&lt;pd&gt;</literal>
					node.
				</para>
				<para>
					Note, that OpenCReports allows fixed-height
					reports to break over page boundaries.
					This is a deviation from RLIB.
				</para>
			</sect3>
			<sect3>
				<title>Iterations</title>
				<para>
					The same <literal>&lt;Report&gt;</literal> may be
					executed multiple times.
					<programlisting>&lt;Report iterations="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Reports may be suppressed.
					<programlisting>&lt;Report suppress="yes"&gt;
&lt;Report suppress="val(m.suppress_report)"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't - change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
			<sect3>
				<title>Suppress page header on the first page</title>
				<para>
					Shortcut for <xref linkend="suppresspageheaderfirstpage"/>
					in the implicitly created parent
					<literal>&lt;Part&gt;</literal> node when
					<literal>&lt;Report&gt;</literal> is the
					toplevel node.
					<programlisting>&lt;Report suppressPageHeaderFirstPage="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="reportqueryname" xreflabel="Report query name">
				<title>Query</title>
				<para>
					Set the primary query name for <literal>&lt;Report&gt;</literal>
					from the list of <xref linkend="queries"/>.
					<programlisting>&lt;Report query="query1"&gt;</programlisting>
				</para>
				<para>
					Default value is unset, i.e. use the first
					query from the list of <xref linkend="queries"/>.
				</para>
			</sect3>
			<sect3>
				<title>Field header priority</title>
				<para>
					Set the field header priority for the report versus
					break (header and footer) priority. This setting
					selects which report detail is encompassing the other.
					<programlisting>&lt;Report field_header_priority="low"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>high</literal>. In this
					mode, the field header is printed on the top of every
					page of the report and break headers and footers are
					encompassed by it. The default is chosen for RLIB
					compatibility.
				</para>
				<para>
					When this setting is <literal>low</literal>,
					field headers are handled with lower priority
					compared to break headers and footers. In this
					mode, a break header is followed by the field header,
					then data rows (field details), followed by the break
					footer. This brings the field header closer to the field
					details.
				</para>
			</sect3>
			<sect3>
				<title>Border width</title>
				<para>
					This is a shortcut for <xref linkend="pdborderwidth"/>
					for the implicitly created <literal>&lt;pd&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					It is measured in points.
					<programlisting>&lt;Report border_width="2"&gt;</programlisting>
				</para>
				<para>
					When set, a rectangle around the part column
					(in this case, around the single report in the
					part column) will be drawn. The width of outline
					of the rectangle is measured in points.
				</para>
				<para>
					This is a deviation from RLIB where the width
					of the outline was a fixed 0.1 points and an
					inner margin (all of top, bottom, left and right)
					inside the column border was used. Also, this shortcut
					didn't exist in RLIB, the <literal>&lt;pd&gt;</literal>
					node had to be present.
				</para>
				<para>
					If the report (column) breaks over a page boundary,
					the border will be drawn the column parts
					on every page. 
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;pd&gt;</literal> node.
				</para>
			</sect3>
			<sect3>
				<title>Border color</title>
				<para>
					This is a shortcut for <xref linkend="pdbordercolor"/>
					for the implicitly created <literal>&lt;pd&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					When <literal>border_width</literal> is set,
					this color is used to draw the border rectangle.
					<programlisting>&lt;Report border_color="'blue'"&gt;</programlisting>
				</para>
				<para>
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3>
				<title>Detail columns</title>
				<para>
					Shortcut for <xref linkend="detailcolumns"/>
					in the implicitly created parent
					<literal>&lt;pd&gt;</literal> when
					<literal>&lt;Parent&gt;</literal> is the
					toplevel node.
					<programlisting>&lt;Report detail_columns="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
				<para>
					This setting for <literal>&lt;Parent&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;pd&gt;</literal> node in the report
					XML description.
				</para>
			</sect3>
			<sect3>
				<title>Column padding</title>
				<para>
					Shortcut for <xref linkend="columnpadding"/>
					in the implicitly created parent
					<literal>&lt;pd&gt;</literal> node when
					<literal>&lt;Parent&gt;</literal> is the
					toplevel node.
					<programlisting>&lt;Report column_pad="0.2"&gt;</programlisting>
				</para>
				<para>
					Default value is 0, i.e. no padding.
				</para>
				<para>
					The unit of padding is inches if
					<xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (default), points
					otherwise.
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Report subsections</title>
			<sect3>
				<title>Page header</title>
				<para>
					This is a shortcut for <xref linkend="pageheader"/>
					in the implicitly created <literal>&lt;Part&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;PageHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageHeader&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					This subsection for <literal>&lt;Report&gt;</literal>
					is ignored when there is a page footer section
					defined for the <literal>&lt;Part&gt;</literal> node,
					either in the <literal>&lt;Part&gt;</literal> node
					itself or in a previous child <literal>&lt;Report&gt;</literal>
					node for the same <literal>&lt;Part&gt;</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Page footer</title>
				<para>
					This is a shortcut for <xref linkend="pagefooter"/>
					in the implicitly created <literal>&lt;Part&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;PageFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageFooter&gt;
&lt;/Part&gt;</programlisting>					
				</para>
				<para>
					This subsection for <literal>&lt;Report&gt;</literal>
					is ignored when there is a page footer section
					defined for the <literal>&lt;Part&gt;</literal> node,
					either in the <literal>&lt;Part&gt;</literal> node
					itself or in a previous child <literal>&lt;Report&gt;</literal>
					node for the same <literal>&lt;Part&gt;</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Report header</title>
				<para>
					This is the description of the report header that is
					emitted at the start of the report.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;ReportHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/ReportHeader&gt;
&lt;/Part&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Report footer</title>
				<para>
					This is the description of the report footer that is
					emitted at the end of the report.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;ReportFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/ReportFooter&gt;
&lt;/Part&gt;</programlisting>					
				</para>
			</sect3>
			<sect3>
				<title>Variables</title>
				<para>
					This section describes the
					<xref linkend="variablesnode"/> in the report.
					<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable ... /&gt;
        ...
    &lt;/Variables&gt;
&lt;/Part&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Breaks</title>
				<para>
					This section describes the
					<xref linkend="breaksnode"/> in the report.
					<programlisting>&lt;Report&gt;
    &lt;Breaks&gt;
        &lt;Break ... &gt;
            ...
        &lt;/Break&gt;
        ...
    &lt;/Breaks&gt;
&lt;/Part&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="detailnode" xreflabel="Detail node">
				<title>Detail</title>
				<para>
					This section describes the tabular details of the report.
					There are two subsections in this node, both contain
					an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;Detail&gt;
        &lt;FieldHeaders&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/FieldHeaders&gt;
        &lt;FieldDetails&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/FieldDetails&gt;
    &lt;/Detail&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					<literal>&lt;FieldHeaders&gt;</literal> is used
					to describe the header for data rows.
				</para>
				<para>
					<literal>&lt;FieldDetails&gt;</literal> is used
					to show data that is derived from the current data row
					produced by the report query.
				</para>
			</sect3>
			<sect3 id="nodatanode" xreflabel="NoData node">
				<title>Alternate output for no data</title>
				<para>
					This section describes the alternate output of the report
					when the query has no data rows, or there is no such
					query name defined that's set in
					<xref linkend="reportqueryname"/>.
					It contains an <xref linkend="outputnode"/>.
				</para>
				<para>
					This section may be declared in two ways. One way is to
					spell out the <literal>&lt;Alternate&gt;</literal> node:
					<programlisting>&lt;Report&gt;
    &lt;Alternate&gt;
        &lt;NoData&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/NoData&gt;
    &lt;/Alternate&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					The other way is without the
					<literal>&lt;Alternate&gt;</literal> node:
					<programlisting>&lt;Report&gt;
    &lt;NoData&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/NoData&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					When the <xref linkend="reportqueryname"/>
					does not exist in in the global list of
					<xref linkend="queries"/> and the
					<xref linkend="noqueryshownodata"/> is set, then
					the <literal>&lt;NoData&gt;</literal> section
					is not displayed.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="loadedreport" xreflabel="Loaded report">
		<title>Loaded report</title>
		<para>
			It is like an inline report, but the
			<xref linkend="report"/> is loaded from
			a different file.
		</para>
		<sect2>
			<title>Loaded Report attributes</title>
			<sect3>
				<title>File name</title>
				<para>
					<programlisting>&lt;load name="report1.xml" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="queryattr" xreflabel="Query attribute">
				<title>Query</title>
				<para>
					The <literal>query</literal> attribute overrides
					the same attribute of <literal>&lt;Report&gt;</literal>.
					This way, the report in the separate file can be reused
					for a different data set.
					<programlisting>&lt;load query="query1" /&gt;</programlisting>
				</para>
				<para>
					When the <xref linkend="noqueryshownodata"/> is set and the
					<xref linkend="reportqueryname"/> is set to
					a non-existing name in the global list of
					<xref linkend="queries"/>, the
					<literal>&lt;NoData&gt;</literal> section
					is not displayed.
				</para>
			</sect3>
			<sect3>
				<title>Iterations</title>
				<para>
					The <literal>iterations</literal> attribute overrides
					the same attribute of <literal>&lt;Report&gt;</literal>.
					<programlisting>&lt;load iterations="5" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="variablesnode" xreflabel="Variables">
		<title>Variables</title>
		<para>
			This is the parent node for individual
			<literal>&lt;Variable&gt;</literal> nodes
			that describe each variable.
			<programlisting>&lt;Variables&gt;
    &lt;Variable ... /&gt;
    ...
&lt;/Variables&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="variablenode" xreflabel="Variable node">
		<title>Variable</title>
		<para>
			This node describes one
			<literal>&lt;Variable&gt;</literal> node.
			It has no children nodes, only attributes.
			<programlisting>&lt;Variable ... /&gt;</programlisting>
		</para>
		<sect2>
			<title>Variable attributes</title>
			<sect3>
				<title>Name</title>
				<para>
					The name of the variable. It must be
					unique in the list of variables for
					the parent <literal>&lt;Report&gt;</literal> node.
					<programlisting>&lt;Variable name="var1" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Value</title>
				<para>
					The "value" of the variable, or rather,
					the expression from which the value is
					computed. Variables' values are computed
					for every data row produced by the report
					query. The expression may therefore reference
					field names of queries that are declared
					in the XML description or in programming code.
					<programlisting>&lt;Variable value="q1.field1 + 2 * q2.field2" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Type</title>
				<para>
					The type of the variable. Several variable
					types exist:
					<programlisting>&lt;Variable value="q1.field" type="expression"/&gt;

&lt;Variable value="q1.field" type="count"/&gt;
&lt;Variable value="q1.field" type="countall"/&gt;

&lt;Variable value="q1.field" type="sum"/&gt;

&lt;Variable value="q1.field" type="average"/&gt;
&lt;Variable value="q1.field" type="averageall"/&gt;

&lt;Variable value="q1.field" type="highest"/&gt;
&lt;Variable value="q1.field" type="lowest"/&gt;

&lt;Variable value="q1.field" type="custom"/&gt;</programlisting>
				</para>
				<para>
					Default type is <literal>expression</literal>,
					this is just a shortcut for the value expression
					that saves both typing and time to generate the
					report.
				</para>
				<para>
					The <literal>count</literal> and
					<literal>countall</literal> variable
					types count the number of expression
					results for the data set. The former
					leaves out NULL values, the latter includes them.
					This is equivalent to COUNT(field) and COUNT(*)
					in SQL.
				</para>
				<para>
					The <literal>sum</literal> variable type
					sums the non-NULL values of the expression
					results for the data set.
				</para>
				<para>
					The <literal>average</literal> and
					<literal>averageall</literal> variable types
					are combinations of <literal>sum</literal>
					and either <literal>count</literal> or
					<literal>countall</literal>. They take the value
					computed for each data row, add them together,
					and divide by the number of values. The result
					of <literal>average</literal> and
					<literal>averageall</literal> may differ if
					there is NULL data in the result set.
				</para>
				<para>
					The <literal>highest</literal> and
					<literal>lowest</literal> variable types
					return the highest and the lowest values
					for the data set, respectively.
				</para>
				<para>
					All of the above pre-defined variables types
					work on numeric data.
				</para>
				<para>
					The <literal>custom</literal> variable type
					allow arbitrary user variables if the
					predefined types are not enough, for example,
					when the base type needs to be something else
					then a number. See below.
				</para>
			</sect3>
			<sect3 id="customvarattrs" xreflabel="Custom variable attributes">
				<title>Custom variable attributes</title>
				<para>
					These attributes below define a custom variable.
					A base expression, up to two intermediary expressions
					and one result expression may be defined, together
					with the expression type.
					<programlisting>&lt;Variable
    baseexpr="..."
    intermedexpr="..."
    intermed2expr="..."
    resultexpr="..."
    basetype="..."
    type="custom"/&gt;</programlisting>
				</para>
				<para>
					<literal>baseexpr</literal>, <literal>intermedexpr</literal>,
					<literal>intermed2expr</literal> and <literal>resultexpr</literal>
					are <xref linkend="expressions"/>.
				</para>
				<para>
					Iterative or recursive variables can use
					<xref linkend="exprself"/>.
				</para>
				<para>
					Possible values for <literal>basetype</literal> are
					<literal>number</literal>, <literal>string</literal>
					or <literal>datetime</literal>.
				</para>
				<para>
					It's the user's responsibility to use expressions
					valid for the base type. Failing that, the result
					value will be an apppropriate error message.
				</para>
				<para>
					Note that the <literal>baseexpr</literal> attribute
					is an alias for <literal>value</literal>.
				</para>
			</sect3>
			<sect3 id="resetonbreak" xreflabel="Reset on break attribute">
				<title>Reset on break</title>
				<para>
					A variable may reset on break boundaries to the
					<literal>baseexpr</literal> value. See
					<xref linkend="breaknode"/> and <xref linkend="breaks"/>
					<programlisting>&lt;Variable resetonbreak="break1" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. no reset on a break.
				</para>
			</sect3>
			<sect3 id="precalcvarattr" xreflabel="Precalculate attribute">
				<title>Precalculate (delayed)</title>
				<para>
					A variable may work two ways. One is to generate an
					immediate value that is either derived from the current
					row, or derived from the current and previous rows.
					Say, for a variable of the <literal>average</literal>
					type, the value of the variable for the 5th row
					is the average value of the base expression of the
					first 5 rows.
				</para>
				<para>
					The other way is <xref linkend="precalcvar"/>,
					that are derived from either the last data row or
					all rows, and supply that value for every data row.
					The attribute is accepted under two names:
					<programlisting>&lt;Variable precalculate="yes" /&gt;
&lt;Variable delayed="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>no</literal>.
				</para>
				<para>
					<literal>precalculate="yes"</literal> (or
					<literal>delayed="yes"</literal> may be combined
					with <literal>resetonbreak="..."</literal>.
					In this case, a precalculated value is
					computed for the break periods separately.
				</para>
				<para>
					Precalculated variables may be used to show values in
					<literal>&lt;ReportHeader&gt;</literal>,
					<literal>&lt;ReportFooter&gt;</literal>,
					<literal>&lt;FieldHeaders&gt;</literal>,
					<literal>&lt;FieldDetails&gt;</literal>,
					<literal>&lt;BreakHeader&gt;</literal> and
					<literal>&lt;BreakFooter&gt;</literal>
					but not in
					<literal>&lt;PageHeader&gt;</literal> and
					<literal>&lt;PageFooter&gt;</literal>.
					The reason for this is that the former headers,
					footers and details are in
					<literal>&lt;Report&gt;</literal> scope with a query.
					On the other hand, the latter two are in
					<literal>&lt;Part&gt;</literal> scope that don't know
					about queries.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="breaksnode" xreflabel="Breaks">
		<title>Breaks</title>
		<para>
			This is the parent node for individual
			<literal>&lt;Break&gt;</literal> nodes
			that describe each break. See <xref linkend="breaks"/>
			<programlisting>&lt;Breaks&gt;
    &lt;Break ... /&gt;
    ...
&lt;/Break&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="breaknode" xreflabel="Break node">
		<title>Break</title>
		<para>
			This node describes one
			<literal>&lt;Break&gt;</literal>.
			<programlisting>&lt;Break ... &gt;
    &lt;BreakHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/BreakHeader&gt;
    &lt;BreakFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/BreakFooter&gt;
    &lt;BreakFields&gt;
        &lt;BreakField /&gt;
        ...
    &lt;/BreakFields&gt;
&lt;/Break&gt;</programlisting>
		</para>
		<sect2>
			<title>Break attributes</title>
			<sect3>
				<title>Name</title>
				<para>
					The name of the break. It must be
					unique in the list of breaks for
					the parent <literal>&lt;Report&gt;</literal> node.
					<programlisting>&lt;Break name="break1" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Newpage</title>
				<para>
					Accepted as part of RLIB compatibility.
					Not implemented.
					<programlisting>&lt;Break newpage="yes" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Header on new page</title>
				<para>
					Accepted as part of RLIB compatibility.
					Not implemented.
					<programlisting>&lt;Break headernewpage="yes" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Suppress blank break contents</title>
				<para>
					Accepted as part of RLIB compatibility.
					Not implemented.
					<programlisting>&lt;Break suppressblank="yes" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Break subsections</title>
			<sect3 id="breakheadernode" xreflabel="BreakHeader">
				<title>BreakHeader</title>
				<para>
					The break header is emitted before the new data row
					if there's a change for the values in the set of
					break fields.
					It contains an <xref linkend="outputnode"/> child node.
					<programlisting>&lt;BreakHeader&gt;
    &lt;Output&gt;
        ...
    &lt;/Output&gt;
&lt;/BreakHeader&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="breakfooternode" xreflabel="BreakFooter">
				<title>BreakFooter</title>
				<para>
					The break header is emitted after the previous data row
					if there's a change for the values in the set of
					break fields.
					It contains an <xref linkend="outputnode"/> child node.
					<programlisting>&lt;BreakHeader&gt;
    &lt;Output&gt;
        ...
    &lt;/Output&gt;
&lt;/BreakHeader&gt;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>BreakFields</title>
				<para>
					The break fields node contains one or more
					<xref linkend="breakfield"/> children nodes.
					<programlisting>&lt;BreakFields&gt;
    &lt;BreakField ... /&gt;
    ...
&lt;/BreakFields&gt;</programlisting>
				</para>
				<sect4 id="breakfield" xreflabel="BreakField">
					<title>BreakField</title>
					<para>
						The break field node only has one attribute and
						contains no child nodes.
						<programlisting>&lt;BreakField value="..."/&gt;</programlisting>
					</para>
					<para>
						The sole attribute in
						<literal>&lt;BreakField&gt;</literal> is
						<literal>&lt;value&gt;</literal> where the
						expression watched for changes is declared.
						See <xref linkend="expressions"/>.
					</para>
					<para>
						There must be at least one
						<literal>&lt;BreakField&gt;</literal> node
						listed. When mode than one break fields
						are listed, then all of them are watched
						for changes.
					</para>
					<para>
						The order in which they are listed matters
						for two reasons.
					</para>
					<para>
						The primary reason is that break fields are
						hierarchical. The break fields listed earlier
						are higher in the hierarchy. If a break field
						earlier in the list triggers, all subsequent
						break fields also trigger implicitly.
					</para>
					<para>
						The second reason is a consequence of the
						previous one: emitting the
						<xref linkend="breakheadernode"/>s
						occur in the order of the list.
						For logical reasons,
						<xref linkend="breakfooternode"/>s
						are in reverse order.
					</para>
				</sect4>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="outputnode" xreflabel="Output node">
		<title>Output</title>
		<para>
			The <literal>&lt;Output&gt;</literal> node is used
			by many previously mentioned sections. This is the
			generic node that described how details are displayed
			in reports.
		</para>
		<sect2>
			<title>Output attributes</title>
			<sect3>
				<title>Suppress</title>
				<para>
					Output nodes may be suppressed as a whole.
					<programlisting>&lt;Output suppress="yes"&gt;
&lt;Output suppress="val(m.suppress_output)"&gt;</programlisting>
				</para>
				<para>
					If it's in a report's
					<literal>&lt;FieldDetails&gt;</literal> node,
					the suppression may depend on query data.
					See <xref linkend="detailnode"/> and
					<xref linkend="expressions"/>.
					<programlisting>&lt;Output suppress="query1.suppress_row"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Output subsections</title>
			<sect3>
				<title>Line</title>
				<para>
					A line containing text elements of varying widths.
					See <xref linkend="linenode"/>.
					<programlisting>&lt;Output&gt;
    &lt;Line&gt;
        ...
    &lt;/Line&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>HorizontalLine</title>
				<para>
					A horizontal line.
					See <xref linkend="hlinenode"/>.
					<programlisting>&lt;Output&gt;
    &lt;HorizontalLine ... /&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Image</title>
				<para>
					An image.
					See <xref linkend="imagenode"/>.
					<programlisting>&lt;Output&gt;
    &lt;Image ... /&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Image end</title>
				<para>
					Terminator for a previous image.
					See <xref linkend="imageendnode"/>.
					<programlisting>&lt;Output&gt;
    &lt;ImageEnd/&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="linenode" xreflabel="Line node">
		<title>Line</title>
		<para>
			A line containing text elements of varying widths.
			<programlisting>&lt;Output&gt;
    &lt;Line&gt;
        ...
    &lt;/Line&gt;
&lt;/Output</programlisting>
		</para>
		<sect2>
			<title>Line attributes</title>
			<sect3 id="linefontname" xreflabel="Line font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the line's scope. It can be overridden
					by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Line font_name="Arial"&gt;
&lt;Line fontName="Arial"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is what's set (in decreasing priority)
					in <xref linkend="reportfontname"/> or
					<xref linkend="partfontname"/>. If none of them is set,
					it's <literal>Courier</literal>.
				</para>
			</sect3>
			<sect3 id="linefontsize" xreflabel="Line font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the line's scope. It can be overridden by
					child nodes for their scope. It may be specified
					in two forms, the first one is the preferred name,
					the second is for RLIB compatibility:
					<programlisting>&lt;Line font_size="10"&gt;
&lt;Line fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font name is what's set (in decreasing priority)
					in <xref linkend="reportfontsize"/> or
					<xref linkend="partfontsize"/>. If none of them is set,
					it's <literal>12</literal>.
				</para>
			</sect3>
			<sect3 id="lineboldattr" xreflabel="Line bold attribute">
				<title>Bold font</title>
				<para>
					Whether the line elements use bold font.
					<programlisting>&lt;Line bold="yes"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>.
				</para>
			</sect3>
			<sect3 id="lineitalicattr" xreflabel="Line italic attribute">
				<title>Italic font</title>
				<para>
					Whether the line elements use italic font.
					It is accepted in two forms:
					<programlisting>&lt;Line italic="yes"&gt;
&lt;Line italics="yes"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Text lines may be suppressed. If the parent
					<literal>&lt;Output&gt;</literal> node is in
					<literal>&lt;FieldDetails&gt;</literal>, the
					expression may be derived from a query field.
					<programlisting>&lt;Line suppress="yes"&gt;
&lt;Line suppress="val(m.suppress_line)"&gt;
&lt;Line suppress="query1.suppress_line"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3>
				<title>Text color</title>
				<para>
					This color is used to render text. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Line color="'blue'"&gt;
&lt;Line colour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>black</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3>
				<title>Background color</title>
				<para>
					This color is used to render the background
					rectangle under the text. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Line bgcolor="'blue'"&gt;
&lt;Line bgcolour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>white</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Line subsections</title>
			<sect3>
				<title>Text element</title>
				<para>
					Two variants are accepted.
					<programlisting>&lt;Line&gt;
    &lt;field value="expression..." ... /&gt;
&lt;/Line&gt;</programlisting> and
					<programlisting>&lt;Line&gt;
    &lt;literal ... &gt;Literal text&lt;/literal&gt;
&lt;/Line&gt;</programlisting>
				</para>
				<para>
					See the <xref linkend="textelemnode"/> below.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="textelemnode" xreflabel="Text element node">
		<title>Text element</title>
		<para>
			Two variants are accepted.
			<programlisting>&lt;Line&gt;
    &lt;field value="expression..." ... /&gt;
&lt;/Line&gt;</programlisting> and
			<programlisting>&lt;Line&gt;
    &lt;literal ... &gt;Literal text&lt;/literal&gt;
&lt;/Line&gt;</programlisting>
		</para>
		<para>
			Neither <literal>field</literal> nor
			<literal>literal</literal> have child nodes,
			only attributes or XML values.
		</para>
		<para>
			The two variants are interchangeable, see
			<xref linkend="elemvalueattr"/> below.
		</para>
		<sect2>
			<title>Text element attributes</title>
			<sect3 id="elemvalueattr" xreflabel="Text element value">
				<title>Value</title>
				<para>
					The value of the text element. It's accepted in two
					ways: in the <literal>value</literal> attribute or as
					the XML value for the <literal>field</literal> and
					<literal>literal</literal> nodes.
					<programlisting>&lt;Line&gt;
    &lt;field value="'This text'" /&gt;
    &lt;field&gt;This text&lt;/field&gt;
    &lt;literal value="'This text'" /&gt;
    &lt;literal&gt;This text&lt;/literal&gt;
&lt;/Line&gt;</programlisting>
				</para>
				<para>
					The value is parsed as an expression
					from the <literal>value</literal> attribute.
					See <xref linkend="expressions"/>.
				</para>
				<para>
					On the other hand, the value is taken as a literal
					string from the XML value in the second and fourth
					examples above.
				</para>
			</sect3>
			<sect3>
				<title>Delayed (precalculated) value</title>
				<para>
					This setting indicates whether the value is
					"precalculated", i.e. the value for the last
					row in the data set is used, or it would be
					the actual value for the current row in the
					data set.
					<programlisting>&lt;field delayed="yes" /&gt;
&lt;field precalculate="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>.
				</para>
				<para>
					This setting is only applicable for
					line elements in the
					<xref linkend="outputnode"/> node in
					<literal>&lt;ReportHeader&gt;</literal>,
					<literal>&lt;ReportFooter&gt;</literal>,
					<literal>&lt;Fieldheaders&gt;</literal>
					<literal>&lt;FieldDetails&gt;</literal>,
					since they are the ones under the
					<literal>&lt;Report&gt;</literal> scope
					with a query.
				</para>
				<para>
					Note that in <literal>OpenCReports</literal>,
					an expression may mix references to precalculated
					variables with non-precalculated variables and
					query field references. The result will use the
					precalculated value only for the precalculated
					variables. Other references will use values derived
					from the current row in the data set.
					This is an extension over RLIB.
				</para>
			</sect3>
			<sect3 id="formatattr" xreflabel="Text element format attribute">
				<title>Format string</title>
				<para>
					The format string is used to format the
					<literal>value</literal> to be displayed
					in the generated output. For example, to
					print a number with two decimal places:
					<programlisting>&lt;field value="3" format="'%.2d'" /&gt;</programlisting>
				</para>
				<para>
					The format string is expected to be a string
					so quoting around it is needed.
				</para>
				<para>
					See <xref linkend="formatting"/> for details.
				</para>
			</sect3>
			<sect3 id="textelemwidth" xreflabel="Text element width">
				<title>Width</title>
				<para>
					The field width.
					<programlisting>&lt;field value="3" format="'%.2d'" width="6" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. the field width
					is implicitly set to the rendered width (in points)
					of the field's formatted value as text, using the
					font name and font size of the field.
				</para>
				<para>
					If set, the width's unit depends on the
					<xref linkend="sizeunit"/>.
				</para>
				<para>
					When the <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal>, the field width is measured
					in number of characters.
				</para>
				<para>
					The character width is queried from the font set by
					<xref linkend="linefontname"/> and
					<xref linkend="linefontsize"/>,
					<xref linkend="reportfontname"/> and
					<xref linkend="reportfontsize"/>, or
					<xref linkend="partfontname"/> and
					<xref linkend="partfontsize"/>
					in decreasing order of precedence.
				</para>
				<para>
					<xref linkend="textelemfontname"/> and
					<xref linkend="textelemfontsize"/> DO NOT influence
					the font width used to determine the field width.
				</para>
				<para>
					This allows using uniquely set font name and size for
					individual text elements, including proportional
					fonts.
				</para>
				<para>
					When using different font names or font sizes for
					different text elements in the same
					<literal>&lt;Line&gt;</literal>, the text elements
					are aligned vertically so all text elements are
					rendered on the same typographic baseline.
				</para>
			</sect3>
			<sect3 id="textelemalign" xreflabel="Text element alignment">
				<title>Alignment</title>
				<para>
					It specifies the alignment for the text element.
					It works in accordance with the
					<xref linkend="textelemwidth"/>, i.e. the field's
					formatted value (as text) is aligned inside the
					specified field width.
					<programlisting>&lt;field value="3" format="'%.2d'"
      width="6" align="'center' /"&gt;</programlisting>
				</para>
				<para>
					The alignment values may be
					<literal>left</literal>,
					<literal>right</literal>,
					<literal>center</literal> or
					<literal>justified</literal>.
				</para>
				<para>
					Justified alignment is like left alignment,
					but for a multi-line field all lines but the
					last are justified. This is best used With
					the default word wrapping. In this case,
					the spacing between words is enlarged.
					<literal>justified</literal> and
					<literal>left</literal> behave the same
					for regular single-line fields.
				</para>
				<para>
					Default is <literal>left</literal>.
				</para>
				<para>
					<literal>OpenCReports</literal> decoupled
					the data from displaying it. For example,
					with the PDF output, the text element is not
					truncated to the element width. Instead,
					pixel perfect alignment is used together
					with masking the parts of the value with
					a bounding box. This is a deviation from
					RLIB where data was approximately truncated,
					because it was designed with monospace fonts
					in mind, and widths were specified in number
					of characters.
				</para>
			</sect3>
			<sect3>
				<title>Text color</title>
				<para>
					This color is used to render text. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Line color="'blue'"&gt;
&lt;Line colour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is what's set for <xref linkend="linenode"/>,
					otherwise <literal>black</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3>
				<title>Background color</title>
				<para>
					This color is used to render the background
					rectangle under the text. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Line bgcolor="'blue'"&gt;
&lt;Line bgcolour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>white</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="textelemfontname" xreflabel="Text element font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the text element's scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_name="Arial"&gt;
&lt;Part fontName="Arial"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is <literal>Courier</literal>.
				</para>
			</sect3>
			<sect3 id="textelemfontsize" xreflabel="Text element font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the text element's scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_size="10"&gt;
&lt;Part fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font size is 12.
				</para>
			</sect3>
			<sect3>
				<title>Bold font</title>
				<para>
					Whether the text element uses bold font.
					It overrides the <xref linkend="lineboldattr"/>
					for this text element.
					<programlisting>&lt;field bold="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is what's set for
					<xref linkend="lineboldattr"/>.
					<literal>false</literal> if both are unset.
				</para>
			</sect3>
			<sect3>
				<title>Italic font</title>
				<para>
					Whether the text element uses italic font.
					It overrides the <xref linkend="lineitalicattr"/>
					for this text element.
					It is accepted in two forms:
					<programlisting>&lt;field italic="yes" /&gt;
&lt;field italics="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is what's set for
					<xref linkend="lineitalicattr"/>.
					<literal>false</literal> if both are unset.
				</para>
			</sect3>
			<sect3>
				<title>Web link</title>
				<para>
					This attribute adds a weblink to the text element.
					E.g. clicking on this text element in the generated
					PDF will open a browser with the website.
					<programlisting>&lt;field value="'This is my website'"
       link="'https://github.com/zboszor/OpenCReports'" /&gt;</programlisting>
				</para>
				<para>
					Default is no weblink.
				</para>
			</sect3>
			<sect3>
				<title>Multi-line (memo) field</title>
				<para>
					This attribute allows breaking long text fields
					to multiple lines according to the 
					<xref linkend="textelemwidth"/>.
					<programlisting>&lt;field value="'This is a long text...'"
       width="12" memo="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>, i.e. the field
					is rendered on a single line.
				</para>
				<para>
					Every line of the text element (regardless if it's a memo
					field or not) is aligned according to
					<xref linkend="textelemalign"/>.
				</para>
			</sect3>
			<sect3>
				<title>Multi-line field wrapping</title>
				<para>
					This attribute allows wrapping multi-line
					text at characters as opposed to words.
					<programlisting>&lt;field value="'This is a long text...'"
       width="12" memo="yes" memo_wrap_chars="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>, i.e. the field
					is wrapped at word boundaries.
				</para>
				<para>
					In <literal>OpenCReports</literal>, character
					wrapping adds hyphenation, thanks to Pango rendering.
					This is a deviation from RLIB.
				</para>
			</sect3>
			<sect3>
				<title>Multi-line field row limit</title>
				<para>
					This attribute allows limiting multi-line
					text with a maximum row number.
					<programlisting>&lt;field value="'This is a long text...'"
       width="12" memo="yes" memo_max_lines="20" /&gt;</programlisting>
				</para>
				<para>
					Default is no limit.
				</para>
				<para>
					In <literal>OpenCReports</literal>, character
					wrapping adds hyphenation, thanks to Pango rendering.
					This is a deviation from RLIB.
				</para>
			</sect3>
			<sect3>
				<title>Column number</title>
				<para>
					This attribute is accepted for RLIB compatibility,
					but it's unused.
					text with a maximum row number.
					<programlisting>&lt;field value="'This is a long text...'"
       col="3" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="hlinenode" xreflabel="HorizontalLine node">
		<title>HorizontalLine</title>
		<para>
			A horizontally drawn line.
			<programlisting>&lt;Output&gt;
    &lt;HorizontalLine ... /&gt;
&lt;/Output</programlisting>
		</para>
		<sect2>
			<title>HorizontalLine attributes</title>
			<sect3>
				<title>Line width</title>
				<para>
					The line width is measured in points,
					regardless of the <xref linkend="sizeunit"/>.
					<programlisting>&lt;HorizontalLine size="3" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>1.0</literal>
				</para>
			</sect3>
			<sect3>
				<title>Indentation</title>
				<para>
					Extra indentation for the line.
					It is measured in points,
					regardless of the <xref linkend="sizeunit"/>.
					<programlisting>&lt;HorizontalLine indent="15" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>0.0</literal>
				</para>
			</sect3>
			<sect3 id="hlinelength" xreflabel="HorizontalLine length">
				<title>Length</title>
				<para>
					The line length.
					<programlisting>&lt;HorizontalLine length="150" /&gt;</programlisting>
				</para>
				<para>
					The line length unit depends on the
					<xref linkend="sizeunit"/>.
					When set to <literal>rlib</literal>,
					it is measured in number of characters.
					The is influenced by <xref linkend="hlinefontsize"/>,
					<xref linkend="reportfontsize"/> and
					<xref linkend="partfontsize"/> in decreasing order,
					which in turn is influenced by
					<xref linkend="reportfontname"/> and
					<xref linkend="partfontname"/> in decreasing order.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, the line length
					is measured in points.
				</para>
				<para>
					Default is unset, i.e. the line is drawn across
					the page width.
				</para>
			</sect3>
			<sect3 id="hlinefontsize" xreflabel="HorizontalLine font size">
				<title>Font size</title>
				<para>
					An extra knob to influence line length computation.
					See <xref linkend="hlinelength"/>.
					It is accepted in two forms, <literal>font_size</literal>
					is the preferred one, the other is accepted for
					RLIB compatibility:
					<programlisting>&lt;HorizontalLine font_size="14" /&gt;
&lt;HorizontalLine fontSize="14" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. only
					<xref linkend="reportfontsize"/> and
                    <xref linkend="partfontsize"/> would contribute
					to the horizontal line width computation.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					Horizontal lines may be suppressed. If the parent
					<literal>&lt;Output&gt;</literal> node is in
					<literal>&lt;FieldDetails&gt;</literal>, the
					expression may be derived from a query field.
					<programlisting>&lt;HorizontalLine suppress="yes /"&gt;
&lt;HorizontalLine suppress="val(m.suppress_hline)" /&gt;
&lt;HorizontalLine suppress="query1.suppress_hline" /&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3>
				<title>Line color</title>
				<para>
					This color is used to render text. It's accepted
					with both American and  British spelling.
					For RLIB compatibility, it is also accepted
					as <literal>bgcolor</literal>, with both
					American and  British spelling.
					<programlisting>&lt;HorizontalLine color="'blue'" /&gt;
&lt;HorizontalLine colour="'blue'" /&gt;
&lt;HorizontalLine bgcolor="'blue'" /&gt;
&lt;HorizontalLine bgcolour="'blue'" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>black</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="imagenode" xreflabel="Image node">
		<title>Image</title>
		<para>
			An image to draw on the page.
			<programlisting>&lt;Output&gt;
    &lt;Image ... /&gt;
&lt;/Output</programlisting>
		</para>
		<para>
			After a valid image specification, subsequent
			<xref linkend="linenode"/>s and
			<xref linkend="hlinenode"/>s are indented
			by the image width in the same
			<literal>&lt;Output&gt;</literal> node,
			or until an <literal>&lt;ImageEnd&gt;</literal>
			node is encountered in that
			<literal>&lt;Output&gt;</literal> node.
		</para>
		<sect2>
			<title>Image attributes</title>
			<sect3>
				<title>File name</title>
				<para>
					The file name of the image.

					<programlisting>&lt;Image value="'filename.jpg'" /&gt;</programlisting>
				</para>
				<para>
					Default is unset. It makes the
					<literal>Image</literal> not shown.
				</para>
			</sect3>
			<sect3>
				<title>Suppress</title>
				<para>
					The image may be suppressed.
					<programlisting>&lt;Image value="'filename.jpg'"
       suppress="yes" /&gt;
&lt;Image value="'filename.jpg'"
       suppress="m.suppress_image" /&gt;
&lt;Image value="'filename.jpg'"
       suppress="query1.suppress_image" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3>
				<title>Type</title>
				<para>
					Accepted for RLIB compatibility.
					<programlisting>&lt;Image value="'filename.jpg'"
       type="'jpg'" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. autodetect.
				</para>
				<para>
					Various image formats are supported
					with autodetection via <literal>gdk-pixbuf</literal>.
					SVG (Scalable Vector Graphics) is supported
					via <literal>librsvg</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Width</title>
				<para>
					Image width, measured in points regardless of
					the <xref linkend="sizeunit"/>.
					<programlisting>&lt;Image value="'filename.jpg'"
       width="100" /&gt;</programlisting>
				</para>
				<para>
					Default is unset. The image would not be shown,
					unless both width and height are set.
				</para>
			</sect3>
			<sect3>
				<title>Height</title>
				<para>
					Image height, measured in points regardless of
					the <xref linkend="sizeunit"/>.
					<programlisting>&lt;Image value="'filename.jpg'"
       height="100" /&gt;</programlisting>
				</para>
				<para>
					Default is unset. The image would not be shown,
					unless both width and height are set.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="imageendnode" xreflabel="ImageEnd node">
		<title>Image end</title>
		<para>
			Terminator for a previous image.
			This node doesn't have any attributes or
			child nodes. Its purpose is to reset
			indentation caused by a previous
			<xref linkend="imagenode"/>.
			<programlisting>&lt;Output&gt;
    &lt;ImageEnd/&gt;
&lt;/Output</programlisting>
		</para>
	</sect1>
	<sect1 id="colorspec" xreflabel="Color specification">
		<title>Color specification</title>
		<para>
			Colors may be specified by HTML notation.
			This contains six hexadecimal digits, representing
			RGB (red, green, blue) values between 0 and 255
			for each color component, prefixed by the
			<literal>#</literal> character.
			<programlisting>&lt;Line bgcolor="'#ffff00'" ... &gt;
&lt;HorizontalLine color="'#ff00ff'" ... &gt;</programlisting>
		</para>
		<para>
			Colors may also be specified by hexadecimal notation.
			This contains six hexadecimal digits, representing
			RGB (red, green, blue) values between 0 and 255
			for each color component, prefixed by
			<literal>0x</literal>.
			<programlisting>&lt;Line bgcolor="'0xffff00'" ... &gt;
&lt;HorizontalLine color="'0xff00ff'" ... &gt;</programlisting>
		</para>
		<para>
			Color names may also be specified by name.
			The following color names are supported for RLIB compatibility.
			Color names are matched in a case-insensitive way.
		</para>
		<para>
			<inlinemediaobject>
				<imageobject>
					<imagedata fileref="images/namedcolors.png" align="center" />
				</imageobject>
			</inlinemediaobject>
		</para>
	</sect1>
</chapter>

<chapter id="xmldescriptor" xreflabel="Report XML description">
	<title>Report XML description</title> <sect1
	id="descstruct">
		<title>XML description structure</title>
		<para>
			<ulink url="https://github.com/zboszor/OpenCReports">OpenCReports</ulink>
			uses an
			<ulink url="https://sourceforge.net/projects/rlib/">RLIB</ulink>-compatible
			report description with extensions.
		</para>
		<para>
			The report XML description, like all XML files start with
			declaring that it's an XML file and the optional declaration
			of the Document Type Definition that the XML file can be
			checked against. For an OpenCReports report description,
			the first two lines are:
			<programlisting>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE OpenCReport SYSTEM "opencreport.dtd"&gt;</programlisting>
			The DTD file <literal>opencreport.dtd</literal> can be
			found in the sources of OpenCReports
			<ulink url="https://github.com/zboszor/OpenCReports/blob/main/opencreport.dtd">here</ulink>.
		</para>
		<para>
			After the XML header lines, a fully specified report
			description looks like this:
			<programlisting>&lt;OpenCReport&gt;
    &lt;Datasources&gt;
        ...
    &lt;/Datasources&gt;
    &lt;Queries&gt;
        ...
    &lt;/Queries&gt;
    &lt;Part&gt;
        &lt;pr&gt;
            &lt;pd&gt;
                &lt;Report&gt;
                    ...
                &lt;/Report&gt;
            &lt;/pd&gt;
        &lt;/pr&gt;
    &lt;/Part&gt;
&lt;/OpenCReport&gt;</programlisting>
			or like this:
			<programlisting>&lt;OpenCReport&gt;
    &lt;Datasources&gt;
        ...
    &lt;/Datasources&gt;
    &lt;Queries&gt;
        ...
    &lt;/Queries&gt;
    &lt;Report&gt;
        ...
    &lt;/Report&gt;
&lt;/OpenCReport&gt;</programlisting>
		</para>
		<para>
			The XML sections <xref linkend="datasourcesnode"/>
			and <xref linkend="queriesnode"/> are optional in the XML
			description. They can be substituted by program code
			using the datasource and query related calls in the
			<xref linkend="lowlevelapi"/>, similarly to RLIB.
		</para>
		<para>
			For RLIB compatibility, a report description may start
			with either <literal>&lt;Part&gt;</literal> or
			<literal>&lt;Report&gt;</literal> as the toplevel node.
			In this case, there's no other way to add datasources
			and queries, but through program code, like the
			<xref linkend="lowlevelapi"/>.
		</para>
		<para>
			Since XML files are hierarchical with a single toplevel
			node with child nodes, multiple
			<literal>&lt;Report&gt;</literal> nodes in the same
			report output were only possible in RLIB with using
			<literal>&lt;Part&gt;</literal> as the toplevel node,
			with all the nodes having to be spelled out between
			<literal>&lt;Part&gt;</literal> and
			<literal>&lt;Report&gt;</literal>. With
			<literal>&lt;OpenCReport&gt;</literal> being the
			toplevel node, multiple <literal>&lt;Report&gt;</literal>
			child nodes can be used without the parent
			<literal>&lt;Part&gt;</literal> node.
		</para>
		<sect2 id="xmlnotes">
			<title>Notes about XML syntax and attributes</title>
			<para>
				Most (if not all) XML attributes in the report
				description file are handled with the expression
				parser (see <xref linkend="expressions"/>), with fallback
				to literal strings if the the location of expression
				wouldn't allow identifier references at that location.
			</para>
			<para>
				For example, the datasource name may be declared using either
				of the three examples below:
				<programlisting>&lt;Datasource name="mysource" ... /&gt;
&lt;Datasource name="'mysource'" ... /&gt;
&lt;Datasource name="&amp;quot;mysource&amp;quot;" ... /&gt;</programlisting>
			</para>
			<para>
				The first form is a regular XML string value.
				Since expression parsing would find that
				<literal>mysource</literal> is an identifier
				which may be a query column name and this is not
				a valid place for a query reference, the non-parsed
				string value is used.
			</para>
			<para>
				The second form is a single quoted OpenCReports
				string constant. The value of the string constant
				(i.e. <literal>mysource</literal>) is used.
			</para>
			<para>
				The third form is a double quoted OpenCReports
				string constant, but in XML the double quote
				character must be substituted with
				<literal>&amp;quot;</literal> because they are
				reserved for quoting the attribute values.
				The value of the string constant (i.e.
				<literal>mysource</literal>) is used.
				(This substitution is called "string escaping"
				and various other formats besides XML require some
				kind of substutition for reserved characters.)
			</para>
			<para>
				To make the XML easier to read, the second form
				is recommended because it still allows
				embedding the single quote character inside
				a string (see <xref linkend="xmldescriptor"/>)
				in case e.g. a strong password contains this.
				For security-by-obscurity, the third form may
				be used because it is harder to read. For all
				special characters that should be escaped in
				XML, see
				<ulink url="https://stackoverflow.com/a/46637835/290085">Simplified XML Escaping</ulink>.
			</para>
		</sect2>
	</sect1>
	<sect1 id="ocrpttopxml" xreflabel="OpenCReport element">
		<title>OpenCReport element</title>
		<para>
			The toplevel <literal>&lt;OpenCReport&gt;</literal>
			element controls some global settings and serves
			as the topmost XML element for child elements.
		</para>
		<sect2 id="sizeunit" xreflabel="Size unit attribute">
			<title>Size unit attribute</title>
			<para>
				The <literal>size_unit</literal> attribute
				specifies report behaviour for size related
				settings:
				<programlisting>&lt;OpenCReport size_unit="'rlib'"&gt;
&lt;OpenCReport size_unit="'points'"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>rlib</literal>
				which is the legacy RLIB behavior, where
				sizing of layout details are a mix of units,
				making it harder to design the report layout:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							width for <literal>field</literal> and
							<literal>literal</literal> (see
							<xref linkend="outputnode"/>) are in
							number of characters. This is influenced
							by the font size set in either
							<xref linkend="partfontsize"/>,
							<xref linkend="reportfontsize"/> or
							<xref linkend="linefontsize"/>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							height for <xref linkend="partcol"/>
							is measured in number of characters
							influenced by <xref linkend="partfontsize"/>
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							height for <xref linkend="report"/>
							is measured in percentage of
							<xref linkend="partcol"/> and considered
							to be a minimum value, so padding is added
							if the report contents end earlier
							than the limit
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							width of horizontal lines and the
							optional border width around reports
							are specified in points
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							gaps between columns of multi-column
							reports is measured in inches
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Note that RLIB only expected monospace
				fonts that have the same width for every character. It also
				expected that the character height is identical to the
				character width. The latter expectation is false for many
				monospace fonts, i.e. their height is usually greater than
				their width. Also, there are problems with field widths
				calculated in number of characters. Widths using
				a 12 point font (for example, used for regular text)
				is not the same as widths using a 20 point font
				used for text in a header line. Due to this, width of header
				and data lines will not align properly and it will show
				when using background color for both of them.
			</para>
			<para>
				With proportional fonts (where the width of
				characters depend on their image, i.e. an "i" is
				thinner than an "m") width of text fields cannot
				reliably be set in a "number of characters" unit
				because it's not an exact value. There is a workaround
				for this in OpenCReports but it isn't available
				in RLIB so it's not backward compatible.
				See <xref linkend="textelemwidth"/>.
			</para>
			<para>
				When <literal>size_unit</literal> is set to
				<literal>points</literal>, all size related
				settings in the report are in points,
				a.k.a. 1/72th inch. It's consistent and avoids the
				above described issues.
			</para>
		</sect2>
		<sect2 id="noqueryshownodata" xreflabel="No query show NoData attribute">
			<title>No query show NoData</title>
			<para>
				The report uses data from <xref linkend="queriesnode"/>
				through the report's <xref linkend="queryattr"/>.
				When a query provides no data rows, an alternative section
				called <xref linkend="nodatanode"/> with static information
				may be shown instead if it exists in the report.
				The report uses the first query declared in
				<xref linkend="queriesnode"/> if it's not explicitly set
				via <xref linkend="queryattr"/>.
			</para>
			<para>
				RLIB had a trick to disable showing the
				<xref linkend="nodatanode"/>. This was enabled by
				specifying a query name that does not exist.
				This option controls the layout behaviour for that case.
				<programlisting>&lt;OpenCReport noquery_show_nodata="yes"&gt;
&lt;OpenCReport noquery_show_nodata="no"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>true</literal> (or <literal>yes</literal>)
				when <literal>&lt;OpenCReport&gt;</literal> is the toplevel node,
				<literal>false</literal> (or <literal>no</literal>) when
				either <literal>&lt;Part&gt;</literal> or
				<literal>&lt;Report&gt;</literal>
				is the toplevel node for RLIB compatibility.
			</para>
		</sect2>
		<sect2 id="reportheightafterlast" xreflabel="Report height after last attribute">
			<title>Report height after last</title>
			<para>
				A report may specify its height through
				<xref linkend="reportheight"/>.
				Multiple <literal>&lt;Report&gt;</literal>
				nodes may exist in the same
				<literal>&lt;pd&gt;</literal> section.
				For more information, see <xref linkend="partcol"/>
				and <xref linkend="report"/>.
			</para>
			<para>
				This option controls whether report height is applied
				after the last <literal>&lt;Report&gt;</literal>
				in the same <literal>&lt;pd&gt;</literal> node.
				<programlisting>&lt;OpenCReport report_height_after_last="yes"&gt;
&lt;OpenCReport report_height_after_last="no"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>false</literal>.
			</para>
		</sect2>
		<sect2 id="xmlfollowermatchsingle" xreflabel="Follower match single attribute">
			<title>Follower match single</title>
			<para>
				<xref linkend="queriesnode"/> may be daisy-chained together
				as <xref linkend="followerqueries"/> in two ways, regular
				and N:1 followers. See the links for details.
			</para>
			<para>
				When set to <literal>false</literal>, N:1 followers behave
				fully like <literal>LEFT OUTER JOIN</literal> in SQL,
				with duplicating data from the primary query if multiple
				matching rows exist in followers. When set to
				<literal>true</literal>, only the first matching row is used.
				The latter approximates the RLIB implementation.
				<programlisting>&lt;OpenCReport follower_match_single="yes"&gt;
&lt;OpenCReport follower_match_single="no"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>yes</literal> in RLIB compatibility
				mode, i.e. when either <literal>&lt;Part&gt;</literal> or
				<literal>&lt;Report&gt;</literal> are used as the
				toplevel XML node for the report description.
				Otherwise the default is <literal>no</literal>.
			</para>
		</sect2>
		<sect2 id="precbits">
			<title>Precision bits</title>
			<para>
				This controls the precision for numeric computations.
				For more information, see <xref linkend="expressions"/>
				<programlisting>&lt;OpenCReport precision_bits="512"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>256</literal>.
			</para>
		</sect2>
		<sect2 id="roundingmode">
			<title>Rounding mode</title>
			<para>
				This controls the rounding mode for numeric computations.
				Possible values are:
				<literal>nearest</literal>,
				<literal>to_minus_inf</literal>,
				<literal>to_inf</literal>,
				<literal>to_zero</literal>,
				<literal>away_from_zero</literal>, or
				<literal>faithful</literal>.
				<programlisting>&lt;OpenCReport rounding_mode="nearest"&gt;
&lt;OpenCReport rounding_mode="to_minus_inf"&gt;
&lt;OpenCReport rounding_mode="to_inf"&gt;
&lt;OpenCReport rounding_mode="to_zero"&gt;
&lt;OpenCReport rounding_mode="away_from_zero"&gt;
&lt;OpenCReport rounding_mode="faithful"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>nearest</literal>.
				Note that according to the MPFR documentation,
				<literal>faithful</literal> is experimental.
			</para>
		</sect2>
		<sect2 id="locale" xreflabel="Locale">
			<title>Locale</title>
			<para>
				This controls the language settings, like the decimal
				separator, weekday names, month names and similar.
				This setting is also used as the language of translation.
				<programlisting>&lt;OpenCReport locale="de_DE"&gt;</programlisting>
			</para>
			<para>
				Default is <literal>C</literal> locale which
				approximates US English.
			</para>
		</sect2>
		<sect2 id="xlatesettings">
			<title>Translation settings</title>
			<para>
				These two settings control the translation.
				<programlisting>&lt;OpenCReport
    translation_domain="mydomain"
    translation_directory="/path/to/translation/files"&gt;</programlisting>
			</para>
			<para>
				Translation is based on
				<ulink url="https://www.gnu.org/software/gettext/">GNU Gettext</ulink>.
				A subdirectory tree is expected under the specified
				translation directory in the form of
				<literal>locale/LC_MESSAGES</literal> (e.g.:
				<literal>de_DE/LC_MESSAGES</literal>) with
				<literal>mydomain.mo</literal> files in them.
				These <literal>.mo</literal> files contain translated
				messages for a given language.
			</para>
		</sect2>
	</sect1>
	<sect1 id="searchpaths" xreflabel="Search paths">
		<title>Paths</title>
		<para>
			Some report description elements reference file.
			Such elements are <literal>&lt;load&gt;</literal> and
			<literal>&lt;Image&gt;</literal>, see
			<xref linkend="loadedreport"/> and <xref linkend="imagenode"/>.
			By default, these files must be in the same directory
			as the report XML description file, or in the current working
			directory for the application using OpenCReports.
			To lift this limitation and to allow organizing files,
			a search path or multiple search paths may be added.
			For files referenced with relative paths, the
			search paths will be used in their order of
			declaration. Search paths and the relative file
			path are concatenated together to form an absolute
			path. The first successful absolute file path
			match will be used in the element referencing
			the file.
		</para>
		<para>
			Search paths are in the following format:
			<programlisting>&lt;Paths&gt;
    &lt;Path value="/absolute/path" /&gt;
    ...
&lt;/Paths&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="datasourcesnode" xreflabel="Datasources">
		<title>Datasources</title>
		<para>
			Datasources in OpenCReports are either database
			connections, or accessors (mini-drivers) for data
			files in certain formats.
		</para>
		<para>
			Datasource descriptions are in the following format:
			<programlisting>&lt;Datasources&gt;
    &lt;Datasource name="mysource" type="..." ... /&gt;
&lt;/Datasources&gt;</programlisting>
		</para>
		<para>
			A report may have multiple datasources, i.e.
			the description may list multiple
			<literal>&lt;Datasource&gt;</literal> lines.
		</para>
		<para>
			Datasources must have unique names in a report and
			their type may be:
			<literal>mariadb</literal> (or <literal>mysql</literal>),
			<literal>postgresql</literal>, <literal>odbc</literal>,
			<literal>csv</literal>, <literal>json</literal>,
			<literal>xml</literal> or <literal>array</literal>.
		</para>
		<sect2 id="mariadbds" xreflabel="MariaDB database connection">
			<title>MariaDB (MySQL) database connection</title>
			<para>
				A MariaDB database connection may be declared in three
				ways. Either by using the database host and port,
				the database name, user name and password directly:
				<programlisting>&lt;Datasource
    name="mysource" type="mariadb"
    host="..." port="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or alternatively, instead of the host and port,
				specifying the UNIX Domain Socket file for
				a local connection if it's not in the standard
				location:
				<programlisting>&lt;Datasource
    name="mysource" type="mariadb"
    unix_socket="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or moving these details out to an external
				configuration file in an INI file format:
				<programlisting>&lt;Datasource
    name="mysource" type="mariadb"
    optionfile="myconn.cnf" group="myconn" /&gt;</programlisting>
			</para>
			<para>
				In the last case, the configuration file <literal>myconn.cnf</literal>
				would contain something like this:
				<programlisting>[myconn]
!include /etc/my.cnf
database=mydb
user=myuser
#password=
#host=
#port=
#unix_socket=</programlisting>
				Please note that the INI group name <literal>[myconn]</literal>
				matches <literal>group="myconn"</literal> in the above
				datasource declaration.
			</para>
			<para>
				The database name and user name are mandatory. The
				user password is optional, depending on the database
				security authentication setup.
			</para>
			<para>
				The database host and port, or the socket file location
				are all optional. Without these, a local connection is
				attempted using the default settings. If the host name
				is specified but the port isn't, the remote host is
				used on the default port (as known by the local MariaDB
				database client library).
			</para>
		</sect2>
		<sect2 id="postgresqlds" xreflabel="PostgreSQL database connection">
			<title>PostgreSQL database connection</title>
			<para>
				A PostgreSQL database connection may be declared in three
				ways. Either by using the database host and port,
				the database name, user name and password directly:
				<programlisting>&lt;Datasource
    name="mysource" type="postgresql"
    host="..." port="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or alternatively, instead of the host and port,
				specifying the UNIX Domain Socket file for
				a local connection if it's not in the standard
				location:
				<programlisting>&lt;Datasource
    name="mysource" type="postgresql"
    unix_socket="..."
    dbname="..." user="..." password="..." /&gt;</programlisting>
				or using a so called connection string:
				<programlisting>&lt;Datasource
    name="mysource" type="postgresql"
    connstr="..." /&gt;</programlisting>
			</para>
			<para>
				For the connection string format, see the
				<ulink url="https://www.postgresql.org/docs">PostgreSQL documentation</ulink>.
			</para>
			<para>
				The database name and user name are mandatory. The
				user password is optional, depending on the database
				security authentication setup.
			</para>
			<para>
				The database host and port, or the socket file location
				are all optional. Without these, a local connection is
				attempted using the default settings. If the host name
				is specified but the port isn't, the remote host is
				used on the default port (as known by the local PostgreSQL
				database client library).
			</para>
			<para>
				There are also two optional parameters that control
				the behaviour of the PostgreSQL driver in OpenCReports,
				rather than being actual connection parameters to a
				PostgreSQL server. These parameters may be used with
				any of the above connection methods.
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The parameter
							<literal>usecursor</literal>
							may have a boolean value:
							<literal>true</literal>,
							<literal>false</literal>,
							<literal>yes</literal>,
							<literal>no</literal>, or
							a numeric value interpreted
							as a boolean value: non-zero
							values mean <literal>true</literal>,
							zero means <literal>false</literal>.
						</para>
						<para>
							When <literal>usecursor</literal> is enabled,
							the SQL query will be wrapped in
							a cursor, and the result is retrieved
							in parts. Otherwise, the SQL query is
							executed as is and the result is
							retrieved in whole.
						</para>
						<para>
							The default value is usually <literal>true</literal>
							but this can be controlled when OpenCReports is built.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							When <literal>usecursor</literal> is enabled,
							the parameter <literal>fetchsize</literal>
							controls the number of rows retrieved
							at once. Default value is 1024.
							
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Examples (add the necessary connection
				parameters from the above):
				<programlisting>&lt;Datasource
    name="mysource" type="postgresql" ...
    usecursor="false"
/&gt;</programlisting>
				or <programlisting>&lt;Datasource
    name="mysource" type="postgresql" ...
    usecursor="true" fetchsize="4096" /&gt;</programlisting>
			</para>
			<para>
				SQL queries added to the same PostgreSQL
				datasource (connection) will behave the same
				way. Either all of them are executed as is,
				or all of them will use a cursor.
			</para>
		</sect2>
		<sect2 id="odbcds" xreflabel="ODBC database connection">
			<title>ODBC database connection</title>
			<para>
				The above described MariaDB and PostgreSQL database
				connection types are using their respective client
				libraries. There is a more generic way, i.e. ODBC.
				ODBC was invented by Microsoft in the 1990s for Windows.
				See
				<ulink url="https://docs.microsoft.com/en-us/sql/odbc/microsoft-open-database-connectivity-odbc">Microsoft Open Database Connectivity (ODBC)</ulink>
				In their solution, there's an abstract client library
				and individual database drivers adhere to the APIs
				offered by ODBC toplevel library. Since then, UNIX and
				UNIX-like systems also gained their ODBC client libraries
				in two different implementations, both of which are
				supported by OpenCReports:
				<ulink url="https://www.unixodbc.org">unixODBC</ulink>
				and
				<ulink url="https://www.iodbc.org">iODBC</ulink>.
			</para>
			<para>
				An ODBC database setup is done a differently. There are
				two system-wide configuration files. The first one is
				<literal>odbcinst.ini</literal> that lists the database
				drivers installed into the system. The second one is
				<literal>odbc.ini</literal> which references the first
				one and lists pre-defined database connections. These
				database connections are named. In ODBC speak, these
				are called Data Source Names or DSNs. The DSNs specify
				the low level connection parameters, like the database
				host and port, and optionally the user name and
				password, too.
			</para>
			<para>
				Thus, an ODBC database connection may be declared in two
				ways. The first way is by using the DSN name, and
				optionally the user name and password:
				<programlisting>&lt;Datasource
    name="mysource" type="odbc"
    dbname="..." user="..." password="..." /&gt;</programlisting>
				In this case, the <literal>dbname</literal> attribute
				is not the low level database name, but the ODBC
				abstract DSN name.
			</para>
			<para>
				There's also a way to use the so called connection string
				which contain the same connection information:
				<programlisting>&lt;Datasource
    name="mysource" type="odbc"
    connstr="..." /&gt;</programlisting>
			</para>
			<para>
				For the connection string format, see the
				<ulink url="https://www.connectionstrings.com/">public examples</ulink>.
			</para>
		</sect2>
		<sect2 id="xmlcsvds">
			<title>CSV file datasource</title>
			<para>
				For a generic description of the CSV file format,
				see <xref linkend="csvds"/>.
			</para>
			<para>
				A CSV file datasource is declared very simply:
				<programlisting>&lt;Datasource name="mysource" type="'csv'" /&gt;</programlisting>
				In this case, the actual CSV file is not declared,
				only that a "query" using a CSV file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
		</sect2>
		<sect2 id="xmljsonds">
			<title>JSON file datasource</title>
			<para>
				For a generic description of the expected JSON file format,
				see <xref linkend="jsonds"/>.
			</para>
			<para>
				Similarly to CSV, the JSON file datasource is also declared
				very simply:
				<programlisting>&lt;Datasource name="mysource" type="'json'" /&gt;</programlisting>
				In this case, the actual JSON file is not declared,
				only that a "query" using a JSON file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
		</sect2>
		<sect2 id="xmlxmlds">
			<title>XML file datasource</title>
			<para>
				Similarly to CSV and JSON, the XML file datasource is also declared
				very simply:
				<programlisting>&lt;Datasource name="mysource" type="'xml'" /&gt;</programlisting>
				In this case, the actual XML file is not declared,
				only that a "query" using an XML file will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
		</sect2>
		<sect2 id="arrayds">
			<title>Array datasource</title>
			<para>
				Arrays are global in-memory structures in the
				application that should be accessible to the
				OpenCReports library. For example, when using
				the C programming language, global non-static
				symbols are visible to libraries if the application
				is compiled with <literal>-rdynamic</literal>.
			</para>
			<para>
				Similarly to file based datasources, the array
				datasource is declared very simply:
				<programlisting>&lt;Datasource name="mysource" type="'array'" /&gt;</programlisting>
				In this case, the actual array is not declared,
				only that a "query" using an array will be listed
				later under <literal>&lt;Queries&gt;</literal>.
			</para>
			<para>
				A C array is declared in this format:
				<programlisting>const char *array[ROWS + 1][COLUMNS] = {
    { "column1", ... },
    { "value1",  ... },
    ...
};</programlisting>
				The array is declared as a two-dimensional array of
				C strings. The first row of the array is the column
				names, <literal>[ROWS + 1]</literal> in the array
				declaration accounts for the title row.
			</para>
			<para>
				All rows have the same number of columns. Column values
				may be NULL, in which case they will be treated the same
				as SQL NULLs in SQL query results.
			</para>
			<para>
				Optionally, a column types array is declared
				separately:
				<programlisting>#include &lt;opencreport.h&gt;

const enum ocrpt_result_type coltypes[COLUMNS] = {
    ...
};</programlisting>
				If this array is present, it must have the same number
				of <literal>COLUMNS</literal> as the matching data
				array. The <literal>enum ocrpt_result_type</literal>
				usable in data array type declaration are
				<literal>OCRPT_RESULT_STRING</literal>,
				<literal>OCRPT_RESULT_NUMBER</literal> and
				<literal>OCRPT_RESULT_DATETIME</literal>. 
			</para>
		</sect2>
		<sect2 id="commondsprops">
			<title>Common datasource properties</title>
			<sect3 id="dsencoding">
				<title>Encoding</title>
				<para>
					OpenCReports expects strings in UTF-8 encoding.
					However, some datasources may use a different
					encoding. To use and display strings from the
					datasource, an internal conversion to UTF-8 is
					needed. To perform this correctly, the datasource
					encoding must be set.
					<programlisting>&lt;Datasource
    name="mysource"
    ...
    encoding="ISO-8859-2" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="queriesnode" xreflabel="Queries">
		<title>Queries</title>
		<para>
			Queries in OpenCReports are SQL queries for database
			connections, or data files files in certain formats.
			The queries are declared like this:
			<programlisting>&lt;Queries&gt;
    &lt;Query name="..." ... /&gt;
    ...
&lt;/Queries&gt;</programlisting>
		</para>
		<sect2 id="xmlsqlqueries">
			<title>SQL queries for SQL datasources</title>
			<para>
				SQL queries for MariaDB, PostgreSQL and ODBC
				datasources may be declared two ways, either
				as the XML value for <literal>&lt;Query&gt;</literal>:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"&gt;
SELECT * FROM some_table
&lt;/Query&gt;</programlisting>
				or as the <literal>value</literal> attribute:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    value="SELECT * FROM some_table" /&gt;</programlisting>
			</para>
			<para>
				Note, that the XML attribute <literal>datasource="..."</literal>
				must match a previously declared datasource.
			</para>
			<para>
				The SQL query can be any <literal>SELECT</literal>
				statement.
			</para>
		</sect2>
		<sect2 id="xmlfilequeries" xreflabel="File based queries">
			<title>Queries for file based datasources</title>
			<para>
				Queries for CSV, XML and JSON datasources may
				be declared two ways. Either as the XML value for
				<literal>&lt;Query&gt;</literal>:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
&gt;xmldata.xml&lt;/Query&gt;</programlisting>
					or as the <literal>value</literal> attribute:
					<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    value="'xmldata.xml'" /&gt;</programlisting>
			</para>
			<para>
				Notes:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The XML attribute <literal>datasource="..."</literal>
							must match a previously declared datasource.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							It is recommended that the <literal>value="..."</literal>
							form is used, since it's not ensured that
							whitespace before or after the file name
							is trimmed in the first variant if the XML
							is "beautified". The file name that the
							OpenCReports library receives must be correct
							in order to use it.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The declaration must specify a file in the
							correct format for the datasource type.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The optional type declaration for columns
							in the XML and JSON file formats, or for CSV,
							the complete lack of it can be supplemented
							with a memory array using the optional
							<literal>coltypes="..."</literal> and
							<literal>cols="..."</literal> attributes.
							For details, see the <xref linkend="xmlarrayqueries"/>.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2 id="xmlarrayqueries" xreflabel="Array queries">
			<title>Queries for array based datasources</title>
			<para>
				Queries for array datasources may be declared two ways.
				Either as the XML value for
				<literal>&lt;Query&gt;</literal>:
				<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    coltypes="'coltypes'"
    rows="30"
    cols="6"
&gt;array&lt;/Query&gt;</programlisting>
					or as the <literal>value</literal> attribute:
					<programlisting>&lt;Query
    name="myquery"
    datasource="mysource"
    value="'array'"
    coltypes="'coltypes'"
    rows="30"
    cols="6" /&gt;</programlisting>
			</para>
			<para>
				Notes:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The XML attribute <literal>datasource="..."</literal>
							must match a previously declared datasource.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							It is recommended that the <literal>value="..."</literal>
							form is used, since it's not ensured that
							whitespace before or after the symbol name
							is trimmed in the first variant if the XML
							is "beautified". The symbol name that the
							OpenCReports library receives must be correct
							in order to use it. The array name must match
							the correct global symbol name. The library
							discovers this symbol using the
							<xref linkend="arraydiscoveryfunc"/>, by
							default via <literal>dlsym()</literal>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							Similarly to the array symbol name, the
							<literal>coltypes="..."</literal> array name
							must match the correct global symbol name.
							The library discovers this symbol using the
							<xref linkend="arraydiscoveryfunc"/>, by
							default via <literal>dlsym()</literal>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The value for <literal>cols</literal>
							must match the second dimension of the
							data array. It may be omitted if the
							<xref linkend="arraydiscoveryfunc"/> is smarter
							than the default implementation and returns
							the arrays' dimensions.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							The value for <literal>rows</literal>
							must match the number of data rows in the array,
							excluding the title row. I.e. it must be one less
							than the first dimension of the array. It may be
							omitted if the
							<xref linkend="arraydiscoveryfunc"/> is smarter
							than the default implementation and returns the
							arrays' dimensions.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Failing to fulfill the above may cause crashes
				or wrong data to be used in the report.
			</para>
		</sect2>
		<sect2 id="xmlfollowerqueries" xreflabel="Follower queries">
			<title>Follower queries</title>
			<sect3 id="xmlfollowerq" xreflabel="Regular follower queries">
				<title>Regular follower queries</title>
					<para>
						A regular follower query is declared by adding
						the <literal>follower_for="..."</literal> attribute.
						The value for <literal>follower_for="..."</literal>
						is the <literal>name</literal> of a previously
						declared query. Example:
						<programlisting>&lt;Query
		name="myquery1"
		datasource="mysource1"
		value="'SELECT * FROM table1'" /&gt;

	&lt;Query
		name="myquery2"
		datasource="mysource2"
		value="'SELECT * FROM table1'"
		follower_for="myquery1" /&gt;</programlisting>
					</para>
					<para>
						In this example, two queries of two different
						datasources are used. This is one of the advantages
						of using follower queries, i.e. data from different
						databases may be used. Nowadays, with foreign
						queries implemented in e.g. PostgreSQL, its use
						case is more limited.
					</para>
			</sect3>
			<sect3 id="xmln1followerq">
				<title>N:1 follower queries</title>
				<para>
					See <xref linkend="n1followerq"/> for explanation.
				</para>
				<para>
					The follower matching expression is specified
					with the <literal>follower_expr="..."</literal>
					attribute. Example:
					<programlisting>&lt;Query
	name="myquery1"
	datasource="mysource1"
	value="'SELECT * FROM table1'" /&gt;

&lt;Query
	name="myquery2"
	datasource="mysource2"
	value="'SELECT * FROM table1'"
	follower_for="myquery1"
	follower_expr="myquery1.id = myquery2.id" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="parts" xreflabel="Report parts">
		<title>Report parts</title>
		<para>
			An OpenCReports XML description may consists of multiple
			separate reports. This is achieved by so called
			"report parts". Such a <literal>&lt;Part&gt;</literal> may be
			under the toplevel <literal>&lt;OpenCReport&gt;</literal>
			node, in which case multiple report parts may exist
			in the same XML. It may also be the toplevel node of
			the XML. In the latter case, only a single
			<literal>&lt;Part&gt;</literal> may be present in
			the XML description.
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
            ...
        &lt;/pd&gt;
        ...
    &lt;/pr&gt;
    ...
&lt;/Part&gt;</programlisting>
		</para>
		<para>
			A report <literal>&lt;Part&gt;</literal> may consist
			multiple reports, arranged in
			<itemizedlist>
				<listitem override="bullet">
					<para>
						rows (<literal>&lt;pr&gt;</literal>),
					</para>
				</listitem>
				<listitem override="bullet">
					<para>
						columns in rows (<literal>&lt;pd&gt;</literal>), and
					</para>
				</listitem>
				<listitem override="bullet">
					<para>
						reports (<literal>&lt;Report&gt;</literal>) arranged
						vertically in a column.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			The rows and columns in rows do not form a grid as rows are
			independent of each other. E.g. one row may contain two columns,
			the next one may contain three, the next one may contain one.
			It is completely freeform.
		</para>
		<para>
			This allows very complex report layouts.
			One possible application of such a complex layout is printed forms.
		</para>
		<sect2 id="partattribs" xreflabel="Part attributes">
			<title>Part attributes</title>
			<para>
				Note that any attribute setting below may only use
				constant expressions or an query column reference
				from <xref linkend="independentqueries"/>.
				An environment variable (since it can't - or shouldn't -
				change during the report execution) is considered constant.
				See <xref linkend="expressions"/>. This allows external
				control for the attributes in question.
			</para>
			<sect3 id="partfontname" xreflabel="Part font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the report part's global scope. It can be
					overridden by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_name="'Arial'"&gt;
&lt;Part fontName="'Arial'"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is <literal>Courier</literal>.
				</para>
			</sect3>
			<sect3 id="partfontsize" xreflabel="Part font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the report part's global scope. It can be
					overridden by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_size="10"&gt;
&lt;Part fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font size is 12.
				</para>
			</sect3>
			<sect3 id="partsizeunit">
				<title>Size unit</title>
				<para>
					Shortcut for the <xref linkend="sizeunit"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>&lt;Part size_unit="'rlib'"&gt;
&lt;Part size_unit="'points'"&gt;</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> is the
					toplevel node in the XML, this attribute for
					<literal>&lt;Part&gt;</literal> is ignored.
				</para>
			</sect3>
			<sect3 id="nqsnd">
				<title>No query show NoData attribute</title>
				<para>
					Shortcut for <xref linkend="noqueryshownodata"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
                    <literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>&lt;Part noquery_show_nodata="yes"&gt;
&lt;Part noquery_show_nodata="no"&gt;</programlisting>
				</para>
				<para>
					See default in <xref linkend="noqueryshownodata"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3 id="rhal">
				<title>Report height after last attribute</title>
				<para>
					Shortcut for <xref linkend="reportheightafterlast"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>&lt;Part report_height_after_last="yes"&gt;
&lt;Part report_height_after_last="no"&gt;</programlisting>
				</para>
				<para>
					See default in <xref linkend="reportheightafterlast"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3 id="partpageorientation" xreflabel="Part page orientation">
				<title>Orientation</title>
				<para>
					Page orientation for the whole
					<literal>&lt;Part&gt;</literal>.
					<programlisting>&lt;Part orientation="'portrait'"&gt;
&lt;Part orientation="'landscape'"&gt;</programlisting>
				</para>
				<para>
					Default is portrait orientation.
				</para>
			</sect3>
			<sect3 id="marginsettings" xreflabel="Margin settings">
				<title>Margin settings</title>
				<para>
					Margin settings for the page for the whole
					<literal>&lt;Part&gt;</literal>. Individual
					settings exist for the top, bottom, left and
					right margins of the page. Every setting
					exist in two forms: the RLIB compatible
					"lowerCamelCase" variant and the all lowercase
					with underscore. The latter variants are preferred.
					<programlisting>&lt;Part top_margin="0.2"&gt;
&lt;Part topMargin="0.2"&gt;
&lt;Part bottom_margin="0.2"&gt;
&lt;Part bottomMargin="0.2"&gt;
&lt;Part left_margin="0.2"&gt;
&lt;Part leftMargin="0.2"&gt;
&lt;Part right_margin="0.2"&gt;
&lt;Part rightMargin="0.2"&gt;</programlisting>
				</para>
				<para>
					When <literal>size_unit="'rlib'"</literal> is in effect
					(the default case) the margin unit is inches.
					The margin unit is points (1/72th inches) when
					<literal>size_unit="'points'"</literal> is in effect.
				</para>
				<para>
					Default values for the top, bottom, left and right
					margins are all 0.2, regardless of the unit.
				</para>
				<para>
					Note that <literal>rightMargin</literal> didn't exist
					in RLIB.
				</para>
			</sect3>
			<sect3 id="papertype" xreflabel="Paper type">
				<title>Paper type</title>
				<para>
					Paper type (implicitly: page size) for the whole
					<literal>&lt;Part&gt;</literal>. It exists in
					two forms: the RLIB compatible "lowerCamelCase"
					variant and the all lowercase with underscore.
					The latter variant is preferred.
					<programlisting>&lt;Part paper_type="'A4'"&gt;
&lt;Part paperType="'A4'"&gt;</programlisting>
				</para>
				<para>
					Default value is the current system paper type
					that <ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>
					uses. E.g. if the system is set to US English,
					the default paper type is implicitly
					<literal>letter</literal>. In most of Europe,
					the default paper type is <literal>A4</literal>
				</para>
				<para>
					The paper type can be specified in either lower case
					or upper case, both are accepted.
				</para>
			</sect3>
			<sect3 id="partiter" xreflabel="Part iterations attribute">
				<title>Iterations</title>
				<para>
					The same <literal>&lt;Part&gt;</literal> may be
					executed multiple times.
					<programlisting>&lt;Part iterations="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
				<para>
					Note that a <literal>&lt;Part&gt;</literal> and
					every iteration of it start on a new page.
					This is one way to print multiple copies
					of a report and encode it into the output,
					e.g. in the PDF file.
				</para>
			</sect3>
			<sect3 id="partsuppress" xreflabel="Part suppress attribute">
				<title>Suppress</title>
				<para>
					Report parts may be suppressed.
					<programlisting>&lt;Part suppress="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3 id="suppresspageheaderfirstpage" xreflabel="Suppress page header on the first page">
				<title>Suppress page header on the first page</title>
				<para>
					The <literal>&lt;PageHeader&gt;</literal> section
					(see <xref linkend="pageheader"/> below)
					for <literal>&lt;Part&gt;</literal> may be
					suppressed on the first page.
					<programlisting>&lt;Part suppressPageHeaderFirstPage="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>.
				</para>
				<para>
					Note that this suppression applies only to
					the first page of the complete result (e.g. PDF)
					and not to the first page of an iteration, which
					may fall on a later page of the result.  
				</para>
			</sect3>
		</sect2>
		<sect2 id="partsubsecs">
			<title>Part subsections</title>
			<para>
				As described at the beginning of this section
				(see <xref linkend="parts"/>), a
				<literal>&lt;Part&gt;</literal> may contain
				one or more report rows (<literal>&lt;pr&gt;</literal>)
				which in turn may contain one or more columns
				(<literal>&lt;pr&gt;</literal>). See
				<xref linkend="partrow"/> and <xref linkend="partcol"/>.
				Apart from these, global page headers and footers
				may also be used for report parts.
			</para>
			<sect3 id="pageheader" xreflabel="Page header">
				<title>Page header</title>
				<para>
					This is the description of the page header.
					It contains an <xref linkend="outputnode"/>.
					The expressions in it cannot reference query columns.
					See also <xref linkend="reportpageheader"/>.
					<programlisting>&lt;Part&gt;
    &lt;PageHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageHeader&gt;
&lt;/Part&gt;</programlisting>					
				</para>
			</sect3>
			<sect3 id="pagefooter" xreflabel="Page footer">
				<title>Page footer</title>
				<para>
					This is the description of the page footer.
					It contains an <xref linkend="outputnode"/>.
					The expressions in it cannot reference query columns.
					See also <xref linkend="reportpagefooter"/>.
					<programlisting>&lt;Part&gt;
    &lt;PageFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageFooter&gt;
&lt;/Part&gt;</programlisting>					
				</para>
			</sect3>
			<sect3 id="partrow0">
				<title>Part row</title>
				<para>
					See <xref linkend="partrow"/>.
					<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            ...
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="partrow" xreflabel="Part row">
		<title>Part row</title>
		<para>
			A part row (<literal>&lt;pr&gt;</literal>) may
			contain one or more <xref linkend="partcol"/>s
			(<literal>&lt;pd&gt;</literal>) which are layed out
			side by side horizontally. The longest running column
			will control the height of the row. The next row will
			be continuous from that vertical page position.
		</para>
		<sect2 id="partrowatts">
			<title>Part row attributes</title>
			<para>
				Note that any attribute setting below may only use
				constant expressions or an query column reference
				from <xref linkend="independentqueries"/>.
				An environment variable (since it can't - or shouldn't -
				change during the report execution) is considered constant.
				See <xref linkend="expressions"/>. This allows external
				control for the attributes in question.
			</para>
			<sect3 id="partrowlayout" xreflabel="Part row layout attribute">
				<title>Layout</title>
				<para>
					The <literal>layout</literal> attribute exists only
					for RLIB compatibility, it's ignored.
					It accepts two values: <literal>flow</literal> and
					<literal>fixed</literal>.
					<programlisting>&lt;pr layout="'flow'"&gt;
&lt;pr layout="'fixed'"&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="partrownewpage" xreflabel="Part row new page attribute">
				<title>New page</title>
				<para>
					The <literal>newpage</literal> attribute controls
					whether the part row starts from the point where
					the previous row in the same part ended, or it
					should start on a new page.
					<programlisting>&lt;pr newpage="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>
				</para>
			</sect3>
			<sect3 id="partrowsuppress" xreflabel="Part row suppress attribute">
				<title>Suppress</title>
				<para>
					Report rows may be suppressed.
					<programlisting>&lt;pr suppress="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="partcol" xreflabel="Part column">
		<title>Part column</title>
		<para>
			A part column (<literal>&lt;pd&gt;</literal>) may
			contain one or more <xref linkend="report"/>s
			(<literal>&lt;Report&gt;</literal>) which are layed
			out vertically in this column continuously.
		</para>
		<para>
			Such a report may be inlined:
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
		</para>
		<para>
			A report may also be loaded from a separate file.
			For details, see <xref linkend="loadedreport"/>.
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;load ... /&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
		</para>
		<sect2 id="partcolatts">
			<title>Part column attributes</title>
			<para>
				Note that any attribute setting below may only use
				constant expressions or an query column reference
				from <xref linkend="independentqueries"/>.
				An environment variable (since it can't - or shouldn't -
				change during the report execution) is considered constant.
				See <xref linkend="expressions"/>. This allows external
				control for the attributes in question.
			</para>
			<sect3 id="partcolwidth" xreflabel="Part column width attribute">
				<title>Width</title>
				<para>
					Width of the part column. Optional.
					<programlisting>&lt;pd width="60"&gt;</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the column width is measured in characters,
					which is controlled by <xref linkend="partfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="partfontname"/>. Width is computed
					from the font width.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, width is measured
					in points.
				</para>
				<para>
					Columns without explicitly specified width are
					dynamically sized according to
					<xref linkend="papertype"/>,
					<xref linkend="marginsettings"/> and other
					columns in the same <xref linkend="partrow"/>
					that do have explicitly set width.
				</para>
				<para>
					Columns that exceed the total page width
					(according to <xref linkend="papertype"/> and
					<xref linkend="marginsettings"/>) will be shown
					partially, or won't be shown at all.
				</para>
			</sect3>
			<sect3 id="partcolheight" xreflabel="Part column height attribute">
				<title>Height</title>
				<para>
					Height of the part column.
					<programlisting>&lt;pd height="120"&gt;</programlisting>
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (the default),
					the column height is measured in characters,
					which is controlled by <xref linkend="partfontsize"/>.
					Note, that the font width and height may differ,
					depending on the font face controlled by
					<xref linkend="partfontname"/>. Column height is
					computed from the font height.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, height is measured
					in points.
				</para>
				<para>
					Report details in this part column are layed out
					up to the specified height. See
					<xref linkend="reportheight"/> for further explanation.
				</para>
				<para>
					Note, that OpenCReports allows fixed height
					columns to break over page boundaries. This is a
					deviation from RLIB.
				</para>
			</sect3>
			<sect3 id="pdborderwidth" xreflabel="Part column border width">
				<title>Border width</title>
				<para>
					Border width around the part column.
					It is measured in points.
					<programlisting>&lt;pd border_width="2"&gt;</programlisting>
				</para>
				<para>
					When set, a rectangle around the part column
					will be drawn. The width of outline of the
					rectangle is measured in points.
				</para>
				<para>
					This is a deviation from RLIB where the width
					of the outline was a fixed 0.1 points and an
					inner margin (all of top, bottom, left and right)
					inside the column border was used.
				</para>
				<para>
					If the column breaks over a page boundary,
					the border will be drawn the column parts
					on every page. 
				</para>
			</sect3>
			<sect3 id="pdbordercolor" xreflabel="Part column border color">
				<title>Border color</title>
				<para>
					When <literal>border_width</literal> is set,
					this color is used to draw the border rectangle.
					<programlisting>&lt;pd border_color="'blue'"&gt;</programlisting>
				</para>
				<para>
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="detailcolumns" xreflabel="Detail columns">
				<title>Detail columns</title>
				<para>
					Inner <literal>&lt;Report&gt;</literal>s
					are layed out in one or more columns.
					<programlisting>&lt;pd detail_columns="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
			</sect3>
			<sect3 id="columnpadding" xreflabel="Column padding">
				<title>Column padding</title>
				<para>
					When <literal>detail_columns</literal>
					is set to higher than 1, inner padding
					between the detail columns may be specified.
					<programlisting>&lt;pd column_pad="0.2"&gt;</programlisting>
				</para>
				<para>
					Default value is 0, i.e. no padding.
				</para>
				<para>
					The unit of padding is inches if
					<xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (default), points
					otherwise.
				</para>
			</sect3>
			<sect3 id="partcolsuppress" xreflabel="Part column suppress attribute">
				<title>Suppress</title>
				<para>
					Report columns may be suppressed.
					<programlisting>&lt;pd suppress="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="report" xreflabel="Report">
		<title>Report</title>
		<para>
			This section may occur in a wider context or
			standalone in an OpenCReports XML report
			description file.
		</para>
		<para>
			Example XML skeleton structure with
			<literal>&lt;OpenCReport&gt;</literal> as
			the toplevel node:
			<programlisting>&lt;OpenCReport&gt;
    &lt;Part&gt;
        &lt;pr&gt;
            &lt;pd&gt;
                &lt;Report&gt;
                    ...
                &lt;/Report&gt;
            &lt;/pd&gt;
        &lt;/pr&gt;
    &lt;/Part&gt;
&lt;/OpenCReport&gt;</programlisting>
		</para>
		<para>
			Example XML skeleton structure with
			<literal>&lt;Part&gt;</literal> as
			the toplevel node:
			<programlisting>&lt;Part&gt;
    &lt;pr&gt;
        &lt;pd&gt;
            &lt;Report&gt;
                ...
            &lt;/Report&gt;
        &lt;/pd&gt;
    &lt;/pr&gt;
&lt;/Part&gt;</programlisting>
		</para>
		<para>
			Example XML skeleton structure with
			a standalone <literal>&lt;Report&gt;</literal> node:
			<programlisting>&lt;Report&gt;
    ...
&lt;/Report&gt;</programlisting>
		</para>
		<para>
			When <literal>&lt;Report&gt;</literal> is the
			toplevel node, parent nodes for
			<literal>&lt;Part&gt;</literal>, <literal>&lt;pr&gt;</literal>
			and <literal>&lt;pd&gt;</literal> are implicitly
			created. Subsections and many attributes specific to
			these parent nodes can be used as shortcuts in the
			<literal>&lt;Report&gt;</literal> node.
		</para>
		<sect2 id="reportattribs" xreflabel="Report attributes">
			<title>Report attributes</title>
			<para>
				Note that any attribute setting below may only use
				constant expressions or an query column reference
				from <xref linkend="independentqueries"/>.
				An environment variable (since it can't - or shouldn't -
				change during the report execution) is considered constant.
				See <xref linkend="expressions"/>. This allows external
				control for the attributes in question.
			</para>
			<sect3 id="reportfontname" xreflabel="Report font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the report's scope. It can be overridden by
					child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Report font_name="'Arial'"&gt;
&lt;Report fontName="'Arial'"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is what's set for
					<xref linkend="partfontname"/>, or
					<literal>Courier</literal> if both are unset.
				</para>
			</sect3>
			<sect3 id="reportfontsize" xreflabel="Report font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the report's scope. It can be overridden by
					child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Report font_size="10"&gt;
&lt;Report fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font name is what's set for
					<xref linkend="partfontsize"/>, or
					<literal>12</literal> if both are unset.
				</para>
			</sect3>
			<sect3 id="repsizeunit">
				<title>Size unit</title>
				<para>
					Shortcut for the <xref linkend="sizeunit"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Report&gt;</literal> is the toplevel node.
					<programlisting>&lt;Report size_unit="'rlib'"&gt;
&lt;Report size_unit="'points'"&gt;</programlisting>
				</para>
				<para>
					When <literal>&lt;OpenCReport&gt;</literal> or
					<literal>&lt;Part&gt;</literal> is the toplevel
					node in the report XML description, this attribute
					for <literal>&lt;Report&gt;</literal> is ignored.
				</para>
			</sect3>
			<sect3 id="nqsnd1">
				<title>No query show NoData attribute</title>
				<para>
					Shortcut for <xref linkend="noqueryshownodata"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
                    <literal>&lt;Report&gt;</literal> is the toplevel node.
					<programlisting>&lt;Report noquery_show_nodata="yes"&gt;
&lt;Report noquery_show_nodata="no&gt;</programlisting>
				</para>
				<para>
					See default in <xref linkend="noqueryshownodata"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3 id="rhal1">
				<title>Report height after last attribute</title>
				<para>
					Shortcut for <xref linkend="reportheightafterlast"/> in
					<literal>&lt;OpenCReport&gt;</literal> when
					<literal>&lt;Part&gt;</literal> is the toplevel node.
					<programlisting>&lt;Report report_height_after_last="yes"&gt;
&lt;Report report_height_after_last="no"&gt;</programlisting>
				</para>
				<para>
					See default in <xref linkend="reportheightafterlast"/>
					See also <xref linkend="nodatanode"/>.
				</para>
			</sect3>
			<sect3 id="orientation">
				<title>Orientation</title>
				<para>
					Shortcut for <xref linkend="partpageorientation"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node when
					<literal>&lt;Report&gt;</literal> is standalone.
					<programlisting>&lt;Report orientation="'portrait'"&gt;
&lt;Report orientation="'landscape'"&gt;</programlisting>
				</para>
				<para>
					Default is portrait orientation.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="marginsettings1">
				<title>Margin settings</title>
				<para>
					Shortcuts for <xref linkend="marginsettings"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node. Individual
					settings exist for the top, bottom, left and
					right margins of the page. Every setting
					exist in two forms: the RLIB compatible
					"lowerCamelCase" variant and the all lowercase
					with underscore. The lowecase-with-underscore
					variants are the preferred ones.
					<programlisting>&lt;Report top_margin="0.2"&gt;
&lt;Report topMargin="0.2"&gt;
&lt;Report bottom_margin="0.2"&gt;
&lt;Report bottomMargin="0.2"&gt;
&lt;Report left_margin="0.2"&gt;
&lt;Report leftMargin="0.2"&gt;
&lt;Report right_margin="0.2"&gt;
&lt;Report rightMargin="0.2"&gt;</programlisting>
				</para>
				<para>
					When <literal>size_unit="'rlib'"</literal> is in effect
					(the default case) the margin unit is inches.
					The margin unit is points (1/72th inches) when
					<literal>size_unit="'points'"</literal> is in effect.
				</para>
				<para>
					Default values for the top, bottom, left and right
					margins are all 0.2, regardless of the unit.
				</para>
				<para>
					Note that <literal>rightMargin</literal> didn't exist
					in RLIB.
				</para>
				<para>
					These settings for <literal>&lt;Report&gt;</literal>
					are ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="papertype1">
				<title>Paper type</title>
				<para>
					Shortcut for <xref linkend="papertype"/>
					for the implicitly created parent
					<literal>&lt;Part&gt;</literal> node. It exists in
					two forms: the RLIB compatible "lowerCamelCase"
					variant and the all lowercase with underscore.
					The lowecase-with-underscore variant is preferred.
					<programlisting>&lt;Part paper_type="'A4'"&gt;
&lt;Part paperType="'A4'"&gt;</programlisting>
				</para>
				<para>
					Default value is the current system paper type
					that <ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>
					uses. E.g. if the system is set to US English,
					the default paper type is implicitly
					<literal>letter</literal>. In most of Europe,
					the default paper type is <literal>A4</literal>
				</para>
				<para>
					The paper type can be specified in either lower case
					or upper case, both are accepted.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="reportheight" xreflabel="Report height">
				<title>Height</title>
				<para>
					Height of the report.
					<programlisting>&lt;Report height="120"&gt;</programlisting>
				</para>
				<para>
					This setting is interpreted differently depending on
					whether the report XML description uses
					<literal>&lt;OpenCReport&gt;</literal>
					as the toplevel node, or it uses
					either <literal>&lt;Part&gt;</literal> or
					<literal>&lt;Report&gt;</literal>.
				</para>
				<sect4 id="reportheightocrpt">
					<title>Report height in OpenCReports mode</title>
					<para>
						When <xref linkend="sizeunit"/> is set to
						<literal>rlib</literal> (the default),
						the report height is measured in characters,
						which is controlled by <xref linkend="reportfontsize"/>.
						Note, that the font width and height may differ,
						depending on the font face controlled by
						<xref linkend="reportfontname"/>. Report height is
						computed from the font height.
					</para>
					<para>
						When <xref linkend="sizeunit"/> is set to
						<literal>points</literal>, height is measured
						in points.
					</para>
					<para>
						Report details are layed out up to the
						specified height. If the report would run longer
						than the specified height, it gets truncated.
						When the report fits in the specified height,
						the next report starts with the remaining height
						added as padding before it.
					</para>
					<para>
						If the <literal>&lt;Report&gt;</literal> is the last
						one in the <literal>&lt;pd&gt;</literal> node, then
						the report may or may not be padded with the remaining
						height, depending on the
						<xref linkend="reportheightafterlast"/>.
					</para>
					<para>
						If height is unset for the parent
						<literal>&lt;pd&gt;</literal> node, it is expanded
						with this vertical padding.
					</para>
					<para>
						In case height is set for both the parent
						<literal>&lt;pd&gt;</literal> node and the
						<literal>&lt;Report&gt;</literal> nodes in it,
						the height value for <literal>&lt;pd&gt;</literal>
						is applied first. It would limit the displayed
						rows in whichever <literal>&lt;Report&gt;</literal> node
						is terminated by it. Subsequent
						<literal>&lt;Report&gt;</literal> nodes would
						no be displayed in that <literal>&lt;pd&gt;</literal>
						node.
					</para>
					<para>
						Note, that OpenCReports allows fixed-height
						reports to break over page boundaries.
						This is a deviation from RLIB.
					</para>
				</sect4>
				<sect4 id="reportheightrlib">
					<title>Report height in RLIB compatibility mode</title>
					<para>
						When parsing XML descriptions from RLIB, i.e. when
						either <literal>&lt;Part&gt;</literal> or
						<literal>&lt;Report&gt;</literal> is used as
						the toplevel node, compatibility mode is turned on
						for interpreting this setting.
					</para>
					<para>
						In this mode, the report height is interpreted
						as a percentage of the height set in
						<xref linkend="partcolheight"/>. In this case,
						the report height setting is a hint, to use it
						as <emphasis>minimum height</emphasis>.
						If the <literal>&lt;Report&gt;</literal> is rendered
						on the same page from start to end, and is shorter
						than the height of the parent
						<literal>&lt;pd&gt;</literal> node, then a gap is
						added to the <literal>&lt;Report&gt;</literal>.
						If there are multiple <literal>&lt;Report&gt;</literal>
						nodes in the same <literal>&lt;pd&gt;</literal>
						node, this will separate them visually.
					</para>
					<para>
						Note, that this behaviour is not available when
						using the programming API to create a report.
						It's only for RLIB compatibility which relied
						only on the report XML description file.
					</para>
				</sect4>
			</sect3>
			<sect3 id="reportiter" xreflabel="Report iterations attribute">
				<title>Iterations</title>
				<para>
					The same <literal>&lt;Report&gt;</literal> may be
					executed multiple times.
					<programlisting>&lt;Report iterations="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
			</sect3>
			<sect3 id="reportsuppress" xreflabel="Report suppress attribute">
				<title>Suppress</title>
				<para>
					Reports may be suppressed.
					<programlisting>&lt;Report suppress="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3 id="sph">
				<title>Suppress page header on the first page</title>
				<para>
					Shortcut for <xref linkend="suppresspageheaderfirstpage"/>
					in the implicitly created parent
					<literal>&lt;Part&gt;</literal> node when
					<literal>&lt;Report&gt;</literal> is the
					toplevel node.
					<programlisting>&lt;Report suppressPageHeaderFirstPage="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>no</literal>.
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;Part&gt;</literal> node
					in the XML description.
				</para>
			</sect3>
			<sect3 id="reportqueryname" xreflabel="Report query name">
				<title>Query</title>
				<para>
					Set the primary query name for <literal>&lt;Report&gt;</literal>
					from the list of <xref linkend="queriesnode"/>.
					<programlisting>&lt;Report query="query1"&gt;</programlisting>
				</para>
				<para>
					Default value is unset, i.e. use the first
					query from the list of <xref linkend="queriesnode"/>.
				</para>
				<para>
					Column references of the report's primary query
					and its follower queries may be used in
					<xref linkend="expressions"/> of
					<xref linkend="outputnode"/> sections in
					a <literal>&lt;Report&gt;</literal> node:
					<xref linkend="reportpageheader"/>,
					<xref linkend="reportpagefooter"/>,
					<xref linkend="repheader"/>,
					<xref linkend="repfooter"/>,
					<literal>&lt;FieldHeaders&gt;</literal> and
					<literal>&lt;FieldDetails&gt;</literal> in
					<xref linkend="detailnode"/>,
					and also in <xref linkend="breaknode"/>s and
					<xref linkend="variablenode"/>s.
				</para>
				<para>
					When a query is empty (i.e. it doesn't have data rows)
					then the <xref linkend="nodatanode"/> will be shown.
				</para>
				<para>
					When the query name is set to a non-existing query,
					then the appearance of the <xref linkend="nodatanode"/>
					is controlled by <xref linkend="noqueryshownodata"/>.
				</para>
			</sect3>
			<sect3 id="reportfhpriority" xreflabel="Report field header priority attribute">
				<title>Field header priority</title>
				<para>
					Set the field header priority for the report versus
					break (header and footer) priority. This setting
					selects which report detail is encompassing the other.
					<programlisting>&lt;Report field_header_priority="'low'"&gt;
&lt;Report field_header_priority="'high'"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>high</literal>. In this
					mode, the field header is printed on the top of every
					page of the report and break headers and footers are
					encompassed by it. The default is chosen for RLIB
					compatibility.
				</para>
				<para>
					When this setting is <literal>low</literal>,
					field headers are handled with lower priority
					compared to break headers and footers. In this
					mode, a break header is followed by the field header,
					then data rows (field details), followed by the break
					footer. This brings the field header closer to the field
					details.
				</para>
			</sect3>
			<sect3 id="bw">
				<title>Border width</title>
				<para>
					This is a shortcut for <xref linkend="pdborderwidth"/>
					for the implicitly created <literal>&lt;pd&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					It is measured in points.
					<programlisting>&lt;Report border_width="2"&gt;</programlisting>
				</para>
				<para>
					When set, a rectangle around the part column
					(in this case, around the single report in the
					part column) will be drawn. The width of outline
					of the rectangle is measured in points.
				</para>
				<para>
					This is a deviation from RLIB where the width
					of the outline was a fixed 0.1 points and an
					inner margin (all of top, bottom, left and right)
					inside the column border was used. Also, this shortcut
					didn't exist in RLIB, the <literal>&lt;pd&gt;</literal>
					node had to be present.
				</para>
				<para>
					If the report (column) breaks over a page boundary,
					the border will be drawn the column parts
					on every page. 
				</para>
				<para>
					This setting for <literal>&lt;Report&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;pd&gt;</literal> node.
				</para>
			</sect3>
			<sect3 id="bc">
				<title>Border color</title>
				<para>
					This is a shortcut for <xref linkend="pdbordercolor"/>
					for the implicitly created <literal>&lt;pd&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					When <literal>border_width</literal> is set,
					this color is used to draw the border rectangle.
					<programlisting>&lt;Report border_color="'blue'"&gt;</programlisting>
				</para>
				<para>
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="dcols">
				<title>Detail columns</title>
				<para>
					Shortcut for <xref linkend="detailcolumns"/>
					in the implicitly created parent
					<literal>&lt;pd&gt;</literal> when
					<literal>&lt;Parent&gt;</literal> is the
					toplevel node.
					<programlisting>&lt;Report detail_columns="3"&gt;</programlisting>
				</para>
				<para>
					Default value is 1.
				</para>
				<para>
					This setting for <literal>&lt;Parent&gt;</literal>
					is ignored when there is a parent
					<literal>&lt;pd&gt;</literal> node in the report
					XML description.
				</para>
			</sect3>
			<sect3 id="cpadding">
				<title>Column padding</title>
				<para>
					Shortcut for <xref linkend="columnpadding"/>
					in the implicitly created parent
					<literal>&lt;pd&gt;</literal> node when
					<literal>&lt;Parent&gt;</literal> is the
					toplevel node.
					<programlisting>&lt;Report column_pad="0.2"&gt;</programlisting>
				</para>
				<para>
					Default value is 0, i.e. no padding.
				</para>
				<para>
					The unit of padding is inches if
					<xref linkend="sizeunit"/> is set to
					<literal>rlib</literal> (default), points
					otherwise.
				</para>
			</sect3>
		</sect2>
		<sect2 id="repsubsecs">
			<title>Report subsections</title>
			<sect3 id="reportpageheader" xreflabel="Report page header">
				<title>Page header</title>
				<para>
					This may be seen as a shortcut for
					<xref linkend="pageheader"/> in the implicitly
					created <literal>&lt;Part&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					Except that report query column references are also
					allowed in expressions instead of only constants and
					column references of <xref linkend="independentqueries"/>.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;PageHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageHeader&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					This subsection for <literal>&lt;Report&gt;</literal>
					is ignored when there is a page header section
					defined for the <literal>&lt;Part&gt;</literal> node,
					either in the <literal>&lt;Part&gt;</literal> node
					itself or in a previous child <literal>&lt;Report&gt;</literal>
					node for the same <literal>&lt;Part&gt;</literal>.
					A warning is issued in this case.
				</para>
			</sect3>
			<sect3 id="reportpagefooter" xreflabel="Report page footer">
				<title>Page footer</title>
				<para>
					This may be seen as a shortcut for
					<xref linkend="pagefooter"/> in the implicitly
					created <literal>&lt;Part&gt;</literal>
					node when <literal>&lt;Report&gt;</literal> is standalone.
					Except that report query column references are also
					allowed in expressions instead of only constants and
					column references of <xref linkend="independentqueries"/>.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;PageFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/PageFooter&gt;
&lt;/Part&gt;</programlisting>					
				</para>
				<para>
					This subsection for <literal>&lt;Report&gt;</literal>
					is ignored when there is a page footer section
					defined for the <literal>&lt;Part&gt;</literal> node,
					either in the <literal>&lt;Part&gt;</literal> node
					itself or in a previous child <literal>&lt;Report&gt;</literal>
					node for the same <literal>&lt;Part&gt;</literal>.
					A warning is issued in this case.
				</para>
			</sect3>
			<sect3 id="repheader" xreflabel="Report header">
				<title>Report header</title>
				<para>
					This is the description of the report header that is
					print at the beginning of the report.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;ReportHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/ReportHeader&gt;
&lt;/Part&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="repfooter" xreflabel="Report footer">
				<title>Report footer</title>
				<para>
					This is the description of the report footer that is
					printed at the end of the report.
					It contains an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;ReportFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/ReportFooter&gt;
&lt;/Part&gt;</programlisting>					
				</para>
			</sect3>
			<sect3 id="repvars1">
				<title>Variables</title>
				<para>
					This section describes the
					<xref linkend="variablesnode"/> in the report.
					<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable ... /&gt;
        ...
    &lt;/Variables&gt;
&lt;/Part&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="breaks1">
				<title>Breaks</title>
				<para>
					This section describes the
					<xref linkend="breaksnode"/> in the report.
					<programlisting>&lt;Report&gt;
    &lt;Breaks&gt;
        &lt;Break ... &gt;
            ...
        &lt;/Break&gt;
        ...
    &lt;/Breaks&gt;
&lt;/Part&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="detailnode" xreflabel="Detail node">
				<title>Detail</title>
				<para>
					This section describes the tabular details of the report.
					There are two subsections in this node, both contain
					an <xref linkend="outputnode"/>.
					<programlisting>&lt;Report&gt;
    &lt;Detail&gt;
        &lt;FieldHeaders&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/FieldHeaders&gt;
        &lt;FieldDetails&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/FieldDetails&gt;
    &lt;/Detail&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					<literal>&lt;FieldHeaders&gt;</literal> is used
					to describe the header for data rows.
				</para>
				<para>
					<literal>&lt;FieldDetails&gt;</literal> is used
					to show data that is derived from the current data row
					produced by the report query.
				</para>
			</sect3>
			<sect3 id="nodatanode" xreflabel="NoData node">
				<title>Alternate output for no data</title>
				<para>
					This section describes the alternate output of the report
					when the query has no data rows, or there is no such
					query name defined that's set in
					<xref linkend="reportqueryname"/>.
					It contains an <xref linkend="outputnode"/>.
				</para>
				<para>
					This section may be declared in two ways. One way is to
					spell out the <literal>&lt;Alternate&gt;</literal> node:
					<programlisting>&lt;Report&gt;
    &lt;Alternate&gt;
        &lt;NoData&gt;
            &lt;Output&gt;
                ...
            &lt;/Output&gt;
        &lt;/NoData&gt;
    &lt;/Alternate&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					The other way is without the
					<literal>&lt;Alternate&gt;</literal> node:
					<programlisting>&lt;Report&gt;
    &lt;NoData&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/NoData&gt;
&lt;/Part&gt;</programlisting>
				</para>
				<para>
					When the <xref linkend="reportqueryname"/>
					does not exist in in the global list of
					<xref linkend="queriesnode"/> and the
					<xref linkend="noqueryshownodata"/> is set, then
					the <literal>&lt;NoData&gt;</literal> section
					is not displayed.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="loadedreport" xreflabel="Loaded report">
		<title>Loaded report</title>
		<para>
			It is like an inline <xref linkend="report"/> it is
			loaded from a different file.
		</para>
		<sect2 id="lrepatts">
			<title>Loaded Report attributes</title>
			<sect3 id="lrepfname">
				<title>File name</title>
				<para>
					<programlisting>&lt;load name="report1.xml" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="queryattr" xreflabel="Query attribute">
				<title>Query</title>
				<para>
					This attribute overrides the
					<xref linkend="queryattr"/> of
					<literal>&lt;Report&gt;</literal>.
					This way, the report in the separate file can be reused
					for a different data set.
					<programlisting>&lt;load query="query1" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="lrepiter">
				<title>Iterations</title>
				<para>
					This attribute overrides the
					<xref linkend="reportiter"/> of <literal>&lt;Report&gt;</literal>.
					<programlisting>&lt;load iterations="5" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="variablesnode" xreflabel="Variables">
		<title>Variables</title>
		<para>
			This is the parent node for individual
			<literal>&lt;Variable&gt;</literal> nodes
			that describe each variable.
			<programlisting>&lt;Variables&gt;
    &lt;Variable ... /&gt;
    ...
&lt;/Variables&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="variablenode" xreflabel="Variable node">
		<title>Variable</title>
		<para>
			This node describes one
			<literal>&lt;Variable&gt;</literal> node.
			It has no children nodes, only attributes.
			<programlisting>&lt;Variable ... /&gt;</programlisting>
		</para>
		<sect2 id="varatts">
			<title>Variable attributes</title>
			<sect3 id="varname">
				<title>Name</title>
				<para>
					The name of the variable. It must be
					unique in the list of variables for
					the parent <literal>&lt;Report&gt;</literal> node.
					<programlisting>&lt;Variable name="var1" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="varvalue">
				<title>Value</title>
				<para>
					The "value" of the variable, or rather,
					the expression from which the value is
					computed. Variables' values are computed
					for every data row produced by the report
					query. The expression may therefore reference
					field names of queries that are declared
					in the XML description or in programming code.
					<programlisting>&lt;Variable value="q1.field1 + 2 * q2.field2" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="vartype">
				<title>Type</title>
				<para>
					The type of the variable. Several variable
					types exist:
					<programlisting>&lt;Variable value="q1.field" type="expression"/&gt;

&lt;Variable value="q1.field" type="count"/&gt;
&lt;Variable value="q1.field" type="countall"/&gt;

&lt;Variable value="q1.field" type="sum"/&gt;

&lt;Variable value="q1.field" type="average"/&gt;
&lt;Variable value="q1.field" type="averageall"/&gt;

&lt;Variable value="q1.field" type="highest"/&gt;
&lt;Variable value="q1.field" type="lowest"/&gt;

&lt;Variable type="custom" ... /&gt;</programlisting>
				</para>
				<para>
					Default type is <literal>expression</literal>.
					This is just a shortcut for the computed value
					of the expression that saves both typing (in other
					expressions referencing this variable) and time
					to generate the report. This can be considered
					a manual optimization.
				</para>
				<para>
					The <literal>count</literal> and
					<literal>countall</literal> variable
					types count the number of expression
					results for the data set. The former
					leaves out NULL values, the latter includes them.
					This is equivalent to <literal>COUNT(field)</literal>
					and <literal>COUNT(*)</literal> in SQL.
				</para>
				<para>
					The <literal>sum</literal> variable type
					sums the non-NULL values of the expression
					results for the data set.
				</para>
				<para>
					The <literal>average</literal> and
					<literal>averageall</literal> variable types
					are combinations of <literal>sum</literal>
					and either <literal>count</literal> or
					<literal>countall</literal>. They take the value
					computed for each data row, add them together,
					and divide by the number of values. The result
					of <literal>average</literal> and
					<literal>averageall</literal> may differ if
					there is NULL data in the result set.
				</para>
				<para>
					The <literal>highest</literal> and
					<literal>lowest</literal> variable types
					return the highest and the lowest values
					for the data set, respectively.
				</para>
				<para>
					All of the above pre-defined variables types
					work on numeric data.
				</para>
				<para>
					The <literal>custom</literal> variable type
					allow arbitrary user variables if the
					predefined types are not enough, for example,
					when the base type needs to be something else
					then a number. See below.
				</para>
				<sect4 id="xmlvarexamples" xreflabel="Complete variable examples">
					<title>Complete variable examples</title>
					<para>
						Here's a complete example of an expression variable:
						<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="query1.field1 + query2.field2"
            type="expression" /&gt;
    &lt;/Variables&gt;

    &lt;Detail&gt;
        &lt;FieldHeaders&gt;
            &lt;literal value="'My variable'" /&gt;
        &lt;/FieldHeaders&gt;

        &lt;FieldDetails&gt;
            &lt;field value="v.var1" /&gt;
        &lt;/FieldDetails&gt;
    &lt;/Detail&gt;
&lt;/Report&gt;</programlisting>
					</para>
					<para>
						Note, that in this simple example, there is
						no difference if the variable is used in
						the <literal>&lt;field&gt;</literal> or the
						<literal>query1.field1 + query2.field2</literal>
						expression. The efficiency of not computing
						the variable again for the same data row can be
						observed when the variable is used multiple times
						and the report processes a huge data set.
					</para>
					<para>
						Here's a complete example of using a variable:
						<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="r.self + query1.field1 + query2.field2"
            type="expression" /&gt;
    &lt;/Variables&gt;

    &lt;Detail&gt;
        &lt;FieldHeaders&gt;
            &lt;literal value="'My variable'" /&gt;
        &lt;/FieldHeaders&gt;

        &lt;FieldDetails&gt;
            &lt;field value="v.var1" /&gt;
        &lt;/FieldDetails&gt;
    &lt;/Detail&gt;
&lt;/Report&gt;</programlisting>
					</para>
					<para>
						The trick is to use the <literal>r.self</literal>
						internal variable.
					</para>
					<para>
						Please note, that the above example will
						not work as is, because for the first row,
						<emphasis>there is no previous row</emphasis>.
						But there is a trick to avoid such problems,
						namely using the <xref linkend="ternaryop"/>
						(or its equivalent, the <xref linkend="iiffunc"/>) and the
						<literal>rownum()</literal> to perform only safe
						computations. (Note that the <literal>value=...</literal>
						part below is a single line.)
						<programlisting>&lt;Variable&gt;
    ...
    value="rownum() == 1 ?
           query1.field1 + query2.field2 :
           r.self + query1.field1 + query2.field2"
    ...
&lt;/Variable&gt;</programlisting>
					</para>
					<para>
						This example shows the correct operation of
						an iterative expression. For the first row,
						set a known good value. For every subsequent rows,
						the previous row value may be used for deriving
						the new value from.
					</para>
					<para>
						The above spelled out example can also be written
						as a <literal>sum</literal>ming variable:
						<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="query1.field1 + query2.field2"
            type="sum" /&gt;
    &lt;/Variables&gt;

    &lt;Detail&gt;
        &lt;FieldHeaders&gt;
            &lt;literal value="'My variable'" /&gt;
        &lt;/FieldHeaders&gt;

        &lt;FieldDetails&gt;
            &lt;field value="v.var1" /&gt;
        &lt;/FieldDetails&gt;
    &lt;/Detail&gt;
&lt;/Report&gt;</programlisting>
					</para>
					<para>
						Here are two examples of the 
						<literal>count</literal> and
						<literal>countall</literal> variable types:
						<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="query1.field1"
            type="count" /&gt;

        &lt;Variable
            name="var2"
            value="query1.field1"
            type="countall" /&gt;
    &lt;/Variables&gt;
&lt;/Report&gt;</programlisting>
					</para>
					<para>
						Here are two examples of using the
						<literal>average</literal> and
						<literal>averageall</literal>
						variable types:
						<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="query1.field1"
            type="average" /&gt;

        &lt;Variable
            name="var2"
            value="query1.field1"
            type="averageall" /&gt;
    &lt;/Variables&gt;
&lt;/Report&gt;</programlisting>
					</para>
					<para>
						Here are two examples of using
						<literal>highest</literal> and
						<literal>lowest</literal> variable types:
						<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="query1.field1"
            type="highest" /&gt;

        &lt;Variable
            name="var2"
            value="query1.field1"
            type="lowest" /&gt;
    &lt;/Variables&gt;
&lt;/Report&gt;</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="customvarattrs" xreflabel="Custom variable attributes">
				<title>Custom variable attributes</title>
				<para>
					These attributes below define a custom variable.
					A base expression, up to two intermediary expressions
					and one result expression may be defined, together
					with the expression type.
					<programlisting>&lt;Variable
    baseexpr="..."
    intermedexpr="..."
    intermed2expr="..."
    resultexpr="..."
    basetype="..."
    type="custom"/&gt;</programlisting>
				</para>
				<para>
					<literal>baseexpr</literal>, <literal>intermedexpr</literal>,
					<literal>intermed2expr</literal> and <literal>resultexpr</literal>
					are <xref linkend="expressions"/>.
				</para>
				<para>
					Iterative or recursive variables can use
					<xref linkend="exprself"/>.
				</para>
				<para>
					Possible values for <literal>basetype</literal> are
					<literal>number</literal>, <literal>string</literal>
					or <literal>datetime</literal>.
				</para>
				<para>
					It's the user's responsibility to use expressions
					valid for the base type. Failing that, the result
					value will be an appropriate error message.
				</para>
				<para>
					Note that the <literal>baseexpr</literal> attribute
					is an alias for <literal>value</literal>.
				</para>
				<sect4 id="xmlcustomvarexample" xreflabel="Custom variable example">
					<title>Custom variable example</title>
					<para>
						For example, the <literal>average</literal> variable
						works this way behind the scenes as written below.
						<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="averagevar1"
            type="custom"
            basetype="number"
            baseexpr="query1.field1"
            intermedexpr="(rownum() == 1 ? 0 : r.self) +
                          (isnull(r.baseexpr) ?
                              0 : r.baseexpr)"
            intermed2expr="r.self +
                           (isnull(r.baseexpr) ? 0 : 1)"
            resultexpr="r.intermedexpr / r.intermed2expr"
            /&gt;
    &lt;/Variables&gt;
&lt;/Report&gt;</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="resetonbreak" xreflabel="Reset on break attribute">
				<title>Reset on break</title>
				<para>
					A variable may be reset on break boundaries to the
					base expression value, e.g. 0 for
					<literal>count</literal> and other pre-defined variable
					types. See <xref linkend="breaknode"/> and
					<xref linkend="breaks"/>.
					<programlisting>&lt;Variable resetonbreak="break1" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. no reset on a break.
				</para>
				<para>
					Here's an example to use a variable that's value
					is reset on a break boundary:
					<programlisting>&lt;Report&gt;
    &lt;Breaks&gt;
        &lt;Break name="break1" ... &gt;
            &lt;BreaksHeader&gt;
                &lt;Output&gt;
                    &lt;field value="v.var1" /&gt;
                &lt;/Output&gt;
            &lt;/BreaksHeader&gt;
            &lt;BreaksFields&gt;
                &lt;BreaksField value="query1.field2" /&gt;
            &lt;/BreaksFields&gt;
        &lt;/Break&gt;
    &lt;/Breaks&gt;

    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="query1.field1"
            type="average"
            precalculate="yes"
            resetonbreak="'break1'" /&gt;
    &lt;/Variables&gt;
    ...
&lt;/Report&gt;</programlisting>
				</para>
				<para>
				</para>
			</sect3>
			<sect3 id="precalcvarattr" xreflabel="Precalculate attribute">
				<title>Precalculate (delayed)</title>
				<para>
					A variable may work two ways. The first way is to
					generate an immediate value that is valid for the current
					row. See <xref linkend="expressions"/>. An expression
					may reference the value computed for previous data row,
					see <xref linkend="exprself"/>.
				</para>
				<para>
					The other way is <xref linkend="precalcvar"/>.
					The attribute is accepted under two names:
					<programlisting>&lt;Variable precalculate="yes" /&gt;
&lt;Variable delayed="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>no</literal>.
				</para>
				<para>
					A precalculated variable may also use the
					<xref linkend="resetonbreak"/>. In this case,
					the precalculated value is computed for each
					break range separately.
				</para>
				<para>
					Precalculated variables may be used to show totals in
					e.g. <xref linkend="repheader"/>,
					in <literal>&lt;FieldHeaders&gt;</literal> in
					<xref linkend="detailnode"/>,
					in <xref linkend="breakheadernode"/>
					and in
					<xref linkend="reportpageheader"/>,
					among other places.
				</para>
				<para>
					Here's an example of a precalculated variable:
					<programlisting>&lt;Report&gt;
    &lt;Variables&gt;
        &lt;Variable
            name="var1"
            value="query1.field1"
            type="average"
            precalculate="yes" /&gt;
    &lt;/Variables&gt;

    &lt;ReportHeader&gt;
        &lt;Output&gt;
            &lt;field value="v.var1"&gt;
        &lt;/Output&gt;
    &lt;/ReportHeader&gt;
&lt;/Report&gt;</programlisting>
				</para>
				<para>
					To reveal the internals of a variable
					that's value is reset on break boundaries,
					here is the equivalent using a
					<literal>custom</literal> variable.
					The value returned by the <xref linkend="brrownumfunc"/>
					automatically resets at every break boundary, so it
					can be used as below.
					<programlisting>&lt;Variables&gt;
    &lt;Variable
        name="var1"
        type="custom"
        baseexpr="query1.field1"
        intermedexpr="(brrownum('break1') == 1 ? 0 : r.self) +
                      (isnull(r.baseexpr) ?
                          0 : r.baseexpr)"
        intermed2expr="r.self +
                       (isnull(r.baseexpr) ? 0 : 1)"
        resultexpr="r.intermedexpr / r.intermed2expr"
        /&gt;
&lt;/Variables&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="breaksnode" xreflabel="Breaks">
		<title>Breaks</title>
		<para>
			This is the parent node for individual
			<literal>&lt;Break&gt;</literal> nodes
			that describe each break. See <xref linkend="breaks"/>
			<programlisting>&lt;Breaks&gt;
    &lt;Break ... /&gt;
    ...
&lt;/Break&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="breaknode" xreflabel="Break node">
		<title>Break</title>
		<para>
			This node describes one
			<literal>&lt;Break&gt;</literal>.
			<programlisting>&lt;Break ... &gt;
    &lt;BreakHeader&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/BreakHeader&gt;
    &lt;BreakFooter&gt;
        &lt;Output&gt;
            ...
        &lt;/Output&gt;
    &lt;/BreakFooter&gt;
    &lt;BreakFields&gt;
        &lt;BreakField /&gt;
        ...
    &lt;/BreakFields&gt;
&lt;/Break&gt;</programlisting>
		</para>
		<para>
			The order in which <literal>Break</literal> nodes are listed
			matters for two reasons.
		</para>
		<para>
			The primary reason is that break fields are
			hierarchical. The break fields listed earlier
			are higher in the hierarchy. If a break field
			earlier in the list triggers, all subsequent
			break fields also trigger implicitly.
		</para>
		<para>
			The second reason is a consequence of the
			previous one: emitting the
			<xref linkend="breakheadernode"/>s
			occur in the order of the list.
			For logical reasons,
			<xref linkend="breakfooternode"/>s
			are in reverse order.
		</para>
		<sect2 id="breakatts">
			<title>Break attributes</title>
			<sect3 id="breakname">
				<title>Name</title>
				<para>
					The name of the break. It must be
					unique in the list of breaks for
					the parent <literal>&lt;Report&gt;</literal> node.
					<programlisting>&lt;Break name="break1" /&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="breakhnp">
				<title>Header on new page</title>
				<para>
					After a break boundary, the header starts on a new page.
					Accepted in two variants:
					<programlisting>&lt;Break headernewpage="yes" /&gt;
&lt;Break newpage="yes" /&gt;</programlisting>
				</para>
				<para>
					The <literal>newpage="yes"</literal> variant is
					parsed but ignored in RLIB.
				</para>
			</sect3>
			<sect3 id="breaksb">
				<title>Suppress break header and footer for blank break fields</title>
				<para>
					Suppress break header and footer in case
					any of the break fields' values are either
					<literal>NULL</literal> or an empty string,
					if the break field is of the string type.
					<programlisting>&lt;Break suppressblank="yes" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="breaksubsecs">
			<title>Break subsections</title>
			<sect3 id="breakheadernode" xreflabel="BreakHeader">
				<title>BreakHeader</title>
				<para>
					The break header is printed before the new data row
					if it causes a break, i.e. the values in the set of
					break fields changed from one row to the next.
					It contains an <xref linkend="outputnode"/> child node.
					<programlisting>&lt;BreakHeader&gt;
    &lt;Output&gt;
        ...
    &lt;/Output&gt;
&lt;/BreakHeader&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="breakfooternode" xreflabel="BreakFooter">
				<title>BreakFooter</title>
				<para>
					The break header is printed after the previous data row
					if it causes a break, i.e. the values in the set of
					break fields changed from one row to the next. Also
					before the first row in the data set.
					It contains an <xref linkend="outputnode"/> child node.
					<programlisting>&lt;BreakHeader&gt;
    &lt;Output&gt;
        ...
    &lt;/Output&gt;
&lt;/BreakHeader&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="breafields">
				<title>BreakFields</title>
				<para>
					The break fields node contains one or more
					<xref linkend="breakfield"/> children nodes.
					<programlisting>&lt;BreakFields&gt;
    &lt;BreakField ... /&gt;
    ...
&lt;/BreakFields&gt;</programlisting>
				</para>
				<sect4 id="breakfield" xreflabel="BreakField">
					<title>BreakField</title>
					<para>
						The break field node only has one attribute and
						contains no child nodes.
						<programlisting>&lt;BreakField value="..."/&gt;</programlisting>
					</para>
					<para>
						The sole attribute in
						<literal>&lt;BreakField&gt;</literal> is
						<literal>&lt;value&gt;</literal> where the
						expression watched for changes is declared.
						See <xref linkend="expressions"/>.
					</para>
					<para>
						There must be at least one
						<literal>&lt;BreakField&gt;</literal> node
						listed. When more than one break fields
						are listed, then all of them are watched
						for value changes. If any of them changes,
						a break boundary occurs for the break.
					</para>
				</sect4>
			</sect3>
		</sect2>
		<sect2 id="breaksexample" xreflabel="A complete break example">
			<title>A complete break example</title>
			<para>
				This XML part below shows a complete example of
				nested breaks based on the real life example
				mentioned in <xref linkend="groupingdata"/>.
				<programlisting>&lt;Report&gt;

    &lt;Breaks&gt;

        &lt;Break&gt;

            &lt;BreakHeader&gt;
                &lt;Output&gt;
                    &lt;Line&gt;
                        &lt;field value="query1.department" /&gt;
                    &lt;/Line&gt;
                &lt;/Output&gt;
            &lt;/BreakHeader&gt;

            &lt;BreakFooter&gt;
                &lt;Output&gt;
                    &lt;Line&gt;
                        &lt;literal&gt;End of &lt;/literal&gt;
                        &lt;field value="query1.department" /&gt;
                    &lt;/Line&gt;
                &lt;/Output&gt;
            &lt;/BreakFooter&gt;

            &lt;BreakFields&gt;
                &lt;BreakField value="query1.department" /&gt;
            &lt;/BreakFields&gt;

        &lt;/Break&gt;

        &lt;Break&gt;

            &lt;BreakHeader&gt;
                &lt;Output&gt;
                    &lt;Line&gt;
                        &lt;literal width="30" /&gt;
                        &lt;field value="query1.paygrade" /&gt;
                    &lt;/Line&gt;
                &lt;/Output&gt;
            &lt;/BreakHeader&gt;

            &lt;BreakFooter&gt;
                &lt;Output&gt;
                    &lt;Line&gt;
                        &lt;literal width="30" /&gt;
                        &lt;literal&gt;End of &lt;/literal&gt;
                        &lt;field value="query1.paygrade" /&gt;
                    &lt;/Line&gt;
                &lt;/Output&gt;
            &lt;/BreakFooter&gt;

            &lt;BreakFields&gt;
                &lt;BreakField value="query1.paygrade" /&gt;
            &lt;/BreakFields&gt;

        &lt;/Break&gt;

    &lt;/Breaks&gt;

    &lt;Detail&gt;

        &lt;FieldHeaders&gt;
            &lt;Output&gt;
                &lt;Line&gt;
                    &lt;literal width="60" /&gt;
                    &lt;literal&gt;Employee name&lt;/literal&gt;
                &lt;/Line&gt;
            &lt;/Output&gt;
        &lt;/FieldHeaders&gt;

        &lt;FieldDetails&gt;
            &lt;Output&gt;
                &lt;Line&gt;
                    &lt;literal width="60" /&gt;
                    &lt;field value="query1.employee" /&gt;
                &lt;/Line&gt;
            &lt;/Output&gt;
        &lt;/FieldDetails&gt;

    &lt;Detail&gt;

&lt;/Report&gt;</programlisting>
			</para>
			<para>
				Assuming that <xref linkend="sizeunit"/> is set to
				<literal>points</literal>, the indentation would be
				30 and 60 points for certain elements (see the empty
				<literal>&lt;literal&gt;</literal>s) and the result
				would look like this:
				<orderedlist>
					<listitem>
						<para>
							Before the first row on every page, the contents
							of <literal>&lt;FieldHeaders&gt;</literal> is
							printed.
						</para>
					</listitem>
					<listitem>
						<para>
							Before the first row, the contents of
							<literal>&lt;BreakHeader&gt;</literal>
							is printed for every break declared in
							the <literal>&lt;Report&gt;</literal> in
							the order of their declaration.
						</para>
					</listitem>
					<listitem>
						<para>
							The contents of
							<literal>&lt;FieldDetails&gt;</literal>
							is printed for the current row. Repeat until
							a value change is observed between
							adjacent rows for a break's expression.
							In this case, the employees are printed
							in one block that are in the current paygrade
							category and working at the current department.
						</para>
					</listitem>
					<listitem>
						<para>
							When a value change happened between
							adjacent rows for a break's expression,
							then this break and every break declared after
							it triggers. For every triggering breaks,
							their <literal>&lt;BreakFooter&gt;</literal>
							is printed in the reverse order of their
							declaration. This is done using the
							<emphasis>previous row</emphasis>, so if any data
							used from the row or derived from it (e.g. a
							variable) and is to be displayed in the footer,
							it will be valid for the break range that just
							ended.
						</para>
					</listitem>
					<listitem>
						<para>
							Before the new row, the contents of
							<literal>&lt;BreakHeader&gt;</literal>
							is printed for every break that just triggered.
							For example, the department's name is not
							printed if only the paygrade category changed
							in the same department from the one row to
							the next.
						</para>
					</listitem>
					<listitem>
						<para>
							Repeat from step 3 until there are no more
							data rows.
						</para>
					</listitem>
				</orderedlist>
			</para>
		</sect2>
	</sect1>
	<sect1 id="outputnode" xreflabel="Output node">
		<title>Output</title>
		<para>
			The <literal>&lt;Output&gt;</literal> node is used
			by many previously mentioned sections. This is the
			generic node that describes how details are displayed
			in reports.
		</para>
		<sect2 id="outputatts">
			<title>Output attributes</title>
			<para>
				Note that <xref linkend="expressions"/> in attribute
				settings below depend on the parent node context.
				Some may only use constant expressions or query column
				references from <xref linkend="independentqueries"/>.
				<literal>&lt;Output&gt;</literal> nodes in
				<literal>&lt;Report&gt;</literal> context may also
				use report query column references.
			</para>
			<sect3 id="outpsuppress">
				<title>Suppress</title>
				<para>
					Output nodes may be suppressed as a whole.
					<programlisting>&lt;Output suppress="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
		</sect2>
		<sect2 id="outputsubsecs">
			<title>Output subsections</title>
			<sect3 id="outpline">
				<title>Line</title>
				<para>
					A line containing text elements of varying widths.
					See <xref linkend="linenode"/>.
					<programlisting>&lt;Output&gt;
    &lt;Line&gt;
        ...
    &lt;/Line&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
			<sect3 id="outphline">
				<title>HorizontalLine</title>
				<para>
					A horizontal line.
					See <xref linkend="hlinenode"/>.
					<programlisting>&lt;Output&gt;
    &lt;HorizontalLine ... /&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
			<sect3 id="outpimg">
				<title>Image</title>
				<para>
					An image.
					See <xref linkend="imagenode"/>.
					<programlisting>&lt;Output&gt;
    &lt;Image ... /&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
			<sect3 id="outpbarcode">
				<title>Barcode</title>
				<para>
					A barcode.
					See <xref linkend="barcodenode"/>.
					<programlisting>&lt;Output&gt;
    &lt;Barcode ... /&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
			<sect3 id="outpimgend">
				<title>Image end</title>
				<para>
					Terminator for a previous image or barcode node.
					See <xref linkend="imageendnode"/>.
					<programlisting>&lt;Output&gt;
    &lt;ImageEnd/&gt;
&lt;/Output</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="linenode" xreflabel="Line node">
		<title>Line</title>
		<para>
			A line containing text elements of varying widths.
			<programlisting>&lt;Output&gt;
    &lt;Line&gt;
        ...
    &lt;/Line&gt;
&lt;/Output</programlisting>
		</para>
		<sect2 id="lineatts">
			<title>Line attributes</title>
			<para>
				Note that <xref linkend="expressions"/> in attribute
				settings below depend on the parent node context.
				Some may only use constant expressions or query column
				references from <xref linkend="independentqueries"/>.
				Child nodes of <literal>&lt;Output&gt;</literal> nodes in
				<literal>&lt;Report&gt;</literal> context may also
				use report query column references.
			</para>
			<sect3 id="linefontname" xreflabel="Line font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the line's scope. It can be overridden
					by child nodes for their scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Line font_name="'Arial'"&gt;
&lt;Line fontName="'Arial'"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is what's set (in decreasing priority)
					in <xref linkend="reportfontname"/> or
					<xref linkend="partfontname"/>.
					If none of them is set, it's <literal>Courier</literal>.
				</para>
			</sect3>
			<sect3 id="linefontsize" xreflabel="Line font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the line's scope. It can be overridden by
					child nodes for their scope. It may be specified
					in two forms, the first one is the preferred name,
					the second is for RLIB compatibility:
					<programlisting>&lt;Line font_size="10"&gt;
&lt;Line fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font name is what's set (in decreasing priority)
					in <xref linkend="reportfontsize"/> or
					<xref linkend="partfontsize"/>.
					If none of them is set, it's <literal>12</literal>.
				</para>
			</sect3>
			<sect3 id="lineboldattr" xreflabel="Line bold attribute">
				<title>Bold font</title>
				<para>
					Whether the line elements use bold font.
					<programlisting>&lt;Line bold="yes"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>.
				</para>
			</sect3>
			<sect3 id="lineitalicattr" xreflabel="Line italic attribute">
				<title>Italic font</title>
				<para>
					Whether the line elements use italic font.
					It is accepted in two forms:
					<programlisting>&lt;Line italic="yes"&gt;
&lt;Line italics="yes"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>.
				</para>
			</sect3>
			<sect3 id="linesuppress">
				<title>Suppress</title>
				<para>
					Text lines may be suppressed. If the parent
					<literal>&lt;Output&gt;</literal> node is in
					<literal>&lt;FieldDetails&gt;</literal>, the
					expression may be derived from a query field.
					<programlisting>&lt;Line suppress="yes"&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3 id="linetextcolor">
				<title>Text color</title>
				<para>
					This color is used to render text. It's accepted
					with both American and British spelling.
					<programlisting>&lt;Line color="'blue'"&gt;
&lt;Line colour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>black</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="linebgcolor">
				<title>Background color</title>
				<para>
					This color is used to render the background
					rectangle under the text. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Line bgcolor="'blue'"&gt;
&lt;Line bgcolour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is <literal>white</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
		</sect2>
		<sect2 id="linesubsecs">
			<title>Line subsections</title>
			<sect3 id="linetxtelem">
				<title>Text element</title>
				<para>
					See the <xref linkend="textelemnode"/>.
					Two variants are accepted.
					<programlisting>&lt;Line&gt;
    &lt;field value="expression..." ... /&gt;
&lt;/Line&gt;</programlisting> and
					<programlisting>&lt;Line&gt;
    &lt;literal ... &gt;Literal text&lt;/literal&gt;
&lt;/Line&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="lineimg">
				<title>Image element</title>
				<para>
					An <literal>&lt;Image&gt;</literal> is accepted
					as a line element. See the <xref linkend="imagenode"/>.
					<programlisting>&lt;Line&gt;
    &lt;Image value="expression..." ... /&gt;
&lt;/Line&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="linebarcode">
				<title>Barcode element</title>
				<para>
					A <literal>&lt;Barcode&gt;</literal> is accepted
					as a line element. See the <xref linkend="barcodenode"/>.
					<programlisting>&lt;Line&gt;
    &lt;Barcode value="expression..." ... /&gt;
&lt;/Line&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="textelemnode" xreflabel="Text element node">
		<title>Text element</title>
		<para>
			Two variants are accepted.
			<programlisting>&lt;Line&gt;
    &lt;field value="expression..." ... /&gt;
&lt;/Line&gt;</programlisting> and
			<programlisting>&lt;Line&gt;
    &lt;literal ... &gt;Literal text&lt;/literal&gt;
&lt;/Line&gt;</programlisting>
		</para>
		<para>
			Neither <literal>field</literal> nor
			<literal>literal</literal> have child nodes,
			only attributes or XML values.
		</para>
		<para>
			The two variants are interchangeable, see
			<xref linkend="elemvalueattr"/> below.
		</para>
		<sect2 id="textelematts">
			<title>Text element attributes</title>
			<para>
				Note that <xref linkend="expressions"/> in attribute
				settings below depend on the parent node context.
				Some may only use constant expressions or query column
				references from <xref linkend="independentqueries"/>.
				Child nodes of <literal>&lt;Output&gt;</literal> nodes in
				<literal>&lt;Report&gt;</literal> context may also
				use report query column references.
			</para>
			<sect3 id="elemvalueattr" xreflabel="Text element value">
				<title>Value</title>
				<para>
					The value of the text element. It's accepted in two
					ways: in the <literal>value</literal> attribute or as
					the XML value for the <literal>field</literal> and
					<literal>literal</literal> nodes.
					<programlisting>&lt;Line&gt;
    &lt;field value="'This text'" /&gt;
    &lt;field&gt;This text&lt;/field&gt;
    &lt;literal value="'This text'" /&gt;
    &lt;literal&gt;This text&lt;/literal&gt;
&lt;/Line&gt;</programlisting>
				</para>
				<para>
					The value is parsed as an expression
					from the <literal>value</literal> attribute.
					See <xref linkend="expressions"/>.
				</para>
				<para>
					On the other hand, the value is taken as a literal
					string from the XML value in the second and fourth
					examples above.
				</para>
			</sect3>
			<sect3 id="textelemdelayed" xreflabel="Precalculated value in XML">
				<title>Delayed (precalculated) value</title>
				<para>
					This setting indicates whether the value is
					"delayed" or "precalculated", i.e. the value for
					the last row in the data set is used for every row.
					It is equivalent to referencing an
					<xref linkend="exprvar"/> with
					<literal>precalculate="yes"</literal> and
					without <literal>resetonbreak</literal>.
					<programlisting>&lt;field delayed="yes" /&gt;
&lt;field precalculate="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>.
				</para>
				<para>
					This setting is only applicable for
					line elements in the
					<xref linkend="outputnode"/> node in
					<literal>&lt;Report&gt;</literal> context.
				</para>
				<para>
					Note that in OpenCReports, an expression may mix
					references to precalculated variables with
					non-precalculated variables and query field references.
					The result will use the precalculated value only for
					the precalculated variables. Other references will
					use values derived from the current row in the data set.
					This is an extension over RLIB.
				</para>
			</sect3>
			<sect3 id="formatattr" xreflabel="Text element format attribute">
				<title>Format string</title>
				<para>
					The format string is one way to format the
					field <literal>value</literal> to be displayed
					in the generated output.
				</para>
				<para>
					The format string is expected to be a string
					so quoting around it is needed.
				</para>
				<para>
					See <xref linkend="formatting"/> for details.
				</para>
				<sect4 id="formatattrexamples" xreflabel="Format attribute examples">
					<title>Format attribute examples</title>
					<para>
						Format a value as a string, first as is, second
						with adding a surrounding text:
						<programlisting>&lt;field value="query1.field1" format="'%s'" &gt;

&lt;field value="query1.field1"
       format="'Look, there is a %s there!'" &gt;</programlisting>
					</para>
					<para>
						Here's the same with the "new syle" formatting flag:
						<programlisting>&lt;field value="query1.field1" format="'!&amp;%s'" /&gt;

&lt;field value="query1.field1"
       format="'Look, there is a !&amp;%s there!'" &gt;</programlisting>
					</para>
					<para>
						Also, with the 2nd generation new style formatting
						flag:
						<programlisting>&lt;field value="query1.field1"
       format="'!&amp;{%s}'" ... /&gt;</programlisting>
					</para>
					<para>
						Here's an example to truncate a string
						to 6 characters using format string flags
						in legacy and both new style formatting flags:
<programlisting>&lt;field value="query1.field1"
       format="'%6.6s'" ... /&gt;

&lt;field value="query1.field1"
       format="'!&amp;%6.6s'" ... /&gt;

&lt;field value="query1.field1"
       format="'!&amp;{%6.6s}'" ... /&gt;</programlisting>
					</para>
					<para>
						Format a numeric value with three decimal places,
						first as is, second with adding a surrounding text:
						<programlisting>&lt;field value="query1.field1"
       format="'%.3d'" &gt;

&lt;field value="query1.field1"
       format="'You have %.3d apples.'" &gt;</programlisting>
					</para>
					<para>
						Convert a number from a string and the value with two
						decimal places:
						<programlisting>&lt;field value="val(query1.field1)"
       format="'%.2d'" /&gt;</programlisting>
					</para>
					<para>
						Here are the same examples using the "new style"
						formatting flags:
						<programlisting>&lt;field value="query1.field1"
       format="'!#%.3d'" &gt;

&lt;field value="query1.field1"
       format="'You have !#%.3d apples.'" &gt;

&lt;field value="val(query1.field1)"
       format="'!#%.2d'" /&gt;</programlisting>
					</para>
					<para>
						Here are the same examples using the 2nd generation
						new style formatting flags:
						<programlisting>&lt;field value="query1.field1"
       format="'!#{%.3d}'" &gt;

&lt;field value="query1.field1"
       format="'You have !#{%.3d} apples.'" &gt;

&lt;field value="val(query1.field1)"
       format="'!#%.2d'" /&gt;</programlisting>
					</para>
					<para>
						Format a numeric value with monetary details
						either using the first or the second generation
						format strings:
						<programlisting>&lt;field value="query1.field1"
       format="'!$%=*#150n'" /&gt;

&lt;field value="query1.field1"
       format="'!${%=*#150n}'" /&gt;</programlisting>
					</para>
					<para>
						Format a datetime value, first with the preferred
						datetime format for the locale, then only the year,
						month and day using the YYYY-MM-DD format:
						<programlisting>&lt;field value="query1.field1"
       format="'!@%c'" /&gt;

&lt;field value="query1.field1"
       format="'!@%Y-%m-%d'" ... /&gt;</programlisting>
					</para>
					<para>
						Here's the same using the second generation
						format strings:
						<programlisting>&lt;field value="query1.field1"
       format="'!@{%c}'" ... /&gt;

&lt;field value="query1.field1"
       format="'!@{%Y-%m-%d}'" ... /&gt;</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="textelemwidth" xreflabel="Text element width">
				<title>Width</title>
				<para>
					The field width.
					<programlisting>&lt;field value="3" format="'%.2d'" width="6" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. the field width
					is implicitly set to the rendered width (in points)
					of the field's formatted value as text, using the
					font name and font size of the field.
				</para>
				<para>
					When the field is the last one in the
					<literal>&lt;Line&gt;</literal>, then its width
					will be the remaining page or column width.
				</para>
				<para>
					If set, the width's unit depends on the
					<xref linkend="sizeunit"/>.
				</para>
				<para>
					When the <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal>, the field width is measured
					in number of characters.
				</para>
				<para>
					The character width is queried from the font set by
					<xref linkend="linefontname"/> and
					<xref linkend="linefontsize"/>,
					<xref linkend="reportfontname"/> and
					<xref linkend="reportfontsize"/>, or
					<xref linkend="partfontname"/> and
					<xref linkend="partfontsize"/>
					in decreasing order of precedence.
				</para>
				<para>
					<xref linkend="textelemfontname"/> and
					<xref linkend="textelemfontsize"/>
					<emphasis>do not influence</emphasis>
					the field width calculation.
				</para>
				<para>
					This allows using uniquely set font name and size for
					individual text elements, including proportional
					fonts, using the RLIB compatible field width settings.
				</para>
				<para>
					When using different font names or font sizes for
					different text elements in the same
					<literal>&lt;Line&gt;</literal>, the text elements
					are aligned vertically so all text elements are
					rendered on the same typographic baseline.
				</para>
			</sect3>
			<sect3 id="textelemalign" xreflabel="Text element alignment">
				<title>Alignment</title>
				<para>
					It specifies the alignment for the text element.
					It works in accordance with the
					<xref linkend="textelemwidth"/>, i.e. the field's
					formatted value (as text) is aligned inside the
					specified field width.
					<programlisting>&lt;field value="3" format="'%.2d'"
       width="6" align="'center'" /&gt;</programlisting>
				</para>
				<para>
					The alignment values may be
					<literal>left</literal>,
					<literal>right</literal>,
					<literal>center</literal> or
					<literal>justified</literal>.
				</para>
				<para>
					Justified alignment is like left alignment,
					but for <xref linkend="memo"/>s,
					all lines but the last are justified.
					This is best used with the default word wrapping.
					In this case, the spacing between words is enlarged.
					<literal>justified</literal> and <literal>left</literal>
					behave the same for single-line fields.
				</para>
				<para>
					Default is <literal>left</literal>.
				</para>
				<para>
					OpenCReports decoupled
					the data from displaying it. For example,
					with the PDF output, the text element is not
					truncated to the element width. Instead,
					pixel perfect alignment is used together
					with masking the parts of the value with
					a bounding box. This is an improvement over
					RLIB where data was truncated (in every output
					formats) because it was designed for using only
					monospace fonts.
				</para>
			</sect3>
			<sect3 id="textcolor">
				<title>Text color</title>
				<para>
					This color is used to render text. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Line color="'blue'"&gt;
&lt;Line colour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is what's set for <xref linkend="linenode"/>,
					otherwise <literal>black</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="textbgcolor">
				<title>Background color</title>
				<para>
					This color is used to render the background
					rectangle under the text. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Line bgcolor="'blue'"&gt;
&lt;Line bgcolour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is what's set for <xref linkend="linenode"/>,
					otherwise <literal>white</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="textelemfontname" xreflabel="Text element font name">
				<title>Font name</title>
				<para>
					The font name attribute specifies the font
					for the text element's scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_name="'Arial'"&gt;
&lt;Part fontName="'Arial'"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_name</literal>
					is used.
				</para>
				<para>
					Default font name is what's set (in decreasing priority)
					in <xref linkend="linefontname"/>,
					<xref linkend="reportfontname"/> or
					<xref linkend="partfontname"/>.
					If none of them is set, it's <literal>Courier</literal>.
				</para>
			</sect3>
			<sect3 id="textelemfontsize" xreflabel="Text element font size">
				<title>Font size</title>
				<para>
					The font size attribute specifies the font size
					for the text element's scope.
					It may be specified in two forms, the first one
					is the preferred name, the second is for RLIB
					compatibility:
					<programlisting>&lt;Part font_size="10"&gt;
&lt;Part fontSize="10"&gt;</programlisting>
				</para>
				<para>
					If both forms are specified, <literal>font_size</literal>
					is used.
				</para>
				<para>
					Default font name is what's set (in decreasing priority)
					in <xref linkend="linefontsize"/>,
					<xref linkend="reportfontsize"/> or
					<xref linkend="partfontsize"/>.
					If none of them is set, it's <literal>12</literal>.
				</para>
			</sect3>
			<sect3 id="textbold">
				<title>Bold font</title>
				<para>
					Whether the text element uses bold font.
					It overrides the <xref linkend="lineboldattr"/>
					for this text element.
					<programlisting>&lt;field bold="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is what's set for
					<xref linkend="lineboldattr"/>.
					<literal>false</literal> if both are unset.
				</para>
			</sect3>
			<sect3 id="textitalic">
				<title>Italic font</title>
				<para>
					Whether the text element uses italic font.
					It overrides the <xref linkend="lineitalicattr"/>
					for this text element.
					It is accepted in two forms:
					<programlisting>&lt;field italic="yes" /&gt;
&lt;field italics="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is what's set for
					<xref linkend="lineitalicattr"/>.
					<literal>false</literal> if both are unset.
				</para>
			</sect3>
			<sect3 id="weblink">
				<title>Web link</title>
				<para>
					This attribute adds a weblink to the text element.
					E.g. clicking on this text element in the generated
					PDF will open a browser with the website.
					<programlisting>&lt;field value="'This is my website'"
       link="'https://github.com/zboszor/OpenCReports'" /&gt;</programlisting>
				</para>
				<para>
					Default is no weblink.
				</para>
			</sect3>
			<sect3 id="memo" xreflabel="Multi-line (memo) field">
				<title>Multi-line (memo) field</title>
				<para>
					This attribute allows breaking long text fields
					to multiple lines according to the 
					<xref linkend="textelemwidth"/>.
					<programlisting>&lt;field value="'This is a long text...'"
       width="12" memo="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>, i.e. the field
					is rendered on a single line.
				</para>
				<para>
					Every line of the text element (regardless if it's a memo
					field or not) is aligned according to
					<xref linkend="textelemalign"/>.
				</para>
			</sect3>
			<sect3 id="memowrap">
				<title>Multi-line field wrapping</title>
				<para>
					This attribute allows wrapping multi-line
					text at characters as opposed to words.
					<programlisting>&lt;field value="'This is a long text...'"
       width="12" memo="yes" memo_wrap_chars="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>, i.e. the field
					is wrapped at word boundaries.
				</para>
				<para>
					In OpenCReports, character wrapping adds hyphenation.
					This is an improvement over RLIB.
				</para>
			</sect3>
			<sect3 id="memorowlimit">
				<title>Multi-line field row limit</title>
				<para>
					This attribute allows limiting multi-line
					text with a maximum row number.
					<programlisting>&lt;field value="'This is a long text...'"
       width="12" memo="yes" memo_max_lines="20" /&gt;</programlisting>
				</para>
				<para>
					Default is no limit.
				</para>
			</sect3>
			<sect3 id="textxlate">
				<title>Translation</title>
				<para>
					This attribute allows the text element to
					be translated to a specified language or locale.
					See <xref linkend="locale"/>.
					<programlisting>&lt;field value="'This is a field'"
       translate="yes" /&gt;</programlisting>
				</para>
				<para>
					The expression result for <literal>translate</literal>
					must be numeric (boolean).
				</para>
				<para>
					For translations to work, the translation settings
					and the language (locale) must be correctly set up.
				</para>
				<para>
					OpenCReports will attempt to translate
					both the format string (if specified) and the text
					element's value. For example, if the format string
					has a translated variant in the translations,
					then this formatted result will be translated:
					<programlisting>&lt;field value="q.apples"
       format="'You have %d apples.'"
       translate="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>no</literal>.
				</para>
				<para>
					An alternative way is to use the translation
					functions directly in the field expression.
					See <xref linkend="translatefunc"/>
					and <xref linkend="translate2func"/>.
					When using them, the <literal>translate="yes"</literal>
					attribute is not needed.
				</para>
			</sect3>
			<sect3 id="textcolid">
				<title>Column number</title>
				<para>
					This attribute is accepted for RLIB compatibility,
					but it's unused.
					<programlisting>&lt;field value="'This is a long text...'"
       col="3" /&gt;</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="hlinenode" xreflabel="HorizontalLine node">
		<title>HorizontalLine</title>
		<para>
			A horizontally drawn line.
			<programlisting>&lt;Output&gt;
    &lt;HorizontalLine ... /&gt;
&lt;/Output</programlisting>
		</para>
		<sect2 id="hlineatts">
			<title>HorizontalLine attributes</title>
			<para>
				Note that <xref linkend="expressions"/> in attribute
				settings below depend on the parent node context.
				Some may only use constant expressions or query column
				references from <xref linkend="independentqueries"/>.
				Child nodes of <literal>&lt;Output&gt;</literal> nodes in
				<literal>&lt;Report&gt;</literal> context may also
				use report query column references.
			</para>
			<sect3 id="hlinewidth">
				<title>Line width</title>
				<para>
					The line width is measured in points,
					regardless of the <xref linkend="sizeunit"/>.
					<programlisting>&lt;HorizontalLine size="3" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>1.0</literal>
				</para>
			</sect3>
			<sect3 id="hlinealign">
				<title>Line alignment</title>
				<para>
					The possible alignment values are
					<literal>left</literal>,
					<literal>right</literal> and
					<literal>center</literal>. Default is
					<literal>left</literal> alignment.
					The alignment is only applied if the line
					length is shorter than the designated page
					or column width without the margins.
					<programlisting>&lt;HorizontalLine align="'center'"
                length="200" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>1.0</literal>
				</para>
			</sect3>
			<sect3 id="hlineindent">
				<title>Indentation</title>
				<para>
					Extra indentation for the line.
					It is measured in points,
					regardless of the <xref linkend="sizeunit"/>.
					<programlisting>&lt;HorizontalLine indent="15" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>0.0</literal>
				</para>
			</sect3>
			<sect3 id="hlinelength" xreflabel="HorizontalLine length">
				<title>Length</title>
				<para>
					The line length.
					<programlisting>&lt;HorizontalLine length="150" /&gt;</programlisting>
				</para>
				<para>
					The line length unit depends on the
					<xref linkend="sizeunit"/>.
					When set to <literal>rlib</literal>,
					it is measured in number of characters.
					The is influenced by <xref linkend="hlinefontsize"/>,
					<xref linkend="reportfontsize"/> and
					<xref linkend="partfontsize"/> in decreasing order,
					which in turn is influenced by
					<xref linkend="reportfontname"/> and
					<xref linkend="partfontname"/> in decreasing order.
				</para>
				<para>
					When <xref linkend="sizeunit"/> is set to
					<literal>points</literal>, the line length
					is measured in points.
				</para>
				<para>
					Default is unset, i.e. the line is drawn across
					the page width.
				</para>
			</sect3>
			<sect3 id="hlinefontsize" xreflabel="HorizontalLine font size">
				<title>Font size</title>
				<para>
					An extra knob to influence line length computation.
					See <xref linkend="hlinelength"/>.
					It is accepted in two forms, <literal>font_size</literal>
					is the preferred one, the other is accepted for
					RLIB compatibility:
					<programlisting>&lt;HorizontalLine font_size="14" /&gt;
&lt;HorizontalLine fontSize="14" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. only
					<xref linkend="reportfontsize"/> and
                    <xref linkend="partfontsize"/> would contribute
					to the horizontal line width computation.
				</para>
			</sect3>
			<sect3 id="hlinesuppress">
				<title>Suppress</title>
				<para>
					Horizontal lines may be suppressed. If the parent
					<literal>&lt;Output&gt;</literal> node is in
					<literal>&lt;FieldDetails&gt;</literal>, the
					expression may be derived from a query field.
					<programlisting>&lt;HorizontalLine suppress="yes" /&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3 id="hlinecolor">
				<title>Line color</title>
				<para>
					This color is used to render text. It's accepted
					with both American and  British spelling.
					For RLIB compatibility, it is also accepted
					as <literal>bgcolor</literal>, with both
					American and  British spelling.
					<programlisting>&lt;HorizontalLine color="'blue'" /&gt;
&lt;HorizontalLine colour="'blue'" /&gt;
&lt;HorizontalLine bgcolor="'blue'" /&gt;
&lt;HorizontalLine bgcolour="'blue'" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>black</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="imagenode" xreflabel="Image node">
		<title>Image</title>
		<para>
			An image to draw on the page, either on its own,
			which controls indentation for subsequent elements:
			<programlisting>&lt;Output&gt;
    &lt;Image ... /&gt;
&lt;/Output</programlisting>
			or as a line element:
			<programlisting>&lt;Output&gt;
    &lt;Line ... &gt;
        &lt;Image ... /&gt;
    &lt;Line/&gt;
&lt;/Output</programlisting>
		</para>
		<para>
			After a valid (standalone) image specification,
			subsequent <xref linkend="linenode"/>s and
			<xref linkend="hlinenode"/>s are indented
			by the image width in the same
			<literal>&lt;Output&gt;</literal> node,
			or until an <literal>&lt;ImageEnd&gt;</literal>
			node is encountered in that
			<literal>&lt;Output&gt;</literal> node.
		</para>
		<sect2 id="imageatts">
			<title>Image attributes</title>
			<para>
				Note that <xref linkend="expressions"/> in attribute
				settings below depend on the parent node context.
				Some may only use constant expressions or query column
				references from <xref linkend="independentqueries"/>.
				Child nodes of <literal>&lt;Output&gt;</literal> nodes in
				<literal>&lt;Report&gt;</literal> context may also
				use report query column references.
			</para>
			<sect3 id="imagefname">
				<title>File name</title>
				<para>
					The file name of the image.

					<programlisting>&lt;Image value="'filename.jpg'" /&gt;</programlisting>
				</para>
				<para>
					Default is unset. It makes the
					<literal>Image</literal> not shown.
				</para>
			</sect3>
			<sect3 id="imagesuppress">
				<title>Suppress</title>
				<para>
					The image may be suppressed.
					<programlisting>&lt;Image value="'filename.jpg'"
       suppress="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>,
					i.e. no suppression.
				</para>
			</sect3>
			<sect3 id="imagetype">
				<title>Type</title>
				<para>
					Accepted for RLIB compatibility.
					<programlisting>&lt;Image value="'filename.jpg'"
       type="'jpg'" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. autodetect.
				</para>
				<para>
					Various image formats are supported
					with autodetection via <literal>gdk-pixbuf</literal>.
					SVG (Scalable Vector Graphics) is supported
					via <literal>librsvg</literal>.
				</para>
			</sect3>
			<sect3 id="imagewidth">
				<title>Width</title>
				<para>
					Image width, measured in points regardless of
					the <xref linkend="sizeunit"/>.
					<programlisting>&lt;Image value="'filename.jpg'"
       width="100" /&gt;</programlisting>
				</para>
				<para>
					Default is unset. The image would not be shown,
					unless both width and height are set.
				</para>
				<para>
					When the image is used as a line element,
					this setting is ignored. Instead, the
					image is automatically scaled according to
					the line height.
				</para>
			</sect3>
			<sect3 id="imageheight">
				<title>Height</title>
				<para>
					Image height, measured in points regardless of
					the <xref linkend="sizeunit"/>.
					<programlisting>&lt;Image value="'filename.jpg'"
       height="100" /&gt;</programlisting>
				</para>
				<para>
					Default is unset. The image would not be shown,
					unless both width and height are set.
				</para>
				<para>
					When the image is used as a line element,
					this setting is ignored. Instead, the
					image is automatically scaled according to
					the line height.
				</para>
			</sect3>
			<sect3 id="imagetextwidth">
				<title>Text width</title>
				<para>
					When the image is used as a line element, this
					is the width in which the image is shown.
					Its unit is subject to the <xref linkend="sizeunit"/>,
					by default it's measured in text character
					width for the parent <literal>&lt;Line&gt;</literal>.
					This setting is only used when the image is a
					line element. Two variants are accepted:
					<programlisting>&lt;Image value="'filename.jpg'"
       text_width="8" /&gt;

&lt;Image value="'filename.jpg'"
       textWidth="8" /&gt;</programlisting>
				</para>
				<para>
					Default is 0. As a result, the image would be
					0 points wide, i.e. not shown.
				</para>
				<para>
					This setting is ignored when the image is used
					as an output subsection.
				</para>
			</sect3>
			<sect3 id="imagebgcolor">
				<title>Background color</title>
				<para>
					Image background color. When the image is a line
					element, then the width in which it's shown may
					be wider than the scaled image width. Or possibly,
					the image is vector graphics (SVG) and there is no
					background defined in the image file. Or the image
					file contains transparency (i.e. PNG). The color
					background will be shown around the image or where
					there are transparent pixels.
					<programlisting>&lt;Image value="'filename.jpg'"
       bgcolor="'red'" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. white.
				</para>
			</sect3>
			<sect3 id="imagealign">
				<title>Alignment</title>
				<para>
					Image alignment. When the image is a line
					element, then the width in which it's shown may
					be wider than the scaled image width. The image
					then may be aligned. <literal>left</literal>,
					<literal>right</literal> and <literal>center</literal>
					are accepted.
					<programlisting>&lt;Image value="'filename.jpg'"
       align="'center'" /&gt;</programlisting>
				</para>
				<para>
					Default is left alignment.
				</para>
				<para>
					This setting is ignored when the image is used
					as an output subsection.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="imageendnode" xreflabel="ImageEnd node">
		<title>Image end</title>
		<para>
			Terminator for a previous image.
			This node doesn't have any attributes or
			child nodes. Its purpose is to reset
			indentation caused by a previous
			<xref linkend="imagenode"/> or
			<xref linkend="barcodenode"/>.
			<programlisting>&lt;Output&gt;
    &lt;ImageEnd/&gt;
&lt;/Output</programlisting>
		</para>
	</sect1>
	<sect1 id="barcodenode" xreflabel="Barcode node">
		<title>Barcode element</title>
		<para>
			This line or output element renders a barcode in various formats.
			<programlisting>&lt;Line&gt;
    &lt;Barcode value="expression..." ... /&gt;
&lt;/Line&gt;</programlisting>
		</para>
		<para>
			The <literal>Barcode</literal> does not have child nodes,
			only attributes.
		</para>
		<sect2 id="barcodeatts">
			<title>Barcode element attributes</title>
			<para>
				Note that <xref linkend="expressions"/> in attribute
				settings below depend on the parent node context.
				Some may only use constant expressions or query column
				references from <xref linkend="independentqueries"/>.
				Child nodes of <literal>&lt;Output&gt;</literal> nodes in
				<literal>&lt;Report&gt;</literal> context may also
				use report query column references.
			</para>
			<sect3 id="bcsuppressattr" xreflabel="Barcode suppression">
				<title>Suppress</title>
				<para>
					<literal>&lt;Barcode&gt;</literal> elements
					in <literal>&lt;Output&gt;</literal> may be
					suppressed.
					<programlisting>&lt;Line&gt;
    &lt;Barcode suppress="yes" ... /&gt;
&lt;/Line&gt;</programlisting>
				</para>
				<para>
					Default value is <literal>false</literal>,
					i.e. no suppression.
				</para>
				<para>
					The expression for <literal>suppress</literal>
					must be a constant expression. An environment
					variable (since it can't - or shouldn't - change
					during the report execution) is considered
					constant. See <xref linkend="expressions"/>.
				</para>
			</sect3>
			<sect3 id="bcvalueattr" xreflabel="Barcode string value">
				<title>Value</title>
				<para>
					The string value to be encoded as barcode.
					<programlisting>&lt;Line&gt;
    &lt;Barcode value="'1234567890128'" /&gt;
&lt;/Line&gt;</programlisting>
				</para>
				<para>
					The value is parsed as an expression
					from the <literal>value</literal> attribute.
					See <xref linkend="expressions"/>.
				</para>
			</sect3>
			<sect3 id="barcodedelayed">
				<title>Delayed (precalculated) value</title>
				<para>
					This setting indicates whether the value is
					"precalculated", i.e. the value for the last
					row in the data set is used, or it would be
					the actual value for the current row in the
					data set.
					<programlisting>&lt;Barcode delayed="yes" /&gt;
&lt;Barcode precalculate="yes" /&gt;</programlisting>
				</para>
				<para>
					Default is <literal>false</literal>.
				</para>
				<para>
					This setting is only applicable for
					line elements in the
					<xref linkend="outputnode"/> node in
					<literal>&lt;ReportHeader&gt;</literal>,
					<literal>&lt;ReportFooter&gt;</literal>,
					<literal>&lt;Fieldheaders&gt;</literal>
					<literal>&lt;FieldDetails&gt;</literal>,
					since they are the ones under the
					<literal>&lt;Report&gt;</literal> scope
					with a query.
				</para>
			</sect3>
			<sect3 id="barcodetypeattr" xreflabel="Barcode type attribute">
				<title>Barcode type</title>
				<para>
					The format string is used to format the
					<literal>value</literal> to be displayed
					in the generated output. For example, to
					print a number with two decimal places:
					<programlisting>&lt;Barcode value="'123456789012'" type="'ean-13'" /&gt;</programlisting>
				</para>
				<para>
					The type may be optional, in which
					case it's autodetected and the barcode
					is rendered in the format that first
					allows the <literal>value</literal> string
					to be rendered. Possible types (in the order of
					autodetection) are:
					<literal>upc-a</literal>,
					<literal>ean-13</literal>,
					<literal>upc-e</literal>,
					<literal>ean-8</literal>,
					<literal>isbn</literal>,
					<literal>code39</literal>,
					<literal>code39ext</literal>,
					<literal>code128b</literal>,
					<literal>code128c</literal>, or
					<literal>code128</literal>.
					If <literal>type</literal> is specified,
					the <literal>value</literal> is
					rendered in that barcode type if
					the string is valid for the type.
					If the <literal>value</literal> is invalid
					for the specified <literal>type</literal>,
					or autodetection fails, because the
					<literal>value</literal> is invalid
					for any of the above listed types,
					the barcode is not rendered.
				</para>
			</sect3>
			<sect3 id="barcodewidth" xreflabel="Barcode element width">
				<title>Width</title>
				<para>
					The field width.
					<programlisting>&lt;Barcode value="'...'" width="6" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. the field width
					is implicitly set to the rendered width (in points)
					of the barcode's inherent encoding width.
				</para>
				<para>
					If set, the barcode is scaled to the specified width.
					Its unit depends on the <xref linkend="sizeunit"/>.
				</para>
				<para>
					When the field is the last one in the
					<literal>&lt;Line&gt;</literal> and its width
					is unset, then depending on the remaining width
					of the line, the barcode is either rendered as is,
					or it's scaled to the remaining width.
				</para>
				<para>
					When the <xref linkend="sizeunit"/> is set to
					<literal>rlib</literal>, the field width is measured
					in number of characters that is set for the
					<literal>&lt;Line&gt;</literal>.
				</para>
			</sect3>
			<sect3 id="barcodeheight" xreflabel="Barcode element height">
				<title>Height</title>
				<para>
					The field height.
					<programlisting>&lt;Barcode value="'...'" height="6" /&gt;</programlisting>
				</para>
				<para>
					Default is unset, i.e. the barcode height
					is implicitly controlled by the text in the line
					or the font height set for the line.
				</para>
				<para>
					If set, and it's larger than the text in the line,
					the barcode height controls the line height, with
					empty space added before and after the text elements
					vertically. is scaled to the specified width.
					It's measured in <literal>points</literal>, i.e. 1/72th
					of an inch.
				</para>
				<para>
					When the field is the last one in the
					<literal>&lt;Line&gt;</literal> and its width
					is unset, then depending on the remaining width
					of the line, the barcode is either rendered as is
					(if the remaining width is larger), or it's
					scaled down to the remaining width.
				</para>
			</sect3>
			<sect3 id="barcodecolor">
				<title>Barcode color</title>
				<para>
					This color is used to render the barcode's bars.
					It's accepted with both American and  British spelling.
					<programlisting>&lt;Barcode color="'blue'"&gt;
&lt;Barcode colour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is what's set for <xref linkend="linenode"/>,
					otherwise <literal>black</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
			<sect3 id="barcodebgcolor">
				<title>Barcode background color</title>
				<para>
					This color is used to render the background
					(the "gaps") in the barcode. It's accepted
					with both American and  British spelling.
					<programlisting>&lt;Barcode bgcolor="'blue'"&gt;
&lt;Barcode bgcolour="'blue'"&gt;</programlisting>
				</para>
				<para>
					Default is what's set for <xref linkend="linenode"/>,
					otherwise <literal>white</literal>.
					See <xref linkend="colorspec"/>.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="colorspec" xreflabel="Color specification">
		<title>Color specification</title>
		<para>
			Colors may be specified by HTML notation.
			This contains six hexadecimal digits, representing
			RGB (red, green, blue) values between 0 and 255
			for each color component, prefixed by the
			<literal>#</literal> character.
			<programlisting>&lt;Line bgcolor="'#ffff00'" ... &gt;
&lt;HorizontalLine color="'#ff00ff'" ... &gt;</programlisting>
		</para>
		<para>
			Colors may also be specified by hexadecimal notation.
			This contains six hexadecimal digits, representing
			RGB (red, green, blue) values between 0 and 255
			for each color component, prefixed by
			<literal>0x</literal>.
			<programlisting>&lt;Line bgcolor="'0xffff00'" ... &gt;
&lt;HorizontalLine color="'0xff00ff'" ... &gt;</programlisting>
		</para>
		<para>
			Color names may also be specified by name.
			The following color names are supported for RLIB compatibility.
			Color names are matched in a case-insensitive way.
		</para>
		<para>
			<inlinemediaobject>
				<imageobject>
					<imagedata fileref="images/namedcolors.svg" align="center" />
				</imageobject>
			</inlinemediaobject>
		</para>
	</sect1>
</chapter>

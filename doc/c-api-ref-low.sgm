<chapter id="c-api-ref-low" xreflabel="Low level C API Reference">
	<title>Low level C language API reference</title>
	<sect1 id="lowlevelapi" xreflabel="Low level C API">
		<title>Low level C API</title>
		<para>
			The low level API extends the <xref linkend="highlevelapi"/>
			to either fine-tune the report behaviour, or to create
			a report purely from program code.
		</para>
		<sect2 id="numerictuning" xreflabel="Numeric behavior related functions">
			<title>Numeric behavior related functions</title>
			<sect3 id="setnumprec">
				<title><literal>Set numeric precision</literal></title>
				<para>
					The default is 256 bits of floating point precision.
					The expression string must evaluate to a numeric
					value, the integer part will be used to set
					the number of precision bits for numeric calculations.
					<programlisting>void
ocrpt_set_numeric_precision_bits(opencreport *o,
                                 const char *expr_string);</programlisting>
				</para>
			</sect3>
			<sect3 id="getnumprec">
				<title><literal>Get numeric precision</literal></title>
				<para>
					The report XML description may set the numeric
					precision. This function allows the application
					to query it.
					<programlisting>mpfr_prec_t
ocrpt_get_numeric_precision_bits(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="setroundingmode">
				<title>Set rounding mode</title>
				<para>
					The expression string must evaluate to a string value.
					Possible values are: <literal>nearest</literal>,
					<literal>to_minus_inf</literal>,
					<literal>to_inf</literal>,
					<literal>to_zero</literal>,
					<literal>away_from_zero</literal> and
					<literal>faithful</literal>.
					The default is <literal>nearest</literal>.
					<programlisting>void
ocrpt_set_rounding_mode(opencreport *o,
                        const char *expr_string);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="localefuncs">
			<title>Locale related functions</title>
			<sect3 id="setupxlate">
				<title>Set up translation</title>
				<para>
					Setting up the translation needs two parameters:
					the so called <emphasis>translation domain</emphasis>
					and the toplevel directory for the translations.
					It relies on GNU Gettext.
					<programlisting>void
ocrpt_bindtextdomain(opencreport *o,
                     const char *domainname,
                     const char *dirname);</programlisting>
				</para>
			</sect3>
			<sect3 id="setupxlate2">
				<title>Set up translation (delayed variant)</title>
				<para>
					Setting up the translation needs two parameters:
					the so called <emphasis>translation domain</emphasis>
					and the toplevel directory for the translations.
					It relies on GNU Gettext. This function allows
					setting the translation from a supplemental query.
					The passed in expressions strings must evaluate
					to string values, with potential fallbacks to
					plain strings in case of parse errors or if the
					expressions may be interpreted as query columns
					but no such column names exist in any query.
					<programlisting>void
ocrpt_bindtextdomain_from_expr(opencreport *o,
                               const char *domain_expr,
                               const char *dir_expr);</programlisting>
				</para>
			</sect3>
			<sect3 id="setlocale">
				<title>Set report locale</title>
				<para>
					Setting the locale for the report does not affect
					the main program or other threads. A locale setting
					includes the language and the country. The UTF-8 suffix
					is necessary. E.g.: <literal>en_GB.UTF-8</literal> or
					<literal>de_DE.UTF-8</literal>
					<programlisting>void
ocrpt_set_locale(opencreport *o,
                 const char *locale);</programlisting>
				</para>
			</sect3>
			<sect3 id="setlocale2">
				<title>Set report locale (delayed variant)</title>
				<para>
					This function allows setting the locale
					from a supplementary query of the report.
					It is used by the report XML parser code
					and it's a lower priority setting than the
					previous function: the application executing
					the report may need to be run a different locale.
					The expression string must evaluate to a string
					value that's a valid locale string.
					<programlisting>void
ocrpt_set_locale_from_expr(opencreport *o,
                           const char *expr_string);</programlisting>
				</para>
			</sect3>
			<sect3 id="printmoneyinlocale">
				<title>Print monetary data in the report locale</title>
				<para>
					A customized monetary printing function was implemented
					for the purposes of the report which MPFR doesn't
					provide. It is used in OpenCReports both internally
					and by unit tests.
					<programlisting>ssize_t
ocrpt_mpfr_strfmon(opencreport *o,
                   char *s, size_t maxsize,
                   const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="dsqfuncs">
			<title>Data source and query related functions</title>
			<para>
				The following <literal>enum</literal> and
				<literal>struct</literal> types are used by
				OpenCReports for datasources and queries.
				<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

struct ocrpt_datasource;
typedef struct ocrpt_datasource ocrpt_datasource;

struct ocrpt_query;
typedef struct ocrpt_query ocrpt_query;

struct ocrpt_query_result;
typedef struct ocrpt_query_result ocrpt_query_result;</programlisting>
			</para>
			<para>
				For more details, see <xref linkend="dsandqueries"/>.
				Multiple queries may use the same data source.
			</para>
			<sect3 id="addds">
				<title>Add a datasource</title>
				<para>
					Add a datasource of the specific
					<emphasis>type</emphasis> to the report handler with the
					associated <emphasis>source_name</emphasis>, using
					optional <emphasis>connection parameters</emphasis>.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add(opencreport *o,
                     const char *source_name,
                     const char *type,
                     const ocrpt_input_connect_parameter *conn_params);</programlisting>
				</para>
				<para>
					The pointer to connection parameters can be
					NULL for <literal>array</literal>,
					<literal>csv</literal>, <literal>json</literal>,
					and <literal>xml</literal> datasource types.
				</para>
				<sect4 id="mariadbconnparams">
					<title>MariaDB connection parameters</title>
					<para>
						There are two methods to connect to a MariaDB
						(or MySQL) database.
					</para>
					<para>
						The first method uses a MariaDB (MySQL) specific
						configuration <literal>ini</literal> file and
						the <literal>group</literal> name in it.
						The <literal>group</literal> parameter is mandatory
						as the main database configuration may also have such
						a group section, in which case the separate
						<literal>optionfile</literal> is not needed.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "group", .param_value = "..." },
    { .param_name = "optionfile", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						The second method spells out individual connection
						parameters. This allows <emphasis>local</emphasis>
						and <emphasis>remote</emphasis> database
						connections. The <literal>dbname</literal> parameter
						is mandatory, others are optional.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "dbname", .param_value = "..." },
    { .param_name = "host", .param_value = "..." },
    { .param_name = "port", .param_value = "..." },
    { .param_name = "unix_socket", .param_value = "..." },
    { .param_name = "user", .param_value = "..." },
    { .param_name = "password", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						These connection parameters can be used as XML node
						attributes, see <xref linkend="mariadbds"/>.
					</para>
				</sect4>
				<sect4 id="pgconnparams">
					<title>PostgreSQL connection parameters</title>
					<para>
						There are three methods to connect to a PostgreSQL
						database.
					</para>
					<para>
						The first method uses the PostgreSQL specific
						<emphasis>connection string</emphasis>. It is the
						only setting and as such, it's mandatory. Its content
						is almost freeform, with optional elements.
						See <ulink url="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING">PostgreSQL connection string</ulink>.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "connstr", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						The second method spells out individual connection
						parameters. This allows <emphasis>local</emphasis>
						database connections on a <emphasis>named socket</emphasis>.
						The <literal>unix_socket</literal> and
						<literal>dbname</literal> parameters are mandatory,
						others are optional.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "unix_socket", .param_value = "..." },
    { .param_name = "dbname", .param_value = "..." },
    { .param_name = "user", .param_value = "..." },
    { .param_name = "password", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						The third method also spells out individual connection
						parameters. This allows <emphasis>remote</emphasis>
						database connection using the <literal>host</literal>
						and <literal>port</literal> parameters. Only the
						<literal>dbname</literal> parameter is mandatory,
						others are optional.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "dbname", .param_value = "..." },
    { .param_name = "host", .param_value = "..." },
    { .param_name = "port", .param_value = "..." },
    { .param_name = "user", .param_value = "..." },
    { .param_name = "password", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						There are also two optional parameters that control
						the behaviour of the PostgreSQL driver in OpenCReports,
						rather than being actual connection parameters to a
						PostgreSQL server. These parameters may be used with
						any of the above connection methods.
						<itemizedlist>
							<listitem override="bullet">
								<para>
									The parameter
									<literal>usecursor</literal>
									may have a boolean value:
									<literal>true</literal>,
									<literal>false</literal>,
									<literal>yes</literal>,
									<literal>no</literal>, or
									a numeric value interpreted
									as a boolean value: non-zero
									values mean <literal>true</literal>,
									zero means <literal>false</literal>.
								</para>
								<para>
									When <literal>usecursor</literal> is enabled,
									the SQL query will be wrapped in
									a cursor, and the result is retrieved
									in parts. Otherwise, the SQL query is
									executed as is and the result is
									retrieved in whole.
								</para>
								<para>
									The default value is usually <literal>true</literal>
									but this can be controlled when OpenCReports is built.
								</para>
							</listitem>
							<listitem override="bullet">
								<para>
									When <literal>usecursor</literal> is enabled,
									the parameter <literal>fetchsize</literal>
									controls the number of rows retrieved
									at once. Default value is 1024.
									
								</para>
							</listitem>
						</itemizedlist>
					</para>
					<para>
						Using a cursor as a regular SQL query is a PostgreSQL
						extension. Other SQL databases only allow it in stored
						procedures. But this allows a trade-off: queries
						that return a large number of rows may be processed
						without the risk of running out of memory, with
						marginally lower performance.
					</para>
					<para>
						SQL queries added to the same PostgreSQL
						datasource (connection) will behave the same
						way. Either all of them are executed as is,
						or all of them will use a cursor.
					</para>
					<para>
						These connection parameters can be used as XML node
						attributes, see <xref linkend="postgresqlds"/>.
					</para>
				</sect4>
				<sect4 id="odbcconnparams">
					<title>ODBC connection parameters</title>
					<para>
						There are two methods to connect to an ODBC database.
					</para>
					<para>
						The first method uses the ODBC specific
						<emphasis>connection string</emphasis>. It is the
						only setting, and as such, it's mandatory.
						Its content is defined by the ODBC knowledge base
						with optional elements.
						See
						<ulink url="https://docs.microsoft.com/en-us/sql/odbc/microsoft-open-database-connectivity-odbc">Microsoft Open Database Connectivity</ulink>
						and
						<ulink url="https://www.connectionstrings.com/">Connection string examples </ulink>.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "connstr", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						The second method spells out <emphasis>some</emphasis>
						individual connection parameters. It requires that
						an ODBC data source (DSN) is already configured.
						Whether the database connections is
						<emphasis>local</emphasis> or
						<emphasis>remote</emphasis> depends on the
						pre-configured DSN. The <literal>dbname</literal>
						parameters is mandatory, others are optional.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "dbname", .param_value = "..." },
    { .param_name = "user", .param_value = "..." },
    { .param_name = "password", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						These connection parameters can be used as XML node
						attributes, see <xref linkend="odbcds"/>.
					</para>
				</sect4>
				<sect4 id="ssheetconnparams">
					<title>Spreadsheet connection parameters</title>
					<para>
						There is only one connection parameter for
						spreadsheet based datasources, the file name.
						<programlisting>ocrpt_input_connect_parameter conn_params[] = {
    { .param_name = "filename", .param_value = "..." },
    { .param_name = NULL }
};</programlisting>
					</para>
					<para>
						This parameter can be used as an XML node attribute,
						see <xref linkend="ssheetds"/>.
					</para>
				</sect4>
			</sect3>
			<sect3 id="findds">
				<title>Find a datasource</title>
				<para>
					Find the data source using its name.
					It returns NULL if the named data source
					is not found.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_get(opencreport *o,
                     const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="setdsencoding">
				<title><literal>Set the encoding of a datasource</literal></title>
				<para>
					Set the encoding of a datasource in case
					if it's not already UTF-8, so data provided by
					it is automatically converted.
					<programlisting>void
ocrpt_datasource_set_encoding(ocrpt_datasource *source,
                              const char *encoding);</programlisting>
				</para>
			</sect3>
			<sect3 id="freeds">
				<title><literal>Free a datasource</literal></title>
				<para>
					Free a datasource from the opencreport structure
					it was added to. It's not needed to be called,
					all datasources are automatically free with
					<literal>ocrpt_free()</literal>
					<programlisting>void
ocrpt_datasource_free(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="adddataquery">
				<title>Add a direct data based query</title>
				<para>
					Add a direct (application internal) data based query
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_data(ocrpt_datasource *source,
                     const char *name,
                     const void *data,
                     int32_t rows, int32_t cols,
                     const int32_t *types,
                     int32_t types_cols);</programlisting>
				</para>
				<para>
					The built-in <literal>array</literal> datasource
					interprets <literal>void *data</literal> as a
					two-dimensional array containing pointers to C strings,
					a.k.a. <programlisting>char *array[rows + 1][cols]</programlisting>
					The first row of the array are the column (field) names.
					The <literal>types</literal> array contains
					<literal>cols</literal> (or fewer) number of
					<literal>enum ocrpt_result_type</literal> elements to
					indicate the column data types.
				</para>
				<para>
					If the <literal>types</literal> pointer is
					<literal>NULL</literal>, the column values are treated
					as <literal>string</literal> data. This is how RLIB
					worked.
				</para>
				<para>
					The call is only successful if the datasource
					is direct data based. See <xref linkend="isdsdata"/> and
					<xref linkend="inputdriver"/>.
				</para>
			</sect3>
			<sect3 id="addsymdataquery">
				<title>Add a symbolic data based query</title>
				<para>
					Add a "symbolic" (discoverable by name) data
					based query.
					<programlisting>ocrpt_query *
ocrpt_query_add_symbolic_data(ocrpt_datasource *source,
                              const char *name,
                              const char *data_name,
                              int32_t rows, int32_t cols,
                              const char *types_name,
                              int32_t types_cols);</programlisting>
				</para>
				<para>
					Symbols of the application can be discovered via
					<literal>dlsym()</literal> if the application was
					built with the compiler option
					<literal>-rdynamic</literal>.
				</para>
				<para>
					The call is only successful if the datasource
					is symbolic data based. See <xref linkend="isdssymdata"/>
					and <xref linkend="inputdriver"/>.
				</para>
			</sect3>
			<sect3 id="addfilequery">
				<title>Add a file based query</title>
				<para>
					Add a file based query to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_file(ocrpt_datasource *source,
                     const char *name,
                     const char *filename,
                     const int32_t *types,
                     int32_t types_cols);</programlisting>
				</para>
				<para>
					The call is only successful if the datasource
					is file based. See <xref linkend="isdsfile"/> and
					<xref linkend="inputdriver"/>.
				</para>
				<para>
					The <literal>types</literal> array pointer may be NULL.
					For file based datasource types that don't support
					data type specifiers internally (or they are optional
					and omitted), this means that the column values are of
					the <literal>string</literal> data type. This is how
					RLIB worked. In this case, conversion functions like
					<xref linkend="valfunc"/>, <xref linkend="stodtfunc"/>
					and <xref linkend="intervalfunc"/> are needed to process
					the values using their actual data type.
				</para>
				<para>
					When the <literal>types</literal> array pointer is
					not NULL, it is used to set the data type specifiers
					for built-in file based datasources, even if the file
					contains type specifiers.
				</para>
				<para>
					The JSON file format expected by OpenCReports is defined
					in <xref linkend="jsonds"/>.
				</para>
				<para>
					The XML file format expected by OpenCReports is defined
					in <xref linkend="xmlds"/>.
				</para>
			</sect3>
			<sect3 id="addsqlquery">
				<title>Add an SQL statement based query</title>
				<para>
					Add an SQL statement based query to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_sql(ocrpt_datasource *source,
                    const char *name,
                    const char *querystr);</programlisting>
				</para>
				<para>
					The call is only successful if the datasource
					is SQL based. See <xref linkend="isdssql"/> and
					<xref linkend="inputdriver"/>.
				</para>
			</sect3>
			<sect3 id="isdsdata">
				<title>Test whether a datasource is direct data based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_data(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="isdssymdata">
				<title>Test whether a datasource is direct data based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_symbolic_data(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="isdsfile">
				<title>Test whether a datasource is file based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_file(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="isdssql">
				<title>Test whether a datasource is SQL based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_sql(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="findquery">
				<title><literal>Find a query</literal></title>
				<para>
					Find a query using its name.
					<programlisting>ocrpt_query *
ocrpt_query_get(opencreport *o,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3 id="getcurrentrowofquery">
				<title><literal>Get the current data row from a query</literal></title>
				<para>
					Create (first call) or get the <literal>ocrpt_query_result</literal>
					array from a query. Output parameter <literal>cols</literal>
					returns the number of columns in the result array. It must
					be re-run after ocrpt_navigate_next() since the previously
					returned pointer becomes invalid.
					<programlisting>ocrpt_query_result *
ocrpt_query_get_result(ocrpt_query *q,
                       int32_t *cols);</programlisting>
				</para>
			</sect3>
			<sect3 id="getcolname">
				<title><literal>Get column name</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal> result
					from <literal>ocrpt_query_get_result()</literal>,
					the column names can be discovered from a query.
					<programlisting>const char *
ocrpt_query_result_column_name(ocrpt_query_result *qr,
                               int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3 id="getcoldata">
				<title><literal>Get column data</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal>
					result from
					<literal>ocrpt_query_get_result()</literal>, get a
					pointer to the column data in its internal (hidden)
					representation.
					<programlisting>ocrpt_result *
ocrpt_query_result_column_result(ocrpt_query_result *qr,
                                 int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3 id="addfollowerquery">
				<title><literal>Add a follower query</literal></title>
				<para>
					Add a <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and the follower will run in parallel with it until
					the leader runs out of rows. In case the leader has more
					rows than the follower, then for rows in the leader where
					there are no follower rows, the follower fields are set to NULL.
					<programlisting>bool
ocrpt_query_add_follower(ocrpt_query *leader,
                         ocrpt_query *follower);</programlisting>
				</para>
			</sect3>
			<sect3 id="addn1followerquery">
				<title><literal>Add an N:1 follower query</literal></title>
				<para>
					Add an N:1 <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and rows from the follower will be matched using the
					<literal>match</literal> expression. If there are multiple
					rows in the follower matching the leader row, then the leader
					row will be listed that many times. For rows in the leader
					where there are no matching rows in the follower, the follower
					fields are set to NULL. It is similar to <literal>LEFT OUTER
					JOIN</literal> in SQL databases. For creating an
					<literal>ocrpt_expr</literal> expression pointer, see the
					next section.
					<programlisting>bool
ocrpt_query_add_follower_n_to_1(ocrpt_query *leader,
                                ocrpt_query *follower,
                                ocrpt_expr *match);</programlisting>
				</para>
			</sect3>
			<sect3 id="queryrefresh">
				<title>Refresh query contents</title>
				<para>
					Call the ocrpt_input::refresh() method for
					datasources that support it.
					It returns <literal>true</literal> if
					all queries were successfully refreshed.
					<programlisting>bool
ocrpt_query_refresh(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="freequery">
				<title><literal>Free a query</literal></title>
				<para>
					Free a query and remove it from the report handler.
					It's optional. <literal>ocrpt_free()</literal> frees
					the queries added to the <literal>opencreport</literal>
					structure.
					<programlisting>void
ocrpt_query_free(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="startmainquery">
				<title><literal>Start the main query</literal></title>
				<para>
					Start query (or query set) navigation.
					<literal>q</literal> should be the primary query
					of the report.
					<programlisting>void
ocrpt_query_navigate_start(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="gonextrow">
				<title><literal>Navigate to the next query row</literal></title>
				<para>
					Navigate the query (or query set) to the next row. Returns
					<literal>false</literal> if there was no more rows.
					in which case the <literal>ocrpt_query_result</literal>
					arrays for all queries in the query set (returned by
					previous <literal>ocrpt_query_get_result()</literal>
					calls contain invalid data.
					<programlisting>bool
ocrpt_query_navigate_next(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="useprevnextrow">
				<title><literal>Navigate use previous/next row</literal></title>
				<para>
					These functions expose an implementation
					detail of the data traversal in OpenCReports.
					There is a 3-row data cache in which there is
					always the current row. One past row is kept
					so e.g. break boundaries can be detected and
					there is one row read-ahead to detect the
					end-of-data condition early. These functions
					allow to switch back and forth in the 3-row
					data cache, making the previous or next row the
					"current" one momentarily. The query must always
					be the primary query of the report. Used by
					unit tests that don't use
					<literal>ocrpt_execute()</literal>.
					<programlisting>void
ocrpt_query_navigate_use_prev_row(ocrpt_query *q);

void
ocrpt_query_navigate_use_next_row(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="arraydiscoveryfunc" xreflabel="Array discovery function">
				<title><literal>API specific data discovery function</literal></title>
				<para>
					For direct (application internal) data based data sources
					and queries, OpenCReports needs a way to to find the data
					pointer and the supplementary type identifier array.
					These are language specific. The below ones
					are the C specific ones. An override function
					is also provided to set a new discovery function.
					The discovery function <emphasis>should</emphasis>
					return the dimensions for both the (usuall 2D array)
					<literal>data</literal> and the 1D
					<literal>types</literal> array.
					It also returns whether <literal>types</literal>
					must be freed by the caller.
					<programlisting>typedef void
(*ocrpt_query_discover_func)(const char *,
                             void **,
                             int32_t *,
                             int32_t *,
                             const char *,
                             void **,
                             int32_t *,
                             bool *);

void
ocrpt_query_set_discover_func(ocrpt_query_discover_func func);

extern ocrpt_query_discover_func ocrpt_query_discover_array;

void
ocrpt_query_discover_array_c(const char *arrayname,
                             void **array,
                             int32_t *rows,
                             int32_t *cols,
                             const char *typesname,
                             void **types,
                             int32_t *types_cols,
                             bool *free_types);</programlisting>
				</para>
				<para>
					Note that the C specific generic discovery function
					does not and cannot return the array dimensions,
					since there is no official API related to
					<literal>dlsym()</literal> that would return
					the size associated with a symbol.
					It's up to the application writers to come up
					with a smarter (application specific) discovery
					function that also returns the array dimensions.
					With such a smart discovery function, one can specify
					the array and the column types array name without
					the related dimensions, i.e. the <literal>rows</literal>
					and <literal>cols</literal> specifiers in
					<xref linkend="xmlarrayqueries"/> and
					<xref linkend="xmlfilequeries"/>.
				</para>
			</sect3>
		</sect2>
		<sect2 id="exprfunc" xreflabel="Expression related functions">
			<title>Expression related functions</title>
			<para>
				Expressions in OpenCReports is explained in the
				<xref linkend="expressions"/> chapter.
			</para>
			<sect3 id="parseexpr">
				<title>Parse an expression string</title>
				<para>
					This function parses an expression string and
					creates an expression tree. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					<programlisting>ocrpt_expr *
ocrpt_expr_parse(opencreport *o,
                 const char *expr_string,
                 char **err);</programlisting>
				</para>
				<para>
					The returned pointer must be freed with
					<literal>ocrpt_expr_free()</literal>.
				</para>
			</sect3>
			<sect3 id="parsereportexpr">
				<title>Parse an expression string and bind it to a report</title>
				<para>
					This function parses an expression string,
					creates an expression tree and binds it to
					a report. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					<programlisting>ocrpt_expr *
ocrpt_report_expr_parse(ocrpt_report *r,
                        const char *expr_string,
                        char **err);</programlisting>
				</para>
				<para>
					The returned pointer is automatically freed by
					<literal>ocrpt_free()</literal>
				</para>
			</sect3>
			<sect3 id="freeexpr">
				<title>Free an expression parse tree</title>
				<para>
					Free an expression parse tree. If it was bound
					to the passed-in <literal>ocrpt_report</literal>,
					this association is also deleted. Alternatively,
					the expression doesn't need to be freed if it was
					bound to a report when it was parsed, as it will be
					automatically freed when freeing either the report,
					or the global <literal>opencreport</literal> structure.
					<programlisting>void
ocrpt_expr_free(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="exprgetstring">
				<title>Get the original expression string</title>
				<para>
					Get the original expression string from an
					expression parse tree.
					<programlisting>const char *
ocrpt_expr_get_expr_string(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="resolveexpr">
				<title>Resolve expression references</title>
				<para>
					This function resolves variable (identifier)
					references in the expression. This is needed
					to bind query columns to expressions that
					use them.
					<programlisting>void
ocrpt_expr_resolve(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="optimizeexpr">
				<title>Optimize an expression</title>
				<para>
					This function optimizes an expression so
					it may needs fewer computation steps during
					report execution.
					<programlisting>void
ocrpt_expr_optimize(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="evalexpr">
				<title>Evaluate an expression</title>
				<para>
					This function evaluates the expression.
					It returns the expression's
					<literal>ocrpt_result</literal> result structure.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>
				</para>
				<para>
					For expressions with query column references,
					this function must be called after
					<literal>ocrpt_query_navigate_next</literal>
					otherwise the result is not valid.
					<programlisting>ocrpt_result *
ocrpt_expr_eval(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="getexprresultwnoeval">
				<title>Get expression result without evaluation</title>
				<para>
					This function returns the expression result
					if it was already evaluated.
					The result <emphasis>must not</emphasis> be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>.
					Used by unit tests.
					<programlisting>ocrpt_result *
ocrpt_expr_get_result(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="printexpr">
				<title>Print an expression tree</title>
				<para>
					Print an expression tree in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_print(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="printexprwresult">
				<title>Print an expression tree with subexpressions and their results</title>
				<para>
					Print an expression tree with subexpressions
					and their results in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_result_deep_print(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="exprnodesnum">
				<title>Count the number of expression nodes</title>
				<para>
					This function returns the number of expression nodes.
					Used by unit tests to validate optimizazion.
					<programlisting>int32_t
ocrpt_expr_nodes(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="initexprtype">
				<title>Initialize expression result type</title>
				<para>
					OpenCReports keeps track of the last three query
					rows and computes three result values for expressions
					for internal reasons. These functions initialize
					the type for either the current result or all results
					of the expression.
					<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

bool ocrpt_expr_init_result(ocrpt_expr *e,
                            enum ocrpt_result_type type);

void ocrpt_expr_init_results(ocrpt_expr *e,
                             enum ocrpt_result_type type);</programlisting>
				</para>
			</sect3>
			<sect3 id="seterror">
				<title>Set an error string as expression result</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_expr_make_error_result(ocrpt_expr *e,
                             const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3 id="setstartflag">
				<title>Set start value flag for an iterative expression</title>
				<para>
					Set whether the iterative expression's first
					value is computed from its base expression
					or from its result expression.
					<programlisting>void
ocrpt_expr_set_iterative_start_value(ocrpt_expr *e,
                                     bool start_with_init);</programlisting>
				</para>
			</sect3>
			<sect3 id="getexprcurval">
				<title>Get current value of an expression in base type</title>
				<para>
					Get the current value of an expression in a C base
					type. Used by parsing report description XML files
					and unit tests.
					<programlisting>const char *
ocrpt_expr_get_string(ocrpt_expr *e);

long
ocrpt_expr_get_long(ocrpt_expr *e);

double
ocrpt_expr_get_double(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="setexprcurval">
				<title>Set current value of an expression in a base type</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_expr_set_string(ocrpt_expr *e,
                            const char *s);

void
ocrpt_expr_set_long(ocrpt_expr *e,
                          long l);

void
ocrpt_expr_set_double(ocrpt_expr *e,
                            double d);</programlisting>
				</para>
			</sect3>
			<sect3 id="setnthexprvalue">
				<title>Set nth value of an expression in a base type</title>
				<para>
					Expressions use <literal>OCRPT_EXPR_RESULTS</literal>
					number of values. With these functions, any of them
					can be set. Used by unit tests.
					<programlisting>void
ocrpt_expr_set_nth_result_string(ocrpt_expr *e,
                                       int which,
                                       const char *s);

void
ocrpt_expr_set_nth_result_long(ocrpt_expr *e,
                                     int which,
                                     long l);

void
ocrpt_expr_set_nth_result_double(ocrpt_expr *e,
                                       int which,
                                       double d);</programlisting>
				</para>
			</sect3>
			<sect3 id="cmpexprvalues">
				<title>Compare the current of an expression with its previous value</title>
				<para>
					Compare the current value of an expression with its
					previous value and return <literal>true</literal>
					if they are equal. It's used to implement
					<xref linkend="breaks"/>.
					<programlisting>bool
ocrpt_expr_cmp_results(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="setexprdelayed">
				<title>Set delayed flag of an expression</title>
				<para>
					<programlisting>void
ocrpt_expr_set_delayed(ocrpt_expr *e,
                       bool delayed);</programlisting>
				</para>
			</sect3>
			<sect3 id="setexprfieldexprref">
				<title>Set field expression reference for an expression</title>
				<para>
					If <literal>e</literal> contains <literal>r.value</literal>,
					the expression <literal>rvalue</literal> will be used to
					resolve this reference.
					<programlisting>void
ocrpt_expr_set_field_expr(ocrpt_expr *e,
                          ocrpt_expr *rvalue);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="resultfuncs">
			<title>Column data or expression result related functions</title>
			<para>
				The internal type <literal>ocrpt_result</literal> holds
				values either for query columns or expression results.
			</para>
			<sect3 id="createexprresult">
				<title>Create an expression result</title>
				<para>
					The returned pointer must be freed with
					<literal>ocrpt_result_free()</literal>.
					<programlisting>ocrpt_result *
ocrpt_result_new(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="getexprresulttype">
				<title>Get expression result type</title>
				<para>
					<programlisting>enum ocrpt_result_type
ocrpt_result_get_type(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="copyexprresult">
				<title>Copy an expression result</title>
				<para>
					Copy expression result from source to
					destination. Both results must have been
					created for the same
					<literal>opencreport</literal> structure,
					either explicitly with <literal>ocrpt_result_new()</literal>
					or implicitly with an expression parsed for
					this <literal>opencreport</literal> structure
					or a report structure owned by it.
					<programlisting>void
ocrpt_result_copy(ocrpt_result *dst,
                  ocrpt_result *src);</programlisting>
				</para>
			</sect3>
			<sect3 id="printexprresult">
				<title>Print an expression result</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_result_print(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="freeexprresult">
				<title>Free an expression result</title>
				<para>
					<programlisting>void
ocrpt_result_free(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisnull">
				<title>Detect whether a column result is NULL</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is NULL.
					<programlisting>bool
ocrpt_result_isnull(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisnumeric">
				<title>Detect whether a column result is numeric</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is numeric.
					<programlisting>bool
ocrpt_result_isnumber(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="getresultnumericvalue">
				<title>Get the numeric value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the numeric column value. It returns  NULL
					if the column is:
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a numeric result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>mpfr_ptr
ocrpt_result_get_number(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisstring">
				<title>Detect whether a column result is string</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is string.
					<programlisting>bool
ocrpt_result_isstring(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="getresultstringvalue">
				<title>Get the string value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the string column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a string result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>ocrpt_string *
ocrpt_result_get_string(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisdatetime">
				<title>Detect whether a column result is datetime</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is datetime.
					<programlisting>bool
ocrpt_result_isdatetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="getresultdatetimevalue">
				<title>Get the datetime value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the datetime column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a datetime result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>const struct tm *
ocrpt_result_get_datetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisinterval">
				<title>Detect whether a datetime column result is interval</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value is interval.
					<programlisting>bool
ocrpt_result_datetime_is_interval(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resulthasvaliddate">
				<title>Detect whether a datetime column result has valid date</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid date.
					<programlisting>bool
ocrpt_result_datetime_is_date_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resulthasvalidtime">
				<title>Detect whether a datetime column result has valid time</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid time.
					<programlisting>bool
ocrpt_result_datetime_is_time_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="uservarrelatedfuncs">
			<title>Variable related functions</title>
			<para>
				Variables can be created for a report using
				the API.
			</para>
			<sect3 id="createbasicuservar">
				<title>Create a basic variable</title>
				<para>
					Using this function, any variable type except
					<literal>OCRPT_VARIABLE_CUSTOM</literal>
					may be created. For a custom variable,
					see the next function.
					<programlisting>enum ocrpt_var_type {
    OCRPT_VARIABLE_INVALID,
    OCRPT_VARIABLE_EXPRESSION,
    OCRPT_VARIABLE_COUNT,
    OCRPT_VARIABLE_COUNTALL,
    OCRPT_VARIABLE_SUM,
    OCRPT_VARIABLE_AVERAGE,
    OCRPT_VARIABLE_AVERAGEALL,
    OCRPT_VARIABLE_LOWEST,
    OCRPT_VARIABLE_HIGHEST,
    OCRPT_VARIABLE_CUSTOM
};
typedef enum ocrpt_var_type ocrpt_var_type;

ocrpt_var *
ocrpt_variable_new(ocrpt_report *r,
                   ocrpt_var_type type,
                   const char *name,
                   const char *expr,
                   const char *ignoreexpr,
                   const char *reset_on_break_name,
                   bool precalculate);</programlisting>
				</para>
			</sect3>
			<sect3 id="createcustomuservar">
				<title>Create a custom variable</title>
				<para>
					Create a custom variable of the specified type
					with the specified subexpressions.
					<programlisting>ocrpt_var *
ocrpt_variable_new_full(ocrpt_report *r,
                        enum ocrpt_result_type type,
                        const char *name,
                        const char *baseexpr,
                        const char *ignoreexpr,
                        const char *intermedexpr,
                        const char *intermed2expr,
                        const char *resultexpr,
                        const char *reset_on_break_name,
                        bool precalculate);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservargettype">
				<title>Get the variable type</title>
				<para>
					Get the type of the variable.
					<programlisting>ocrpt_var_type
ocrpt_variable_get_type(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservargetsubexprs">
				<title>Get subexpressions of a variable</title>
				<para>
					Get subexpressions of a previously created
					basic or custom variable.
					<programlisting>ocrpt_expr *
ocrpt_variable_baseexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_ignoreexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermedexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermed2expr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_resultexpr(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservargetprecalc">
				<title>Get precalculate flag for a variable</title>
				<para>
					<programlisting>bool
ocrpt_variable_get_precalculate(ocrpt_var *var);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservarresolve">
				<title>Resolve a variable</title>
				<para>
					Resolve subexpressions of a variable
					so it can be evaluated correctly.
					<programlisting>void
ocrpt_variable_resolve(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservareval">
				<title>Evaluate a variable</title>
				<para>
					After evaluation, the result is in the
					expression returned by
					<literal>ocrpt_variable_resultexpr()</literal>.
					<programlisting>void
ocrpt_variable_evaluate(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservariter">
				<title>Iterate over variables of a report</title>
				<para>
					Iterate over variables of a report. The first call
					needs the iterator list pointer to be set to NULL.
					<programlisting>ocrpt_var *
ocrpt_variable_get_next(ocrpt_report *r,
                     ocrpt_list **list);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="breakrelatedfuncs">
			<title>Break related functions</title>
			<sect3 id="createbreak">
				<title>Create a break</title>
				<para>
					Create a break. No need to free it,
					<literal>ocrpt_free()</literal> does it.
					<programlisting>ocrpt_break *
ocrpt_break_new(ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakattfuncs">
				<title>Set attribute flag expressions for a break</title>
				<para>
					Set break attributes from expression strings
					for <literal>headernewpage</literal> and
					<literal>suppressblank</literal>.
					There is a 3rd flag accepted in the report
					XML DTD called <literal>newpage</literal>
					which is not represented (ignored) in the API,
					because it's also ignored in RLIB and is only
					handled for RLIB compatibility.
					<programlisting>void
ocrpt_break_set_headernewpage(ocrpt_break *br,
                              const char *headernewpage);

void
ocrpt_break_set_suppressblank(ocrpt_break *br,
                              const char *suppressblank);</programlisting>
				</para>
				<para>
					<literal>headernewpage="yes"</literal> instructs the
					layout to render <literal>&lt;BreakHeader&gt;</literal>
					on a new page.
				</para>
				<para>
					<literal>suppressblank="yes"</literal> instructs the
					layout to suppress <literal>&lt;BreakHeader&gt;</literal>
					if any of the <literal>&lt;BreakField&gt;</literal>s
					are <literal>NULL</literal> value or an empty string,
					if the break field is of the string type.
				</para>
			</sect3>
			<sect3 id="breakgetbyname">
				<title>Get break using its name</title>
				<para>
					Get the pointer to the break using its name.
					<programlisting>ocrpt_break *
ocrpt_break_get(ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakgetname">
				<title>Get the name of a break</title>
				<para>
					Get the name of the break using its structure
					pointer.
					<programlisting>const char *
ocrpt_break_get_name(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakaddbreakfield">
				<title>Add a watched expression to a break</title>
				<para>
					<programlisting>bool
ocrpt_break_add_breakfield(ocrpt_break *br,
                           ocrpt_expr *bf);</programlisting>
				</para>
			</sect3>
			<sect3 id="iteratebreaks">
				<title>Iterate over breaks of a report</title>
				<para>
					Iterate over breaks of a report. The first call
					needs the iterator list pointer to be set to NULL.
					<programlisting>ocrpt_break *
ocrpt_break_get_next(ocrpt_report *r,
                     ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakresolveandopt">
				<title>Resolve and optimize break fields</title>
				<para>
					<programlisting>void
ocrpt_break_resolve_fields(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakchecktrigger">
				<title>Check whether the break triggers</title>
				<para>
					<programlisting>bool
ocrpt_break_check_fields(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakcheckblank">
				<title>Check whether break field values are blank</title>
				<para>
					The second parameter <literal>evaluate</literal>
					allows skipping evaluating the breakfield values.
					(This is an optimization in case it's executed after
					<literal>ocrpt_break_check_fields()</literal> which
					already evaluated the breakfields.)
					<programlisting>bool
ocrpt_break_check_blank(ocrpt_break *br,
                        bool evaluate);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakresetvars">
				<title>Reset variables for the break</title>
				<para>
					<programlisting>void
ocrpt_break_reset_vars(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="userfuncfuncs">
			<title>Function related functions</title>
			<sect3 id="adduserfunc">
				<title>Add a user defined function</title>
				<para>
					Add a user defined function by specifying
					the name, the function pointer that contains
					the implementation, the number of operands
					(0 or greater for fixed number or operands,
					-1 is varying number of operands) and
					the function mathematical properties
					that help optimizing it.
					<programlisting>bool
ocrpt_function_add(opencreport *o,
                   const char *fname,
                   ocrpt_function_call func,
                   void *user_data,
                   int32_t n_ops,
                   bool commutative,
                   bool associative,
                   bool left_associative,
                   bool dont_optimize);</programlisting>
				</para>
				<para>
					Adding a user defined function with
					a name of a pre-existing function will
					override it.
				</para>
				<para>
					OpenCReports functions are called with the
					parameters as declared below.
					<programlisting>#define OCRPT_FUNCTION_PARAMS \
    ocrpt_expr *e, void *user_data</programlisting>
				</para>
				<para>
					OpenCReports functions may be declared
					with these convenience symbols below.
					<programlisting>#define OCRPT_FUNCTION(name) \
    void name(OCRPT_FUNCTION_PARAMS)

#define OCRPT_STATIC_FUNCTION(name) \
    static void name(OCRPT_FUNCTION_PARAMS)</programlisting>
				</para>
				<para>
					The above function
					(<literal>ocrpt_function_add()</literal>)
					is called with a function pointer which has
					this type:
					<programlisting>typedef void
(*ocrpt_function_call)(OCRPT_FUNCTION_PARAMS);</programlisting>
				</para>
			</sect3>
			<sect3 id="findfunc">
				<title>Find a named function</title>
				<para>
					<programlisting>const ocrpt_function *
ocrpt_function_get(opencreport *o,
                   const char *fname);</programlisting>
				</para>
			</sect3>
			<sect3 id="exprgetops">
				<title>Get number of operands for an expression (function)</title>
				<para>
					In an expression tree, functions
					are represented as subexpressions with
					operands. This call may be used by OpenCReports
					functions to inspect whether the number of
					operands is in the expected range.
					<programlisting>int32_t
ocrpt_expr_get_num_operands(ocrpt_expr *e);
</programlisting>
				</para>
			</sect3>
			<sect3 id="expropgetvalue">
				<title>Get current value of a function operand</title>
				<para>
					This function is used by OpenCReports functions
					internally to compute the result from its
					operands.
					<programlisting>ocrpt_result *
ocrpt_expr_operand_get_result(ocrpt_expr *e,
                              int32_t opnum);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="partandreportfuncs">
			<title>Report part and report related functions</title>
			<sect3 id="createpart">
				<title>Create a report part</title>
				<para>
					<programlisting>ocrpt_part *
ocrpt_part_new(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="createpartrow">
				<title>Create a row in a report part</title>
				<para>
					<programlisting>ocrpt_part_row *
ocrpt_part_new_row(ocrpt_part *p);</programlisting>
				</para>
			</sect3>
			<sect3 id="createpartcol">
				<title>Create a column in report part row</title>
				<para>
					<programlisting>ocrpt_part_column *
ocrpt_part_row_new_column(ocrpt_part_row *pr);</programlisting>
				</para>
			</sect3>
			<sect3 id="createpartreport">
				<title>Create a new report in a part column</title>
				<para>
					<programlisting>ocrpt_report *
ocrpt_part_column_new_report(ocrpt_part_column *pd);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportiterators">
				<title>Report part related iterators</title>
				<para>
					Iterators for getting report parts, part rows,
					columns in rows and reports in columns.
					Every iterator function must be called
					the first time with the list pointer set to NULL.
					<programlisting>ocrpt_part *
ocrpt_part_get_next(opencreport *o,
                    ocrpt_list **list);

ocrpt_part_row *
ocrpt_part_row_get_next(ocrpt_part *p,
                        ocrpt_list **list);

ocrpt_part_column *
ocrpt_part_column_get_next(ocrpt_part_row *pr,
                           ocrpt_list **list);

ocrpt_report *
ocrpt_report_get_next(ocrpt_part_column *pd,
                      ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportsetmainquery">
				<title>Set the main query for a report</title>
				<para>
					Set the main query for a report either by
					the query structure pointer, or from expression.
					The expression must resolve to a string value,
					with fallback to a plain string.
					<programlisting>void
ocrpt_report_set_main_query(ocrpt_report *r,
                            const ocrpt_query *query);

void
ocrpt_report_set_main_query_from_expr(ocrpt_report *r,
                                    const char *expr_string);</programlisting>
				</para>
				<para>
					See <xref linkend="reportqueryname"/>.
					Unlike with the XML description, where the first
					globally declared query is used for the report
					if its main query is not set, the default via
					the low level API is unset.
				</para>
			</sect3>
			<sect3 id="reportgetcurrentrownum">
				<title>Get the current row number of the main query</title>
				<para>
					The row number starts from 1.
					<programlisting>long
ocrpt_report_get_query_rownum(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportresolvevars">
				<title>Resolve all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_variables(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportevalvars">
				<title>Evaluate all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_variables(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportresolvebreaks">
				<title>Resolve all report breaks</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_breaks(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportresolveexprs">
				<title>Resolve all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_expressions(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportevalexprs">
				<title>Evaluate all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_expressions(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="layoutfuncs">
			<title>Layout related functions</title>
			<sect3 id="layoutglobalopts">
				<title>Global layout options</title>
				<sect4 id="layoutsizeunit">
					<title>Set or get "size unit" option</title>
					<para>
						See <xref linkend="sizeunit"/>.
						The expression string must evaluate to
						a string value, where <literal>points</literal>
						will set the layout rendering to use
						<emphasis>points</emphasis> for size units.
						Any other value will make the layout rendering
						use the convoluted RLIB compatible size units,
						mostly based on font sizes.
						<programlisting>ocrpt_expr *
ocrpt_set_size_unit(opencreport *o,
                    const char *expr_string);</programlisting>
					</para>
					<para>
						The expression also has a getter function,
						so its result (value) can be queried.
						Which may be useful, in case it's set in
						the report XML description and callbacks
						and the report processing needs to inspect it.
						<programlisting>ocrpt_expr *
ocrpt_get_size_unit(opencreport *o);</programlisting>
					</para>
				</sect4>
				<sect4 id="layoutnqsnd">
					<title>Set or get "no query show NoData" option</title>
					<para>
						See <xref linkend="noqueryshownodata"/>.
						The expression string should evaluate to
						a boolean value.
						<programlisting>ocrpt_expr *
ocrpt_set_noquery_show_nodata(opencreport *o,
                              const char *expr_string);

ocrpt_expr *
ocrpt_get_noquery_show_nodata(opencreport *o);</programlisting>
					</para>
				</sect4>
				<sect4 id="layoutrhal">
					<title>Set or get "report height after last" option</title>
					<para>
						See <xref linkend="reportheightafterlast"/>.
						The expression string should evaluate to
						a boolean value.
						<programlisting>ocrpt_expr *
ocrpt_set_report_height_after_last(opencreport *o,
                                   const char *expr_string);

ocrpt_expr *
ocrpt_get_report_height_after_last(opencreport *o);</programlisting>
					</para>
				</sect4>
				<sect4 id="followermatchsingle">
					<title>Set "follower match single" option</title>
					<para>
						See <xref linkend="xmlfollowermatchsingle"/>.
						The expression string should evaluate to
						a boolean value.
						<programlisting>ocrpt_expr *
ocrpt_set_follower_match_single(opencreport *o,
                                const char *expr_string);

ocrpt_expr *
ocrpt_get_follower_match_single(opencreport *o);</programlisting>
					</para>
				</sect4>
				<sect4 id="followermatchsingledirect">
					<title>Set or get "follower match single" option directly</title>
					<para>
						See above and <xref linkend="xmlfollowermatchsingle"/>.
						The  difference is that the modified behaviour
						is set directly and immediately. Used by unit tests.
						<programlisting>void
ocrpt_set_follower_match_single_direct(opencreport *o,
                                       bool value);

bool
ocrpt_get_follower_match_single_direct(opencreport *o);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partopts">
				<title>Report part options</title>
				<sect4 id="setpartiter">
					<title>Set or get part iterations</title>
					<para>
						See <xref linkend="partiter"/>.
						The expression string must evaluate to
						a numeric value.
						<programlisting>ocrpt_expr *
ocrpt_part_set_iterations(ocrpt_part *p,
                          const char *expr_string);

ocrpt_expr *
ocrpt_part_get_iterations(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartfontname">
					<title>Set or get part font name</title>
					<para>
						See <xref linkend="partfontname"/>.
						<programlisting>ocrpt_expr *
ocrpt_part_set_font_name(ocrpt_part *p,
                         const char *expr_string);

ocrpt_expr *
ocrpt_part_get_font_name(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartfontsize">
					<title>Set or get part font size</title>
					<para>
						See <xref linkend="partfontsize"/>.
						<programlisting>ocrpt_expr *
ocrpt_part_set_font_size(ocrpt_part *p,
                         const char *expr_string);

ocrpt_expr *
ocrpt_part_get_font_size(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartpapertype">
					<title>Set or get part paper type</title>
					<para>
						See <xref linkend="papertype"/>.
						<programlisting>ocrpt_expr *
ocrpt_part_set_paper_type(ocrpt_part *p,
                             const char *expr_string);

ocrpt_expr *
ocrpt_part_get_paper_type(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartorientation">
					<title>Set or get part paper's orientation</title>
					<para>
						See <xref linkend="partpageorientation"/>.
						The expression string must evaluate to a string
						value, with possible options of
						<literal>portrait</literal> and
						<literal>landscape</literal>. By default,
						the part uses <literal>portrait</literal>
						orientation.
						<programlisting>ocrpt_expr *
ocrpt_part_set_orientation(ocrpt_part *p,
                           const char *expr_string);

ocrpt_expr *
ocrpt_part_get_orientation(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
				<sect4 id="partsetmargins">
					<title>Set or get part margins</title>
					<para>
						See <xref linkend="marginsettings"/>.
						The margin values must be passed in via strings
						as they can be expressions.
						<programlisting>ocrpt_expr *
ocrpt_part_set_top_margin(ocrpt_part *p,
                          const char *expr_string);

ocrpt_expr *
ocrpt_part_get_top_margin(ocrpt_part *p);

ocrpt_expr *
ocrpt_part_set_bottom_margin(ocrpt_part *p,
                             const char *expr_string);

ocrpt_expr *
ocrpt_part_get_bottom_margin(ocrpt_part *p);

ocrpt_expr *
ocrpt_part_set_left_margin(ocrpt_part *p,
                           const char *expr_string);

ocrpt_expr *
ocrpt_part_get_left_margin(ocrpt_part *p);

ocrpt_expr *
ocrpt_part_set_right_margin(ocrpt_part *p,
                            const char *expr_string);

ocrpt_expr *
ocrpt_part_get_right_margin(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
				<sect4 id="partsetsuppress">
					<title>Set or get part suppression</title>
					<para>
						See <xref linkend="partsuppress"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>ocrpt_expr *
ocrpt_part_set_suppress(ocrpt_part *p,
                        const char *expr_string);

ocrpt_expr *
ocrpt_part_get_suppress(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
				<sect4 id="partsetphsfp">
					<title>Set or get part's page header suppressed on the first page</title>
					<para>
						See <xref linkend="suppresspageheaderfirstpage"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>ocrpt_expr *
ocrpt_part_set_suppress_pageheader_firstpage(ocrpt_part *p,
                                             const char *expr_string);

ocrpt_expr *
ocrpt_part_get_suppress_pageheader_firstpage(ocrpt_part *p);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partrowopts">
				<title>Part row options</title>
				<sect4 id="partrowsetsuppress">
					<title>Set or get part row suppression</title>
					<para>
						See <xref linkend="partrowsuppress"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>ocrpt_expr *
ocrpt_part_row_set_suppress(ocrpt_part_row *pr,
                            const char *expr_string);

ocrpt_expr *
ocrpt_part_row_get_suppress(ocrpt_part_row *pr);</programlisting>
					</para>
				</sect4>
				<sect4 id="partrowsetnewpage">
					<title>Set or get part row new page</title>
					<para>
						See <xref linkend="partrownewpage"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>ocrpt_expr *
ocrpt_part_row_set_newpage(ocrpt_part_row *pr,
                           const char *expr_string);

ocrpt_expr *
ocrpt_part_row_get_newpage(ocrpt_part_row *pr);</programlisting>
					</para>
				</sect4>
				<sect4 id="partrowsetlayout">
					<title>Set or get part row layout mode</title>
					<para>
						See <xref linkend="partrowlayout"/>.
						The expression string must evaluate
						to a string value, with possible options
						<literal>flow</literal> and
						<literal>fixed</literal>. This setting
						is ignored, it's only accepted for RLIB
						compatibility.
						<programlisting>ocrpt_expr *
ocrpt_part_row_set_layout(ocrpt_part_row *pr,
                          const char *expr_string);

ocrpt_expr *
ocrpt_part_row_get_layout(ocrpt_part_row *pr);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partcolopts">
				<title>Part column options</title>
				<sect4 id="partcolsetsuppress">
					<title>Set or get part column suppression</title>
					<para>
						See <xref linkend="partcolsuppress"/>.
						The expression must evaluate to a numeric
						(boolean) value.
						<programlisting>ocrpt_expr *
ocrpt_part_column_set_suppress(ocrpt_part_column *pd,
                               const char *expr_string);

ocrpt_expr *
ocrpt_part_column_get_suppress(ocrpt_part_column *pd);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetwidth">
					<title>Set or get part column width</title>
					<para>
						See <xref linkend="partcolwidth"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_part_column_set_width(ocrpt_part_column *pd,
                            const char *expr_string);

ocrpt_expr *
ocrpt_part_column_get_width(ocrpt_part_column *pd);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetheight">
					<title>Set or get part column height</title>
					<para>
						See <xref linkend="partcolheight"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_part_column_set_height(ocrpt_part_column *pd,
                             const char *expr_string);

ocrpt_expr *
ocrpt_part_column_get_height(ocrpt_part_column *pd);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetborderwidth">
					<title>Set or get part column border width</title>
					<para>
						See <xref linkend="pdborderwidth"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_part_column_set_border_width(ocrpt_part_column *pd,
                                   const char *expr_string);

ocrpt_expr *
ocrpt_part_column_get_border_width(ocrpt_part_column *pd);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetbordercolor">
					<title>Set or get part column border color</title>
					<para>
						See <xref linkend="pdbordercolor"/>.
						The expression must evaluate to a string
						value with a valid color name or specification.
						<programlisting>ocrpt_expr *
ocrpt_part_column_set_border_color(ocrpt_part_column *pd,
                                   const char *expr_string);

ocrpt_expr *
ocrpt_part_column_get_border_color(ocrpt_part_column *pd);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetcolumns">
					<title>Set or get part column's number of detail columns</title>
					<para>
						See <xref linkend="detailcolumns"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_part_column_set_detail_columns(ocrpt_part_column *pd,
                                     const char *expr_string);

ocrpt_expr *
ocrpt_part_column_get_detail_columns(ocrpt_part_column *pd);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetpadding">
					<title>Set or get part column's detail column padding</title>
					<para>
						See <xref linkend="columnpadding"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_part_column_set_column_padding(ocrpt_part_column *pd,
                                     const char *expr_string);

ocrpt_expr *
ocrpt_part_column_get_column_padding(ocrpt_part_column *pd);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="reportsopts">
				<title>Report options</title>
				<sect4 id="reportsetsuppress">
					<title>Set or get report suppression</title>
					<para>
						See <xref linkend="reportsuppress"/>.
						The expression must evaluate to a numeric
						(boolean) value.
						<programlisting>ocrpt_expr *
ocrpt_report_set_suppress(ocrpt_report *r,
                          const char *expr_string);

ocrpt_expr *
ocrpt_report_get_suppress(ocrpt_report *r);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetiteration">
					<title>Set or get report iterations</title>
					<para>
						See <xref linkend="reportiter"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_report_set_iterations(ocrpt_report *r,
                            const char *expr_string);

ocrpt_expr *
ocrpt_report_get_iterations(ocrpt_report *r);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetfontname">
					<title>Set or get report font name</title>
					<para>
						See <xref linkend="reportfontname"/>.
						The expression must evaluate to a string
						value, with fallback to plain string:
						in case of a parsing error, the value
						string is taken as is.
						<programlisting>ocrpt_expr *
ocrpt_report_set_font_name(ocrpt_report *r,
                           const char *expr_string);

ocrpt_expr *
ocrpt_report_get_font_name(ocrpt_report *r);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetfontsize">
					<title>Set or get report font size</title>
					<para>
						See <xref linkend="reportfontsize"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_report_set_font_size(ocrpt_report *r,
                           const char *expr_string);

ocrpt_expr *
ocrpt_report_get_font_size(ocrpt_report *r);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetheight">
					<title>Set or get report height</title>
					<para>
						See <xref linkend="reportheight"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>ocrpt_expr *
ocrpt_report_set_height(ocrpt_report *r,
                        const char *expr_string);

ocrpt_expr *
ocrpt_report_get_height(ocrpt_report *r);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetfhprio">
					<title>Set or get report's field header priority</title>
					<para>
						See <xref linkend="reportfhpriority"/>.
						The expression must evaluate to a string
						value with the options of <literal>high</literal>
						and <literal>low</literal>. Default is
						<literal>low</literal>.
						<programlisting>ocrpt_expr *
ocrpt_report_set_fieldheader_priority(ocrpt_report *r,
                                      const char *expr_string);

ocrpt_expr *
ocrpt_report_get_fieldheader_priority(ocrpt_report *r);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partgetlayoutsections">
				<title>Get part layout sections</title>
				<para>
					Get the part's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;PageHeader&gt;</literal>
					or <literal>&lt;PageFooter&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_layout_part_page_header(ocrpt_part *p);

ocrpt_output *
ocrpt_layout_part_page_footer(ocrpt_part *p);</programlisting>
				</para>
			</sect3>
			<sect3 id="partlayoutsetreport">
				<title>Set report for part layout sections</title>
				<para>
					Set the report pointer for the part's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;PageHeader&gt;</literal>
					or <literal>&lt;PageFooter&gt;</literal>.
					<programlisting>void
ocrpt_layout_part_page_header_set_report(ocrpt_part *p,
                                         ocrpt_report *r);

void
ocrpt_layout_part_page_footer_set_report(ocrpt_part *p,
                                         ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportgetlayoutsections">
				<title>Get report layout sections</title>
				<para>
					Get the report's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;NoData&gt;</literal>,
					<literal>&lt;ReportHeader&gt;</literal>,
					<literal>&lt;ReportFooter&gt;</literal>,
					<literal>&lt;FieldHeaders&gt;</literal> or
					<literal>&lt;FieldDetails&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_layout_report_nodata(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_header(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_footer(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_field_header(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_field_details(ocrpt_report *r);</programlisting>
				</para>
				<sect4 id="reportlayoutiterator">
					<title>Miscellaneous report layout and line element functions</title>
					<para>
						It is possible to load a report XML descriptor and
						modify the layout contents defined by it using code.
					</para>
					<para>
						The first iterator function loops through toplevel
						output elements: line, horizontal line, image, barcode.
						An abstract opaque pointer type is returned by the
						iterator. Further boolean functions determine the
						actual element type. The <literal>void **iter</literal>
						pointer must point to a <literal>NULL</literal>
						pointer initially and the iterator function returns
						<literal>NULL</literal> when there are no more
						elements in the output section. Depending on the
						boolean function results, the abstract opaque
						pointer type can be case to the actual output
						element type: <literal>ocrpt_line *</literal>,
						<literal>ocrpt_hline *</literal>,
						<literal>ocrpt_image *</literal> or
						<literal>ocrpt_barcode *</literal>.
						<programlisting>struct ocrpt_output_element;
typedef struct ocrpt_output_element ocrpt_output_element;

ocrpt_output_element *
ocrpt_output_element_get_next(ocrpt_output *output, ocrpt_list **iter);

bool
ocrpt_output_element_is_line(ocrpt_output_element *elem);

bool
ocrpt_output_element_is_hline(ocrpt_output_element *elem);

bool
ocrpt_output_element_is_image(ocrpt_output_element *elem);

bool
ocrpt_output_element_is_barcode(ocrpt_output_element *elem);</programlisting>
					</para>
					<para>
						The second iterator function loops through line
						elements: text, image and barcode.
						An abstract opaque pointer type is returned by the
						iterator. Further boolean functions determine the
						actual element type. The <literal>void **iter</literal>
						pointer must point to a <literal>NULL</literal>
						pointer initially and the iterator function returns
						<literal>NULL</literal> when there are no more
						elements in the output section. Depending on the
						boolean function results, the abstract opaque
						pointer type can be cast to the actual output
						element type: <literal>ocrpt_text *</literal>,
						<literal>ocrpt_image *</literal> or
						<literal>ocrpt_barcode *</literal>.
						<programlisting>struct ocrpt_line_element;
typedef struct ocrpt_line_element ocrpt_line_element;

ocrpt_line_element *
ocrpt_line_element_get_next(ocrpt_line *line, void **iter);

bool
ocrpt_line_element_is_text(ocrpt_line_element *elem);

bool
ocrpt_line_element_is_image(ocrpt_line_element *elem);

bool
ocrpt_line_element_is_barcode(ocrpt_line_element *elem);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="breakgetlayoutsections">
				<title>Get break layout sections</title>
				<para>
					Get the break's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;BreakHeader&gt;</literal> or
					<literal>&lt;BreakFooter&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_break_get_header(ocrpt_break *br);

ocrpt_output *
ocrpt_break_get_footer(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="outputglobalsections">
				<title>Set output section global settings</title>
				<para>
					Note that part (page) header and footer, and report
					header and footer sections must be constant
					expressions. Other sections may depend on data derived
					from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="outputsetsuppress">
					<title>Set or get output section suppression</title>
					<para>
						Set suppression from an expression string.
						<programlisting>ocrpt_expr *
ocrpt_output_set_suppress(ocrpt_output *output,
                          const char *expr_string);

ocrpt_expr *
ocrpt_output_get_suppress(ocrpt_output *output);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddline">
				<title>Add a text line to an output section</title>
				<para>
					<programlisting>ocrpt_line *
ocrpt_output_add_line(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3 id="outputlinesettings">
				<title>Text line settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="linesetfontname">
					<title>Set or get line font name</title>
					<para>
						Set the text line's font name from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_line_set_font_name(ocrpt_line *line,
                         const char *expr_string);

ocrpt_expr *
ocrpt_line_get_font_name(ocrpt_line *line);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetfontsize">
					<title>Set line font size</title>
					<para>
						Set the text line's font size from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_line_set_font_size(ocrpt_line *line,
                         const char *expr_string);

ocrpt_expr *
ocrpt_line_get_font_size(ocrpt_line *line);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetbold">
					<title>Set or get line bold value</title>
					<para>
						Set the text line's bold value from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_line_set_bold(ocrpt_line *line,
                    const char *expr_string);

ocrpt_expr *
ocrpt_line_get_bold(ocrpt_line *line);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetitalic">
					<title>Set or get line italic value</title>
					<para>
						Set the text line's italic value from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_line_set_italic(ocrpt_line *line,
                      const char *expr_string);

ocrpt_expr *
ocrpt_line_get_italic(ocrpt_line *line);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetsuppress">
					<title>Set or get line suppression</title>
					<para>
						Set the text line's suppression value from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_line_set_suppress(ocrpt_line *line,
                        const char *expr_string);

ocrpt_expr *
ocrpt_line_get_suppress(ocrpt_line *line);</programlisting>
					</para>
				</sect4>
				<sect4 id="linessettextcolor">
					<title>Set or get line text color</title>
					<para>
						Set the text line's text color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_line_set_color(ocrpt_line *line,
                     const char *expr_string);

ocrpt_expr *
ocrpt_line_get_color(ocrpt_line *line);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetbgcolor">
					<title>Set or get line background color</title>
					<para>
						Set or get the text line's background color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_line_set_bgcolor(ocrpt_line *line,
                       const char *expr_string);

ocrpt_expr *
ocrpt_line_get_bgcolor(ocrpt_line *line);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="lineaddtext">
				<title>Add a text element to a text line</title>
				<para>
					<programlisting>ocrpt_text *
ocrpt_line_add_text(ocrpt_line *line);</programlisting>
				</para>
			</sect3>
			<sect3 id="textsettings">
				<title>Text element settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="textsetliteral">
					<title>Set text element literal value</title>
					<para>
						Set the text element's literal value from
						a string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_value_string(ocrpt_text *text,
                            const char *string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetvalue">
					<title>Set or get text element value</title>
					<para>
						Set the text element's value from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_value_expr(ocrpt_text *text,
                          const char *expr_string);</programlisting>
					</para>
					<para>
						The getter function for the text element's
						value also works when the text value is set
						as a literal.
						<programlisting>ocrpt_expr *
ocrpt_text_get_value(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetdelayed">
					<title>Set or get text element value's delayed property</title>
					<para>
						Set the text element value's delayed
						property from an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_value_delayed(ocrpt_text *text,
                             const char *expr_string);


ocrpt_expr *
ocrpt_text_get_value_delayed(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetformatstring">
					<title>Set or get text element format string</title>
					<para>
						Set the text element's format string from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_format(ocrpt_text *text,
                      const char *expr_string);

ocrpt_expr *
ocrpt_text_get_format(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetxlate">
					<title>Set or get text element translation</title>
					<para>
						Set the text element's translation from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_translate(ocrpt_text *text,
                         const char *expr_string);

ocrpt_expr *
ocrpt_text_get_translate(ocrpt_text *text);</programlisting>
					</para>
					<para>
						OpenCReports will attempt to translate
						both the format string and the text element's
						value.
					</para>
				</sect4>
				<sect4 id="textsetwidth">
					<title>Set or get text element field width</title>
					<para>
						Set the text element's field width from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_width(ocrpt_text *text,
                     const char *expr_string);

ocrpt_expr *
ocrpt_text_get_width(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetalignment">
					<title>Set or get text element alignment</title>
					<para>
						Set the text element's alignment from
						a string or an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_alignment(ocrpt_text *text,
                         const char *expr_string);

ocrpt_expr *
ocrpt_text_get_alignment(ocrpt_text *text);</programlisting>
					</para>
					<para>
						String values <literal>left</literal>,
						<literal>right</literal>,
						<literal>center</literal> and
						<literal>justified</literal> are
						accepted either as is, or as an expression.
					</para>
				</sect4>
				<sect4 id="textsetcolor">
					<title>Set or get text element text color</title>
					<para>
						Set the text element's text color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_color(ocrpt_text *text,
                     const char *expr_string);

ocrpt_expr *
ocrpt_text_get_color(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetbgcolor">
					<title>Set or get text element background color</title>
					<para>
						Set the text element's background color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_bgcolor(ocrpt_text *text,
                       const char *expr_string);

ocrpt_expr *
ocrpt_text_get_bgcolor(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetfontname">
					<title>Set or get text element font name</title>
					<para>
						Set the text element's font name from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_font_name(ocrpt_text *text,
                         const char *expr_string);

ocrpt_expr *
ocrpt_text_get_font_name(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetfontsize">
					<title>Set or get text element font size</title>
					<para>
						Set the text element's font size from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_font_size(ocrpt_text *text,
                         const char *expr_string);

ocrpt_expr *
ocrpt_text_get_font_size(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetbold">
					<title>Set or get text element bold value</title>
					<para>
						Set the text element's bold value from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_bold(ocrpt_text *text,
                    const char *expr_string);

ocrpt_expr *
ocrpt_text_get_bold(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetitalic">
					<title>Set or get text element italic value</title>
					<para>
						Set the text element's italic value from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_italic(ocrpt_text *text,
                      const char *expr_string);

ocrpt_expr *
ocrpt_text_get_italic(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetlink">
					<title>Set or get text element link URL</title>
					<para>
						Set the text element's link URL from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_text_set_link(ocrpt_text *text,
                    const char *expr_string);

ocrpt_expr *
ocrpt_text_get_link(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetmemo">
					<title>Set or get text element multiline property</title>
					<para>
						Set the text element's multiline property
						from an expression string. The expression
						must evaluate to a numeric (boolean) value.
						<programlisting>ocrpt_expr *
ocrpt_text_set_memo(ocrpt_text *text,
                    const char *expr_string);

ocrpt_expr *
ocrpt_text_get_memo(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetmemohyphenate">
					<title>Set or get text element "hyphenate" property</title>
					<para>
						Set the text element's "hyphenate"
						property from an expression string.
						The expression must evaluate to a numeric
						(boolean) value. This setting is only used
						for multiline fields. When set to
						<literal>false</literal>, words at the end
						of the lines in the multiline text field
						would break over to the next line as a whole.
						When set to <literal>true</literal>, the word
						will be hyphenated. Default is
						<literal>true</literal>. When character wrapping
						is in used (see below), this setting in not used.
						<programlisting>ocrpt_expr *
ocrpt_text_set_memo_hyphenate(ocrpt_text *text,
                              const char *expr_string);

ocrpt_expr *
ocrpt_text_get_memo_hyphenate(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetmemowrap">
					<title>Set or get text element "wrap at characters" property</title>
					<para>
						Set the text element's "wrap at characters"
						property from an expression string.
						The expression must evaluate to a numeric
						(boolean) value. This setting is only used
						for multiline fields. When unset or set to
						<literal>false</literal>, multiline text
						fields wrap at word boundaries.
						<programlisting>ocrpt_expr *
ocrpt_text_set_memo_wrap_chars(ocrpt_text *text,
                               const char *expr_string);

ocrpt_expr *
ocrpt_text_get_memo_wrap_chars(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetmemolines">
					<title>Set or get text element maximum lines</title>
					<para>
						Set the text element's maximum lines
						property from an expression string.
						The expression must evaluate to a numeric
						value. This setting is only used for multiline
						fields. When unset or set to <literal>0</literal>,
						the whole content of the multiline field is
						rendered. Otherwise, not more than the
						maximum lines are rendered from the multiline
						field value. The used font size, the field's width
						and word/character wrapping influence the
						number of lines the field value is rendered into.
						<programlisting>ocrpt_expr *
ocrpt_text_set_memo_max_lines(ocrpt_text *text,
                              const char *expr_string);

ocrpt_expr *
ocrpt_text_get_memo_max_lines(ocrpt_text *text);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddhline">
				<title>Add a horizontal line to an output section</title>
				<para>
					<programlisting>ocrpt_hline *
ocrpt_output_add_hline(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3 id="hlinesettings">
				<title>Horizontal line settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="hlinesetwidth">
					<title>Set or get horizontal line size (width)</title>
					<para>
						Set the horizontal line's size (width) from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_hline_set_size(ocrpt_hline *hline,
                     const char *expr_string);

ocrpt_expr *
ocrpt_hline_get_size(ocrpt_hline *hline);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetalign">
					<title>Set or get horizontal line alignment</title>
					<para>
						Set the horizontal line's alignment from
						an expression string. Possibly values are
						<literal>left</literal>,
						<literal>right</literal> and
						<literal>center</literal>. Default is
						<literal>left</literal> alignment.
						The alignment is only applied if the line
						length is shorter than the designated page
						or column width without the margins.
						<programlisting>ocrpt_expr *
ocrpt_hline_set_alignment(ocrpt_hline *hline,
                      const char *expr_string);

ocrpt_expr *
ocrpt_hline_get_alignment(ocrpt_hline *hline);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetindentation">
					<title>Set or get horizontal line indentation</title>
					<para>
						Set the horizontal line's indentation value from
						an expression string. The indentation is used if
						<literal>left</literal> alignment is set.
						<programlisting>ocrpt_expr *
ocrpt_hline_set_indentation(ocrpt_hline *hline,
                       const char *expr_string);

ocrpt_expr *
ocrpt_hline_get_indentation(ocrpt_hline *hline);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetlength">
					<title>Set or get horizontal line length</title>
					<para>
						Set the horizontal line's length from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_hline_set_length(ocrpt_hline *hline,
                       const char *expr_string);

ocrpt_expr *
ocrpt_hline_get_length(ocrpt_hline *hline);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetfontsize">
					<title>Set or get horizontal line font size</title>
					<para>
						Set the horizontal line's font size from
						an expression string. It's used in indentation
						and length calculations if <xref linkend="sizeunit"/>
						is set to <literal>rlib</literal>.
						<programlisting>ocrpt_expr *
ocrpt_hline_set_font_size(ocrpt_hline *hline,
                          const char *expr_string);

ocrpt_expr *
ocrpt_hline_get_font_size(ocrpt_hline *hline);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetsuppress">
					<title>Set or get horizontal line suppression</title>
					<para>
						Set the horizontal line's suppression from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_hline_set_suppress(ocrpt_hline *hline,
                         const char *expr_string);

ocrpt_expr *
ocrpt_hline_get_suppress(ocrpt_hline *hline);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetcolor">
					<title>Set or get horizontal line color</title>
					<para>
						Set the horizontal line's color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_hline_set_color(ocrpt_hline *hline,
                      const char *expr_string);

ocrpt_expr *
ocrpt_hline_get_color(ocrpt_hline *hline);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddbarcode">
				<title>Add a barcode to an output section</title>
				<para>
					<programlisting>ocrpt_barcode *
ocrpt_output_add_barcode(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3 id="textaddbarcode">
				<title>Add a barcode to a text line</title>
				<para>
					<programlisting>ocrpt_barcode *
ocrpt_line_add_barcode(ocrpt_line *line);</programlisting>
				</para>
			</sect3>
			<sect3 id="barcodesettings">
				<title>Barcode settings</title>
				<sect4 id="barcodesetvalue">
					<title>Set or get barcode value</title>
					<para>
						Set the barcode's value from
						an expression string. The expression
						must evaluate to a string, whose
						value is the string to be encoded
						as a barcode.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_value(ocrpt_barcode *bc,
                        const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_value(ocrpt_barcode *bc);</programlisting>
					</para>
				</sect4>
				<sect4 id="barcodesetvaluedelayed">
					<title>Set or get barcode value delayed</title>
					<para>
						Set the barcode's value delayed from
						an expression string. The expression
						must evaluate to a boolean value.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_value_delayed(ocrpt_barcode *bc,
                                const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_value_delayed(ocrpt_barcode *bc);</programlisting>
					</para>
				</sect4>
				<sect4 id="barcodesetsuppress">
					<title>Set or get barcode suppression</title>
					<para>
						Set the barcode's suppression value from
						an expression string. The expression
						must evaluate to a boolean value.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_suppress(ocrpt_barcode *bc,
                           const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_suppress(ocrpt_barcode *bc);</programlisting>
					</para>
					<para>
						Default value is <literal>false</literal>,
						i.e. no suppression.
					</para>
				</sect4>
				<sect4 id="barcodesettype">
					<title>Set or get barcode type</title>
					<para>
						Set the barcode's type from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_type(ocrpt_barcode *bc,
                       const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_type(ocrpt_barcode *bc);</programlisting>
					</para>
					<para>
						The type may be optional, in which
						case it's autodetected and the barcode
						is rendered in the format that first
						allows the <literal>value</literal> string
						to be rendered. Possible types (in the order of
						autodetection) are:
						<literal>upc-a</literal>,
						<literal>ean-13</literal>,
						<literal>upc-e</literal>,
						<literal>ean-8</literal>,
						<literal>isbn</literal>,
						<literal>code39</literal>,
						<literal>code39ext</literal>,
						<literal>code128b</literal>
						<literal>code128c</literal>, or
						<literal>code128</literal>.
						If <literal>type</literal> is specified,
						the <literal>value</literal> is
						rendered in that barcode type if
						the string is valid for the type.
						If <literal>value</literal> is invalid
						for the specified <literal>type</literal>,
						or autodetection fails, because the
						<literal>value</literal> is invalid
						for any of the above listed types,
						the barcode is not rendered.
					</para>
				</sect4>
				<sect4 id="barcodesetwidth">
					<title>Set or get barcode width</title>
					<para>
						Set the barcode's width from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_width(ocrpt_barcode *bc,
                        const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_width(ocrpt_barcode *bc);</programlisting>
					</para>
					<para>
						The width is set according to
						<xref linkend="sizeunit"/>,
						either in points (1/72th inch) or
						in (monospace) font width units
						set by <literal>&lt;Line&gt;</literal>.
					</para>
				</sect4>
				<sect4 id="barcodesetheight">
					<title>Set or get barcode width</title>
					<para>
						Set the barcode's height from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_height(ocrpt_barcode *bc,
                         const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_height(ocrpt_barcode *bc);</programlisting>
					</para>
					<para>
						This setting is always in points, i.e.
						1/72th of an inch. The line height will
						be determined by greatest height
						of all the <literal>&lt;field&gt;</literal>,
						<literal>&lt;literal&gt;</literal> and
						<literal>&lt;Barcode&gt;</literal> fields
						in the same <literal>&lt;Line&gt;</literal>
						in a way that the elements of the same line
						will appear (approximately) centered vertically.
					</para>
				</sect4>
				<sect4 id="barcodesetcolor">
					<title>Set or get barcode line color</title>
					<para>
						Set the barcode's line color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_color(ocrpt_barcode *bc,
                         const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_color(ocrpt_barcode *bc);</programlisting>
					</para>
				</sect4>
				<sect4 id="barcodesetbgcolor">
					<title>Set or get barcode background color</title>
					<para>
						Set the barcode's background color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_barcode_set_bgcolor(ocrpt_barcode *bc,
                         const char *expr_string);

ocrpt_expr *
ocrpt_barcode_get_bgcolor(ocrpt_barcode *bc);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddimage">
				<title>Add an image to an output section</title>
				<para>
					<programlisting>ocrpt_image *
ocrpt_output_add_image(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3 id="textaddimage">
				<title>Add an image to a text line</title>
				<para>
					<programlisting>ocrpt_image *
ocrpt_line_add_image(ocrpt_line *line);</programlisting>
				</para>
			</sect3>
			<sect3 id="imagesettings">
				<title>Image settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="imagesetvalue">
					<title>Set or get image value</title>
					<para>
						Set the image's value (filename) from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_image_set_value(ocrpt_image *image,
                      const char *expr_string);

ocrpt_expr *
ocrpt_image_get_value(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetsuppress">
					<title>Set or get image suppression</title>
					<para>
						Set the image's suppression from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_image_set_suppress(ocrpt_image *image,
                         const char *expr_string);

ocrpt_expr *
ocrpt_image_get_suppress(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesettype">
					<title>Set or get image type</title>
					<para>
						Set the image's type from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_image_set_type(ocrpt_image *image,
                     const char *expr_string);

ocrpt_expr *
ocrpt_image_get_type(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetwidth">
					<title>Set or get image width</title>
					<para>
						Set the image's width from
						an expression string. Used when
						the image is directly added to
						an output section.
						<programlisting>ocrpt_expr *
ocrpt_image_set_width(ocrpt_image *image,
                      const char *expr_string);

ocrpt_expr *
ocrpt_image_get_width(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetheight">
					<title>Set or get image height</title>
					<para>
						Set the image's width from
						an expression string. Used when
						the image is directly added to
						an output section.
						<programlisting>ocrpt_expr *
ocrpt_image_set_height(ocrpt_image *image,
                       const char *expr_string);

ocrpt_expr *
ocrpt_image_get_height(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetalignment">
					<title>Set or get image alignment</title>
					<para>
						Set the image's alignment from
						an expression string. Used when
						the image is added to text line.
						<programlisting>ocrpt_expr *
ocrpt_image_set_alignment(ocrpt_image *image,
                      const char *expr_string);

ocrpt_expr *
ocrpt_image_get_alignment(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetbgcolor">
					<title>Set or get image background color</title>
					<para>
						Set the image's background color from
						an expression string.
						<programlisting>ocrpt_expr *
ocrpt_image_set_bgcolor(ocrpt_image *image,
                        const char *expr_string);

ocrpt_expr *
ocrpt_image_get_bgcolor(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagessetfieldwidth">
					<title>Set or get image field width</title>
					<para>
						Set the image's field width from
						an expression string. Used when
						the image is added to a text line.
						<programlisting>ocrpt_expr *
ocrpt_image_set_text_width(ocrpt_image *image,
                           const char *expr_string);

ocrpt_expr *
ocrpt_image_get_text_width(ocrpt_image *image);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddimageend">
				<title>Add an image end marker to an output section</title>
				<para>
					<programlisting>void
ocrpt_output_add_image_end(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="callbackfuncs">
			<title>Callback related functions</title>
			<para>
				Certain stages of the report execution can
				notify the application about the stage
				being executed or finished.
			</para>
			<para>
				Every "add a callback" function below return
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
			</para>
			<sect3 id="addpartaddedcb">
				<title>Add a "part added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_part_cb)(opencreport *,
                 ocrpt_part *,
                 void *data);

bool
ocrpt_add_part_added_cb(opencreport *o,
                        ocrpt_part_cb func,
                        void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="addreportaddedcb">
				<title>Add a "report added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_report_cb)(opencreport *,
                   ocrpt_report *,
                   void *data);

bool
ocrpt_add_report_added_cb(opencreport *o,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="addprecalcsdonecb">
				<title>Add an "all precalculations done" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_cb)(opencreport *,
            void *data);

bool
ocrpt_add_precalculation_done_cb(opencreport *o,
                                 ocrpt_cb func,
                                 void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="addpartitercb">
				<title>Add a "part iteration" callback</title>
				<para>
					<programlisting>bool
ocrpt_part_add_iteration_cb(ocrpt_part *r,
                            ocrpt_part_cb func,
                            void *data);

bool
ocrpt_part_add_iteration_cb2(opencreport *o,
                             ocrpt_part_cb func,
                             void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report part. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportstartedcb">
				<title>Add a "report started" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_start_cb(ocrpt_report *r,
                          ocrpt_report_cb func,
                          void *data);

bool
ocrpt_report_add_start_cb2(opencreport *o,
                           ocrpt_report_cb func,
                           void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportdonecb">
				<title>Add a "report done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_done_cb(ocrpt_report *r,
                         ocrpt_report_cb func,
                         void *data);

bool
ocrpt_report_add_done_cb2(opencreport *o,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addnewrowcb">
				<title>Add a "new row" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_new_row_cb(ocrpt_report *r,
                            ocrpt_report_cb func,
                            void *data);

bool
ocrpt_report_add_new_row_cb2(opencreport *o,
                             ocrpt_report_cb func,
                             void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportiterdonecb">
				<title>Add a "report iteration done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_iteration_cb(ocrpt_report *r,
                              ocrpt_report_cb func,
                              void *data);

bool
ocrpt_report_add_iteration_cb2(opencreport *o,
                               ocrpt_report_cb func,
                               void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportprecalcdone">
				<title>Add a "report precalculation done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_precalculation_done_cb(ocrpt_report *r,
                                        ocrpt_report_cb func,
                                        void *data);

bool
ocrpt_report_add_precalculation_done_cb2(opencreport *o,
                                         ocrpt_report_cb func,
                                         void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addbreaktriggerscb">
				<title>Add a "break triggers" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_break_trigger_cb)(opencreport *,
                          ocrpt_report *,
                          ocrpt_break *,
                          void *);

bool
ocrpt_break_add_trigger_cb(ocrpt_break *br,
                           ocrpt_break_trigger_cb func,
                           void *data);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="envfuncs">
			<title>Environment related functions</title>
			<sect3 id="getenvvarindirect">
				<title>Indirect function to get an environment variable</title>
				<para>
					<programlisting>typedef ocrpt_result *
(*ocrpt_env_query_func)(opencreport *,
                        const char *);

extern ocrpt_env_query_func
ocrpt_env_get;</programlisting>
				</para>
			</sect3>
			<sect3 id="setenvqueryfunc">
				<title>Set the environment query function</title>
				<para>
					<programlisting>void
ocrpt_env_set_query_func(ocrpt_env_query_func func);</programlisting>
				</para>
			</sect3>
			<sect3 id="capienvqueryfunc">
				<title>C API environment query function</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_env_get_c(opencreport *o,
                const char *env);</programlisting>
				</para>
			</sect3>
			<sect3 id="setmvarfunc">
				<title>Add an "m" domain variable</title>
				<para>
					Set an "m" domain variable.
					If such a variable <literal>name</literal>
					didn't exist yet, and <literal>value</literal>
					is not <literal>NULL</literal>, then
					the variable is set. If <literal>value</literal>
					is <literal>NULL</literal>, the variable is
					removed. Such an explicit variable takes
					precedence over the environment variable
					of the same name when used in expressions.
					<programlisting>void
ocrpt_set_mvariable(opencreport *o,
                    const char *name,
                    const char *value);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="filefuncs">
			<title>File handling related functions</title>
			<sect3 id="getcanonfile">
				<title>Return a canonical file path</title>
				<para>
					The returned path contains only single
					directory separators and doesn't contains
					symlinks.
					<programlisting>char *
ocrpt_canonicalize_path(const char *path);</programlisting>
				</para>
			</sect3>
			<sect3 id="addsearchpath">
				<title>Add search path</title>
				<para>
					Add a new directory path to the list of
					search paths. It's useful to find files
					referenced with relative path.
					<programlisting>void
ocrpt_add_search_path(opencreport *o,
                      const char *path);</programlisting>
				</para>
			</sect3>
			<sect3 id="addsearchpath2">
				<title>Add search path (delayed variant)</title>
				<para>
					Add a new directory path from an expression string
					to the list of search paths. It's useful to find
					files referenced with relative path.
					The expression must evaluate to a string value.
					It is evaluated at the beginning of the report
					execution. This function may be used explicitly
					but it's also used when parsing the
					<literal>&lt;Path&gt;</literal> nodes in a
					report XML description.
					<programlisting>void
ocrpt_add_search_path_from_expr(opencreport *o,
                                const char *expr_string);</programlisting>
				</para>
			</sect3>
			<sect3 id="resolvesearchpaths">
				<title>Resolve search paths</title>
				<para>
					Resolve expressions added by
					<literal>ocrpt_add_search_path_from_expr()</literal>.
					It's used internally when executing the report.
					<programlisting>void
ocrpt_resolve_search_paths(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="findfile">
				<title>Find a file</title>
				<para>
					Find a file and return the canonicalized path to it.
					This function takes the search paths into account.
					<programlisting>char *
ocrpt_find_file(opencreport *o,
                const char *filename);</programlisting>
				</para>
				<para>
					Note that search paths added by
					<literal>ocrpt_add_search_path()</literal>
					and <literal>ocrpt_add_search_path_from_expr()</literal>
					are used in their order of appearance when searching
					for files during executing the report.
				</para>
			</sect3>
		</sect2>
		<sect2 id="colorfuncs">
			<title>Color related functions</title>
			<sect3 id="findcolor">
				<title>Find a color by its name</title>
				<para>
					The function fills in the
					<literal>ocrpt_color</literal> structure with
					RGB values in Cairo values (0.0 ... 1.0).
				</para>
				<para>
					If the color name starts with
					<literal>#</literal> or <literal>0x</literal> or
					<literal>0X</literal> then it must be in HTML
					notation.
				</para>
				<para>
					Otherwise, the color name is looked up in the
					color name database in a case insensitive way.
					If found, the passed-in ocrpt_color structure is
					filled with the RGB color value of that name.
				</para>
				<para>
					If not found or the passed-in color name is NULL,
					depending on the the expected usage (foreground
					or background color), the <literal>ocrpt_color</literal>
					structure is filled with either white or black.
					<programlisting>void
ocrpt_get_color(opencreport *o,
                const char *cname,
                ocrpt_color *color,
                bool bgcolor);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="paperfuncs">
			<title>Paper size related functions</title>
			<para>
				Paper size in OpenCReports is handled via
				<ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>.
			</para>
			<para>
				This structure is used in OpenCReports to represent
				paper name and size:
				<programlisting>struct ocrpt_paper {
    const char *name;
    double width;
    double height;
};
typedef struct ocrpt_paper ocrpt_paper;</programlisting>
			</para>
			<sect3 id="getdefsystempaper">
				<title>Get the system default paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_system_paper(void);</programlisting>
				</para>
			</sect3>
			<sect3 id="getpaperbyname">
				<title>Get the paper specified by name</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper_by_name(const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3 id="setglobalpaper">
				<title>Set the global paper</title>
				<para>
					Set global paper using an
					<literal>ocrpt_paper</literal> structure.
					The contents of the structure is copied.
					<programlisting>void
ocrpt_set_paper(opencreport *o,
                const ocrpt_paper *paper);</programlisting>
				</para>
			</sect3>
			<sect3 id="setglobalpaperbyname">
				<title>Set global paper specified by name</title>
				<para>
					Set paper for the report using a paper name.
					If the paper name is unknown, the system default paper is set.
					<programlisting>void
ocrpt_set_paper_by_name(opencreport *o,
                        const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3 id="getglobalpaper">
				<title>Get currently set global paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="paperiterator">
				<title>Iterate over paper sizes</title>
				<para>
					Get the next <literal>ocrpt_paper</literal> structure
					in the iterator. For the first call, the iterator
					pointer must be NULL. It returns NULL when there are
					no more papers known to the system.
					<programlisting>const ocrpt_paper *
ocrpt_paper_next(opencreport *o,
                 void **iter);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="memoryfuncs">
			<title>Memory handling related functions</title>
			<para>
				Memory handling is done through an indirection,
				to help with bindings (that may do their own memory
				handling) override the default.
			</para>
			<sect3 id="funcptrs">
				<title>Indirect function pointers</title>
				<para>
					<programlisting>typedef void *
(*ocrpt_mem_malloc_t)(size_t);

typedef void *
(*ocrpt_mem_realloc_t)(void *,
                       size_t);

typedef void *
(*ocrpt_mem_reallocarray_t)(void *,
                            size_t,
                            size_t);

typedef void
(*ocrpt_mem_free_t)(const void *);

typedef char *
(*ocrpt_mem_strdup_t)(const char *);

typedef char *
(*ocrpt_mem_strndup_t)(const char *,
                       size_t);

typedef void
(*ocrpt_mem_free_size_t)(void *,
                         size_t);

extern ocrpt_mem_malloc_t ocrpt_mem_malloc0;
extern ocrpt_mem_realloc_t ocrpt_mem_realloc0;
extern ocrpt_mem_reallocarray_t ocrpt_mem_reallocarray0;
extern ocrpt_mem_free_t ocrpt_mem_free0;
extern ocrpt_mem_strdup_t ocrpt_mem_strdup0;
extern ocrpt_mem_strndup_t ocrpt_mem_strndup0;</programlisting>
				</para>
			</sect3>
			<sect3 id="allocmem">
				<title>Allocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_malloc(size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="reallocmem">
				<title>Reallocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_realloc(void *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="reallocarray">
				<title>Reallocate array of memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_reallocarray(void *ptr,
                       size_t nmemb,
                       size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="freemem">
				<title>Free memory</title>
				<para>
					<programlisting>void
ocrpt_mem_free(const void *ptr);</programlisting>
				</para>
			</sect3>
			<sect3 id="duplicatecstring">
				<title>Duplicate C string</title>
				<para>
					<programlisting>void *
ocrpt_mem_strdup(const char *ptr);</programlisting>
				</para>
			</sect3>
			<sect3 id="duplicatecstringlen">
				<title>Duplicate C string up to the specified length</title>
				<para>
					<programlisting>void *
ocrpt_mem_strndup(const char *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="freecstring">
				<title>Free a C string</title>
				<para>
					It'a convenience alias for
					<literal>ocrpt_mem_free()</literal>.
					<programlisting>void
ocrpt_strfree(const char *s);</programlisting>
				</para>
			</sect3>
			<sect3 id="setallocptrs">
				<title>Set indirect allocation functions</title>
				<para>
					<programlisting>void
ocrpt_mem_set_alloc_funcs(ocrpt_mem_malloc_t rmalloc,
                          ocrpt_mem_realloc_t rrealloc,
                          ocrpt_mem_reallocarray_t rreallocarray,
                          ocrpt_mem_free_t rfree,
                          ocrpt_mem_strdup_t rstrdup,
                          ocrpt_mem_strndup_t rstrndup);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="listfuncs">
			<title>List related functions</title>
			<para>
				These functions implement a single linked list.
				The list element structure is hidden:
				<programlisting>struct ocrpt_list;
typedef struct ocrpt_list ocrpt_list;</programlisting>
			</para>
			<sect3 id="listgetlength">
				<title>Get the list length</title>
				<para>
					<programlisting>size_t
ocrpt_list_length(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listmake1">
				<title>Make a list from one element</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_makelist1(const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listmakemulti">
				<title>Make a list from multiple elements</title>
				<para>
					This function can be used with variable
					number of arguments.
					<programlisting>ocrpt_list *
ocrpt_makelist(const void *data1, ...);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetlast">
				<title>Get the last element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_last(const ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetnth">
				<title>Get the nth element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_nth(const ocrpt_list *l, uint32_t n);</programlisting>
				</para>
			</sect3>
			<sect3 id="listappend">
				<title>Append a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_append(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listappendwend">
				<title>Append to list using the last element</title>
				<para>
					This function make appending to the list work
					<emphasis>O(1)</emphasis> instead of
					<emphasis>O(n)</emphasis>.
					<programlisting>ocrpt_list *
ocrpt_list_end_append(ocrpt_list *l,
                      ocrpt_list **e,
                      const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listprepend">
				<title>Prepend a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_prepend(ocrpt_list *l,
                   const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listremove">
				<title>Remove a data element from a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_remove(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listremovewend">
				<title>Remove a data element from a list and update the last link</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_end_remove(ocrpt_list *l,
                      ocrpt_list **endptr,
                      const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetnext">
				<title>Get next link in the list</title>
				<para>
					This can be used to iterate through a list.
					It returns <literal>NULL</literal> if the
					passed-in link is the last list in the list
					or it's an empty list.
					<programlisting>ocrpt_list *
ocrpt_list_next(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetdata">
				<title>Get the data element from a list</title>
				<para>
					<programlisting>void *
ocrpt_list_get_data(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listfree">
				<title>Free a list</title>
				<para>
					<programlisting>void
ocrpt_list_free(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listdeepfree">
				<title>Free a list and its data elements</title>
				<para>
					<programlisting>void
ocrpt_list_free_deep(ocrpt_list *l,
                     ocrpt_mem_free_t freefunc);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="cstringfuncs">
			<title>String related functions</title>
			<para>
				For memory safety and higher performance, a wrapper
				structure is used over C functions.
				<programlisting>struct ocrpt_string {
    char *str;
    size_t allocated_len;
    size_t len;
};
typedef struct ocrpt_string ocrpt_string;</programlisting>
			</para>
			<sect3 id="stringcreate">
				<title>Create a new string</title>
				<para>
					Create a new string from a C string.
					The ownership of the input string may be
					taken over, or the original string's contents
					are copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new(const char *str,
                     bool copy);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringcreatelen">
				<title>Create a new string with specified allocated length</title>
				<para>
					Create a new string with specified allocated length
					so future growth can be done without reallocation.
					The input string is always copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_with_len(const char *str,
                              size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringcreatevnprintf">
				<title>Create a string from a formatted string with maximum length</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_vnprintf(size_t len,
                              const char *format,
                              va_list va);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringcreateprintf">
				<title>Create a string from a formatted string</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_printf(const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringresize">
				<title>Resize a string</title>
				<para>
					Resize the string to the specified allocated
					length.
					<programlisting>ocrpt_string *
ocrpt_mem_string_resize(ocrpt_string *string,
                        size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringfree">
				<title>Free a string</title>
				<para>
					<programlisting>char *
ocrpt_mem_string_free(ocrpt_string *string,
                      bool free_str);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendcstring">
				<title>Append a C string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len(ocrpt_string *string,
                            const char *str,
                            const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendbinary">
				<title>Append a binary string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len_binary(ocrpt_string *string,
                                   const char *str,
                                   const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendcstringwlen">
				<title>Append a C string of unspecified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append(ocrpt_string *string,
                        const char *str);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendchar">
				<title>Append a byte to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_c(ocrpt_string *string,
                          const char c);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendprintf">
				<title>Append a formatted string to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_printf(ocrpt_string *string,
                               const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
</chapter>

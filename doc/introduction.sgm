<chapter id="introduction" xreflabel="Introduction and concepts">
	<title>Introduction and concepts</title>
	<sect1 id="rlib" xreflabel="RLIB">
		<title>The predecessor: RLIB</title>
		<para>
			The idea to write <ulink url="https://github.com/zboszor/OpenCReports">OpenCReports</ulink>
			started with my getting acqauinted with <ulink url="https://github.com/SICOM/rlib">RLIB</ulink>
			in 2005 and working with it (and on it) for a very long time,
			with the original implementors finally losing interest in
			developing RLIB further. This was around 2018. Even the
			original documentation site for RLIB was retired. But
			thanks to the Internet Archive,
			<ulink url="https://web.archive.org/web/20131116192438/http://newrlib.sicom.com/~rlib/index.php/Main_Page">it may still be read</ulink>
		</para>
		<para>
			To overcome some of the shortcomings seen in RLIB,
			its <emphasis>ideas</emphasis> were used for a completely
			new implementation with high level of compatibility
			to the original.
		</para>
		<para>
			RLIB is a report generator library, so is OpenCReports.
			In this documentation, a lot of references contain
			comparisons to RLIB.
		</para>
		<para>
			The name OpenCReports came from the fact that it's
			implemented in the C programming language in an
			open way, and using a free software license.
		</para>
	</sect1>
	<sect1 id="concepts" xreflabel="Concepts">
		<title>Concepts</title>
		<sect2 id="whatisarepgen">
			<title>What is a report generator?</title>
			<para>
				A report generator uses a tabular data source, which contains
				rows and columns of data. The columns have labels or names.
				(An SQL database query is such a tabular data source.)
				It also uses some kind of description that specifies how
				to display the data. The input data is transformed into
				various output formats, some for human viewing, some for
				further machine processing. Such output formats may be PDF,
				HTML, XML, plain text or CSV.
			</para>
		</sect2>
		<sect2 id="xmlbaseddesc">
			<title>XML based report description</title>
			<para>
				The XML file format is widely used. It can describe
				structured data in a hierarchy with names for its
				sections or "nodes".
			</para>
			<para>
				OpenCReports uses an RLIB-compatible report description
				with extensions. See <xref linkend="xmldescriptor"/> and the
				<ulink url="https://web.archive.org/web/20131116192438/http://newrlib.sicom.com/~rlib/index.php/Main_Page">RLIB documentation</ulink>
			</para>
		</sect2>
		<sect2 id="comprehensiveapi">
			<title>Comprehensive API for report creation</title>
			<para>
				The <xref linkend="lowlevelapi"/> allows creating a report purely
				via program code. The <xref linkend="highlevelapi"/> allows loading
				an XML report description that contains all details
				about the report, including database access. Mixing
				the high and low level APIs allows a balance anywhere
				between the two extremes. For example, load the report
				description, which contains the complete layout, and pass
				database access details via program code. RLIB's API and
				report description allowed neither extremes, it relied on
				the report description to provide the layout, with the
				data access added from programming code.
			</para>
		</sect2>
		<sect2 id="strictparser">
			<title>Strict expression parser</title>
			<para>
				OpenCReports uses a Flex/Bison based expression parser.
				The expression grammar doesn't allow buggy expressions.
				See the <xref linkend="expressions"/> chapter.
			</para>
			<para>
				RLIB's expression parser was a custom implementation
				which was slightly fragile and forgiving. For example,
				it allowed unclosed parentheses at the end of an
				expression.
			</para>
		</sect2>
		<sect2 id="expropt">
			<title>Expression optimization</title>
			<para>
				OpenCReports does some expression optimization
				to reduce runtime cost of computing expression
				values. For example, in <literal>a*2/3</literal>
				the part <literal>2/3</literal> is two constants
				in a division. This is precomputed into a single
				constant as an optimization.
			</para>
			<para>
				RLIB didn't contain automatic optimizations.
				It relied on manual optimizations, like using
				<xref linkend="variables"/>.
			</para>
		</sect2>
		<sect2 id="repvars">
			<title>Report variables</title>
			<para>
				OpenCReports supports standard report variables
				for calculating sums, minimum, maximum and average values
				or custom defined ones. See <xref linkend="variables"/>
			</para>
		</sect2>
		<sect2 id="setoffuncs">
			<title>Extensive and extensible set of functions</title>
			<para>
				OpenCReports has many operators and functions to
				be used in expressions. See <xref linkend="opsandfunc"/>
				in the <xref linkend="expressions"/> chapter.
			</para>
			<para>
				In fact, OpenCReports has all the operators and
				functions that RLIB also had, with many additions.
			</para>
			<para>
				Custom functions can also be added to a report by
				programming code. Custom functions may override stock
				functions.
			</para>
		</sect2>
		<sect2 id="utf8strings">
			<title>UTF-8 string handling</title>
			<para>
				OpenCReports exclusively uses UTF-8 for strings.
				Input data must be in UTF-8 and output formats
				also use UTF-8.
			</para>
			<para>
				RLIB could have been built with or without UTF-8 support.
				The build that disabled UTF-8 support relied on
				single byte character set encodings and conversion
				between them. That wasn't always reliable. Since that
				time, multibyte character encodings have won.
			</para>
		</sect2>
		<sect2 id="highprecnumerics">
			<title>High precision numeric data type</title>
			<para>
				For historic record, RLIB was designed for the US
				and slower machines. It used a fixed point numeric
				representation. For the US, with its strong currency
				and prices expressed in low numbers, this was an
				acceptable design decision. But for countries, whose
				currencies are a few orders of magnitude weaker and
				conversely, the prices are similarly higher, the fixed
				point numeric value range was easily overflown, leading
				to wrong data in the report output.
			</para>
			<para>
				Another potential problem with the fixed point numeric
				representation was that converting numbers from the
				input data to this internal representation always and
				unconditionally rounded down. This can be demonstrated
				with a carefully constructed (small) data set that would
				add up exactly to 100% both on paper and with using the
				IEEE-754 <literal>double</literal> data type, it would
				only add up to 99.99% with RLIB's internal numeric
				representation.
			</para>
			<para>
				To avoid these kind of problems, OpenCReports uses
				GNU MPFR floating point values with 256-bit precision
				by default. This allows storing very large and very small
				numbers. E.g. this allows computations even with late
				stage
				<ulink url="https://en.wikipedia.org/wiki/Hyperinflation">hyperinflation</ulink>
				prices.
				See <xref linkend="numericconstants"/> in
				the <xref linkend="expressions"/> chapter and the
				<xref linkend="numerictuning"/> part in the
				<xref linkend="lowlevelapi"/> chapter.
			</para>
		</sect2>
		<sect2 id="datetimetypes">
			<title>Datetime and interval data types</title>
			<para>
				OpenCReports differentiates between timestamp and
				time interval data types, with the latter allowing
				adding or subtracting a custom time period to and from
				timestamp data. See <xref linkend="datetimeconstants"/>
				in the <xref linkend="expressions"/> chapter.
			</para>
		</sect2>
		<sect2 id="autoconv">
			<title>Automatic input data conversion</title>
			<para>
				For maximum portability, databases provide their
				data in strings. They also provide metadata that
				describes the data type of every column in the
				data record.
			</para>
			<para>
				RLIB relied on explicit data conversion functions,
				like <literal>val()</literal> and
				<literal>stodt()</literal>.
			</para>
			<para>
				OpenCReports discovers the columns' data type
				and applies the conversion automatically. For
				RLIB compatibility, the conversion functions
				pass through values as is if they are already
				converted. For example, the <literal>val()</literal>
				function accepts an operand with both string and
				numeric data types. In the former case the conversion
				to numeric is performed, but if the operand is
				already numeric, no further conversion takes place.
				This is user friendly in two aspects: the conversion
				function is not necessary when implementing a new
				report, and an already existing RLIB report (that
				contains such conversion functions for the input data)
				may be used as is.
			</para>
		</sect2>
		<sect2 id="alignments">
			<title>Versatile field alignment and multi-row fields</title>
			<para>
				In the report output, fields may have a fixed width in
				which they are displayed. Some field values are longer
				that the field width. When displaying them in a single
				row, fields may be left-, right- or center-aligned.
				With the PDF output, this means pixel-perfect alignment
				with the parts of the field value that don't fit masked
				off visually. RLIB aligned the data actually truncated
				to fit into the field width.
			</para>
			<para>
				Fields longer than the designated width may be wrapped
				either at word or character boundaries. This way, they
				become multi-row fields. RLIB called them "memo" fields
				and the XML report description in OpenCReports also
				uses the same naming for the flags dealing with this
				detail. Multi-row fields are configurable regading word
				or character wrapping, or they may be limited to print
				only a certain amount of lines. Memo fields can break
				over column or page boundaries.
			</para>
			<para>
				OpenCReports have some differences from RLIB regards to
				memo fields.
			</para>
			<para>
				Thanks to Pango rendering, when using character wrapping,
				hyphenation is done.
			</para>
			<para>
				The second extension over RLIB is that
				<literal>justified</literal> alignment can also be
				used for multi-line fields. This is also thanks to
				Pango. When <literal>justified</literal> alignment is
				used, all lines but the last are justified. Therefore,
				<literal>justified</literal> alignment is equivalent to
				<literal>left</literal> alignment for single line fields.
			</para>
		</sect2>
		<sect2 id="repbreaks">
			<title>Report breaks</title>
			<para>
				OpenCReports supports report breaks defined on arbitrary
				expressions. Breaks occur when the expression value
				changes, when stepping from one data set row to the next.
				See <xref linkend="breaks"/> and <xref linkend="breaksnode"/>
			</para>
		</sect2>
		<sect2 id="multicolrep">
			<title>Multi-column reports</title>
			<para>
				OpenCReports, just like RLIB, supports both single-column
				and multi-column report layout.
			</para>
			<para>
				If a report is "narrow", so more columns would fit on
				the same page, the report may be set to use multiple
				columns on the same page.
			</para>
		</sect2>
		<sect2 id="layoutdetails">
			<title>Layout details</title>
			<para>
				In RLIB, sizing of layout details are a mix of units,
				making it harder to design the report layout:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							field widths and report heights are in
							number of characters
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							width of lines are in points (1/72th inch)
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							width of gaps between columns of a
							multi-column report is in inches
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				OpenCReports faithfully reimplements these
				for compatibility.
			</para>
			<para>
				However, there are problems with field widths
				calculated in number of characters. Widths using
				a 12 point font is not the same as widths using
				a 20 point font. Also, font width and height are
				usually not identical. Some fonts are lean, with
				their width smaller than their height. RLIB expected
				that fonts are using the same character width and
				height. For this reason, RLIB only supported a small
				variety of monospace fonts.
			</para>
			<para>
				Also, character widths for proportional fonts differ.
				Field width expressed in number of characters cannot
				be exact when using  proportional fonts. For this reason,
				RLIB didn't support proportional fonts at all.
			</para>
			<para>
				OpenCReports extended upon these ideas, so individual
				fields in a text line may use custom font settings
				while keeping the field width calculation identical
				to RLIB, which ends with the font parameters set for
				the text line. In OpenCReports, the fields' custom font
				settings (font name and size) don't influence the field
				width. Using this method, OpenCReports may use proportional
				fonts even with using the RLIB compatible size settings.
			</para>
			<para>
				On top of that, OpenCReports also has a new, consistent
				size calculation method where everything is measured in
				points.
			</para>
		</sect2>
		<sect2 id="outputformats">
			<title>Multiple output formats</title>
			<para>
				OpenCReports supports several output formats:
				PDF, HTML, CSV, TXT, XML and JSON.
			</para>
			<para>
				By using the excellent drawing possibilities of
				Cairo coupled with Pango for text rendering,
				OpenCReports supports generating the report in
				PDF format. PDF is the definitive output format
				in OpenCReports, as in it supports every feature
				described in <xref linkend="xmldescriptor"/>, such as
				<itemizedlist>
					<listitem override="bullet">
						<para>
							page breaks (PDF is a multi-page format)
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							all four page margins: top, bottom, left, right
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							column breaks, multi-column reports
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							report column width and height
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				When using the HTML output format, OpenCReports
				attempts to imitate the PDF drawing capabilities
				using CSS. However, there are inevitable differences.
				<itemizedlist>
					<listitem override="bullet">
						<para>
							The HTML output doesn't support page breaks.
							HTML is rendered as a continuous flow of text
							and other elements. As a consequence,
							<literal>r.pageno</literal> and
							<literal>r.totpages</literal> are both 1
							for the whole output.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							HTML output doesn't support column breaks.
							As a consequence, a multi-column report layout
							is rendered differently from PDF.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							When a data row's column does not fit into the
							width specified by the page margins or the
							report column's width, it is rendered in the
							remaining width differently from PDF. While PDF
							uses the whole field width to render the data
							field contents and uses bounding box to clip
							the invisible part, CSS uses the remaining width
							specified by either the margins or the report
							column width to render the field. Left, right
							and center alignment of the field is done
							according to the remaining width for the field.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				When rendering field data wider than their
				field widths, both the PDF and the HTML output drivers
				use clipping (bounding box) to hide parts of the
				field, fitting them into the designated area
				<emphasis>visually</emphasis>. Actual field data is
				not truncated. In some viewer applications
				(e.g. in Poppler based PDF viewers) a visibly
				truncated field's whole text can be selected,
				copied and pasted elsewhere to be viewed in its
				entirety. Field data in HTML behave the same way
				in browsers.
			</para>
			<para>
				OpenCReports also supports CSV, XML and JSON as
				output formats that don't truncate field data.
				These are plaintext formats with their own internal
				format. CSV is usually used for importing into office
				applications or databases. In general, these formats
				are used in applications where loss of data may
				not be tolerated. These formats don't support page or
				column breaks. CSV does not have a way to express
				multiple inner reports in a table in the same report run.
			</para>
			<para>
				OpenCReports also supports TXT (plaintext) as output
				format, that approximates RLIB's TXT output.
				This format may truncate field data because it expects
				monospace font and character based field widths;
				and fields in this format cannot be presented separately
				like in other formats. The TXT format doesn't support
				page or column breaks. Its rendering ignores font name
				and font size settings and renders everything internally
				using a monospace font at 12 point font size.
			</para>
		</sect2>
		<sect2 id="unittests">
			<title>Extensive set of unit tests</title>
			<para>
				The unit tests ensure that OpenCReports' features keep
				working when adding new features or fixes. Units tests
				exercise many aspects of the high and low level API,
				report description handling, runtime behavior and output
				generation.
			</para>
		</sect2>
		<sect2 id="stddeps">
			<title>Standard Linux dependencies</title>
			<para>
				OpenCReports uses
				<ulink url="https://gitlab.gnome.org/GNOME/libxml2/-/wikis/home">LibXML2</ulink>,
				<ulink url="https://juliastrings.github.io/utf8proc/">utf8proc</ulink>,
				<ulink url="https://www.mpfr.org">MPFR</ulink>,
				<ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>,
				<ulink url="https://github.com/rgamble/libcsv">libcsv</ulink>,
				<ulink url="http://lloyd.github.com/yajl/">yajl</ulink>,
				<ulink url="https://www.cairographics.org">Cairo</ulink>,
				<ulink url="https://pango.gnome.org">Pango</ulink>,
				<ulink url="https://wiki.gnome.org/Projects/LibRsvg">librsvg2</ulink>,
				<ulink url="https://gitlab.gnome.org/GNOME/gdk-pixbuf">gdk-pixbuf2</ulink>,
				<ulink url="https://www.postgresql.org">PostgreSQL</ulink>,
				<ulink url="https://mariadb.com">MariaDB</ulink>
				and
				<ulink url="http://www.unixodbc.org">unixODBC</ulink>.
			</para>
			<para>
				For running the unit tests,
				<ulink url="https://www.ghostscript.com">Ghostscript</ulink>
				and <literal>compare</literal> from
				<ulink url="https://imagemagick.org">Imagemagick</ulink>
				are also needed.
			</para>
			<para>
				<literal>docbook2pdf</literal> and
				<literal>docbook2html</literal> from
				<ulink url="http://sources.redhat.com/docbook-tools/">Docbook</ulink>
				is used to generate the documentation.
			</para>
		</sect2>
	</sect1>
	<sect1 id="planned">
		<title>OpenCReports planned features</title>
		<sect2 id="graphs">
			<title>Graph and chart support in HTML and PDF output</title>
			<para>
				Currently Gantt chart and various graph types (like
				barchart, pie chart and their various subtypes) are
				not supported.
			</para>
		</sect2>
		<sect2 id="visualeditor">
			<title>Visual editor for report XML descriptions</title>
			<para>
				There are other report generators on the market with
				nice GUIs to create the report visually.
			</para>
		</sect2>
	</sect1>
</chapter>

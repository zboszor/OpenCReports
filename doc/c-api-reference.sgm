<chapter id="c-api-reference" xreflabel="C API Reference">
	<title>C language API reference</title>
	<sect1>
		<title>Header file</title>
		<para>
			For using OpenCReports, this single header must be used:
			<programlisting>#include &lt;opencreport.h&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="highlevelapi" xreflabel="High level C API">
		<title>High level C API</title>
		<para>
			Example code using the high level C API where everything
			concerning the report (including the data source)
			is described in the report XML:
			<programlisting>#include &lt;opencreport.h&gt;

int main(void) {
    opencreport *o = ocrpt_init();

    if (!ocrpt_parse_xml(o, "report.xml")) {
        printf("XML parse error\n");
        ocrpt_free(o);
        return 1;
    }

    ocrpt_set_output_format(o, OCRPT_OUTPUT_PDF);
    ocrpt_execute(o);
    ocrpt_spool(o);
    ocrpt_free(o);
    return 0;
}</programlisting>
		</para>
		<para>
			The above code will load <literal>report.xml</literal>,
			set the output format to PDF, runs the report and prints
			it output on <literal>stdout</literal>.
		</para>
		<sect2>
		<title>Report handler initialization</title>
		<para>
			<programlisting>opencreport *ocrpt_init(void);</programlisting>
		</para>
		</sect2>
		<sect2>
			<title>Load a report XML description</title>
			<para>
				This function loads the specified XML file
				into the report handler. It returns
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
				<programlisting>bool ocrpt_parse_xml(opencreport *o, const char *filename);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Set report output format</title>
			<para>
				<programlisting>enum ocrpt_format_type {
    OCRPT_OUTPUT_UNSET,
    OCRPT_OUTPUT_PDF,
    OCRPT_OUTPUT_HTML,
    OCRPT_OUTPUT_TXT,
    OCRPT_OUTPUT_CSV,
    OCRPT_OUTPUT_XML
};
typedef enum ocrpt_format_type ocrpt_format_type;

void ocrpt_set_output_format(opencreport *o,
                             ocrpt_format_type format);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Run the report</title>
			<para>
				This function executes the report, constructs
				the result in memory. It returns <literal>true</literal>
				for success, <literal>false</literal> for failure.
				It is a failure if the output format is unset.
				<programlisting>bool ocrpt_execute(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Dump report result</title>
			<para>
				Dump the report output on the program's
				standard output channel.
				<programlisting>void ocrpt_spool(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Report handler destruction</title>
			<para>
				Calling this function frees up the report handler
				structure and everything created for it, even
				the details that were created by the low level API.
				<programlisting>void ocrpt_free(opencreport *o);</programlisting>
			</para>
		</sect2>
	</sect1>
	<sect1 id="lowlevelapi" xreflabel="Low level C API">
		<title>Low level C API</title>
		<para>
			The <xref linkend="highlevelapi"/> is also part of the
			low level API. The functions described below allow
			creating a report using program code, or simply
			fine tuning the report behavior by mostly using the
			<xref linkend="highlevelapi"/>.
		</para>
		<sect2 id="numerictuning" xreflabel="Numeric behavior related functions">
			<title>Numeric behavior related functions</title>
			<sect3>
				<title><literal>Set numeric precision</literal></title>
				<para>
					The default is 256 bits of floating point precision.
					<programlisting>void ocrpt_set_numeric_precision_bits(opencreport *o,
                                      mpfr_prec_t prec);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set rounding mode</title>
				<para>
					OpenCReports uses GNU MPFR under the hood and does't
					hide this fact. The MPFR rounding mode constants are
					used as is to set the rounding behaviour.
					The default is <literal>MPFR_RNDN</literal>, round
					to nearest.
					<programlisting>void ocrpt_set_rounding_mode(opencreport *o,
                             mpfr_rnd_t rndmode);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Locale related functions</title>
			<sect3>
				<title>Set report locale</title>
				<para>
					Setting the locale for the report does not affect
					the main program or other threads. Locale setting
					includes the language, the country. The UTF-8 suffix
					is necessary. E.g.: <literal>en_GB.UTF-8</literal> or
					<literal>de_DE.UTF-8</literal>
					<programlisting>void ocrpt_set_locale(opencreport *o,
                      const char *locale);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print monetary data in the report locale</title>
				<para>
					A customized monetary printing function was implemented
					for the purposes of the report which MPFR doesn't
					provide. It is used in OpenCReports both internally
					and by unit tests.
					<programlisting>ssize_t ocrpt_mpfr_strfmon(opencreport *o,
                           char *s, size_t maxsize,
                           const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Data source and query related functions</title>
			<para>
				The following <literal>enum</literal> and
				<literal>struct</literal> types are used by
				OpenCReports for datasources and queries.
				<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

struct ocrpt_datasource;
typedef struct ocrpt_datasource ocrpt_datasource;

struct ocrpt_query;
typedef struct ocrpt_query ocrpt_query;

struct ocrpt_query_result;
typedef struct ocrpt_query_result ocrpt_query_result;

struct ocrpt_input {
    void (*describe)(ocrpt_query *,
                     ocrpt_query_result **,
                     int32_t *);
    void (*rewind)(ocrpt_query *);
    bool (*next)(ocrpt_query *);
    bool (*populate_result)(ocrpt_query *);
    bool (*isdone)(ocrpt_query *);
    void (*free)(ocrpt_query *);
    bool (*set_encoding)(ocrpt_datasource *,
                         const char *);
    void (*close)(const ocrpt_datasource *);
};
typedef struct ocrpt_input ocrpt_input;</programlisting>
			</para>
			<para>
				Data sources in this context are "mini drivers".
				Data source handling is implemented via
				<literal>ocrpt_input</literal> functions.
			</para>
			<para>
				Queries are data providers over data sources. They are
				the actual sources of data using a specific data source.
				Multiple queries may use the same data source.
			</para>
			<sect3>
				<title>Add an array datasource</title>
				<para>
					Add an array datasource to the report handler.
					It's optional, as an array datasource called
					"array" is automatically added to an opencreport
					structure.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_array(opencreport *o,
                           const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an array query</title>
				<para>
					Add an "array query" to the report handler.
					This adds the array pointer and parameters, so
					the array datasource input driver can use it.
					The provided <literal>array</literal> array pointer
					contains <literal>(rows + 1) * cols</literal> number of
					<literal>char *</literal> pointers, with the first row
					being the column (field) names. The
					<literal>types</literal> array contains
					<literal>cols</literal> number of
					<literal>enum ocrpt_result_type</literal> elements to
					indicate the column data type.
					<programlisting>ocrpt_query *
ocrpt_query_add_array(opencreport *o,
                      ocrpt_datasource *source,
                      const char *name,
                      const char **array,
                      int32_t rows, int32_t cols,
                      const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					If the <literal>types</literal> pointer is
					<literal>NULL</literal>, the column values are treated
					as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3>
				<title>Add a CSV datasource</title>
				<para>
					Add a CSV datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_csv(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a CSV query</title>
				<para>
					Add a "CSV query" to the report handler.
					This specifies the file name, so
					the CSV datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_csv(opencreport *o,
                    ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					The <literal>types</literal> array pointer is optional.
					If it is <literal>NULL</literal>, the column values are
					treated as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3>
				<title>Add a JSON datasource</title>
				<para>
					Add a JSON datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_json(opencreport *o,
                          const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a JSON query</title>
				<para>
					Add a "JSON query" to the report handler.
					This specifies the file name, so
					the JSON datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_json(opencreport *o,
                     ocrpt_datasource *source,
                     const char *name,
                     const char *filename,
                     const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					The JSON file format defined in <xref linkend="jsonds"/>
					contains the way to describe the column data types,
					which is optional in a JSON file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the JSON file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the JSON file doesn't
					contain type specifiers), the column values are
					treated as strings. RLIB didn't have JSON input.
				</para>
			</sect3>
			<sect3>
				<title>Add an XML datasource</title>
				<para>
					Add an XML datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_xml(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an XML query</title>
				<para>
					Add an "XML query" to the report handler.
					This specifies the file name, so
					the XML datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_xml(opencreport *o,
                    ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					The XML file format defined in <xref linkend="xmlds"/>
					contains the way to describe the column data types,
					which is optional in an XML file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the XML file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the XML file doesn't
					contain type specifiers), the column values are
					treated as strings. This is how RLIB operated.
					The OpenCReports XML input file format is RLIB
					compatible without the type specification part.
				</para>
			</sect3>
			<sect3>
				<title>Add a PostgreSQL datasource</title>
				<para>
					Add a PostgreSQL datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_postgresql(opencreport *o,
                                const char *source_name,
                                const char *host,
                                const char *port,
                                const char *dbname,
                                const char *user,
                                const char *password);

ocrpt_datasource *
ocrpt_datasource_add_postgresql2(opencreport *o,
                                 const char *source_name,
                                 const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="postgresqlds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Add a PostgreSQL query</title>
				<para>
					Add a SQL query using the PostgreSQL datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_postgresql(opencreport *o,
                           ocrpt_datasource *source,
                           const char *name,
                           const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a MariaDB datasource</title>
				<para>
					Add a MariaDB datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_mariadb(opencreport *o,
                             const char *source_name,
                             const char *host,
                             const char *port,
                             const char *dbname,
                             const char *user,
                             const char *password,
                             const char *unix_socket);

ocrpt_datasource *
ocrpt_datasource_add_mariadb2(opencreport *o,
                              const char *source_name,
                              const char *optionfile,
                              const char *group);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="mariadbds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Add a MariaDB query</title>
				<para>
					Add an SQL query using the MariaDB datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_mariadb(opencreport *o,
                        ocrpt_datasource *source,
                        const char *name,
                        const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an ODBC datasource</title>
				<para>
					Add an ODBC datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_odbc(opencreport *o,
                          const char *source_name,
                          const char *dbname,
                          const char *user, const char *password);

ocrpt_datasource *
ocrpt_datasource_add_odbc2(opencreport *o,
                           const char *source_name,
                           const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="odbcds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Add an ODBC query</title>
				<para>
					Add an SQL query using the ODBC datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_odbc(opencreport *o,
                     ocrpt_datasource *source,
                     const char *name,
                     const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Find a datasource</title>
				<para>
					Find the data source using its name.
					It returns NULL if the named data source
					is not found.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_get(opencreport *o,
                     const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add a custom datasource</literal></title>
				<para>
					Add a custom data source to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_add_datasource(opencreport *o,
                     const char *source_name,
                     const ocrpt_input *input);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Set the encoding of a datasource</literal></title>
				<para>
					Set the encoding of a datasource in case
					if it's not already UTF-8, so data provided by
					it is automatically converted.
					<programlisting>void
ocrpt_datasource_set_encoding(opencreport *o,
                              ocrpt_datasource *source,
                              const char *encoding);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Free a datasource</literal></title>
				<para>
					Free a datasource from the opencreport structure
					it was added to. It's not needed to be called,
					all datasources are automatically free with
					<literal>ocrpt_free()</literal>
					<programlisting>void
ocrpt_datasource_free(opencreport *o,
                      ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Find a query</literal></title>
				<para>
					Find a query using its name.
					<programlisting>ocrpt_query *
ocrpt_query_get(opencreport *o,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get the current data row from a query</literal></title>
				<para>
					Create (first call) or get the <literal>ocrpt_query_result</literal>
					array from a query. Output parameter <literal>cols</literal>
					returns the number of columns in the result array. It must
					be re-run after ocrpt_navigate_next() since the previously
					returned pointer becomes invalid.
					<programlisting>ocrpt_query_result *
ocrpt_query_get_result(ocrpt_query *q,
                       int32_t *cols);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get column name</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal> result
					from <literal>ocrpt_query_get_result()</literal>,
					the column names can be discovered from a query.
					<programlisting>const char *
ocrpt_query_result_column_name(ocrpt_query_result *qr,
                               int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get column data</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal>
					result from
					<literal>ocrpt_query_get_result()</literal>, get a
					pointer to the column data in its internal (hidden)
					representation.
					<programlisting>ocrpt_result *
ocrpt_query_result_column_result(ocrpt_query_result *qr,
                                 int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add a follower query</literal></title>
				<para>
					Add a <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and the follower will run in parallel with it until
					the leader runs out of rows. In case the leader has more
					rows than the follower, then for rows in the leader where
					there are no follower rows, the follower fields are set to NULL.
					<programlisting>bool
ocrpt_add_query_follower(opencreport *o,
                         ocrpt_query *leader,
                         ocrpt_query *follower);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add an N:1 follower query</literal></title>
				<para>
					Add an N:1 <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and rows from the follower will be matched using the
					<literal>match</literal> expression. If there are multiple
					rows in the follower matching the leader row, then the leader
					row will be listed that many times. For rows in the leader
					where there are no matching rows in the follower, the follower
					fields are set to NULL. It is similar to <literal>LEFT OUTER
					JOIN</literal> in SQL databases. For creating an
					<literal>ocrpt_expr</literal> expression pointer, see the
					next section.
					<programlisting>bool
ocrpt_add_query_follower_n_to_1(opencreport *o,
                                ocrpt_query *leader,
                                ocrpt_query *follower,
                                ocrpt_expr *match);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Free a query</literal></title>
				<para>
					Free a query and remove it from the report handler.
					It's optional. <literal>ocrpt_free()</literal> frees
					the queries added to the <literal>opencreport</literal>
					structure.
					<programlisting>void
ocrpt_query_free(opencreport *o,
                 ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Start the main query</literal></title>
				<para>
					Start query (or query set) navigation.
					<literal>q</literal> should be the primary query
					of the report.
					<programlisting>void
ocrpt_query_navigate_start(opencreport *o,
                           ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Navigate to the next query row</literal></title>
				<para>
					Navigate the query (or query set) to the next row. Returns
					<literal>false</literal> if there was no more rows.
					in which case the <literal>ocrpt_query_result</literal>
					arrays for all queries in the query set (returned by
					previous <literal>ocrpt_query_get_result()</literal>
					calls contain invalid data.
					<programlisting>bool
ocrpt_query_navigate_next(opencreport *o,
                          ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>API specific array discovery function</literal></title>
				<para>
					For array data sources and queries, OpenCReports
					needs a way to to find the data array and the
					supplementary type identifier array.
					These are language specific. The below ones
					are the C specific ones. The override function
					is also provided to set a new discovery function.
					<programlisting>typedef void
(*ocrpt_query_discover_func)(const char *,
                             void **,
                             const char *,
                             void **);

void
ocrpt_query_set_discover_func(ocrpt_query_discover_func func);

extern ocrpt_query_discover_func ocrpt_query_discover_array;

void
ocrpt_query_discover_array_c(const char *arrayname,
                             void **array,
                             const char *typesname,
                             void **types);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="exprfunc" xreflabel="Expression related functions">
			<title>Expression related functions</title>
			<para>
				Expressions in OpenCReports is explained in the
				<xref linkend="expressions"/> chapter.
			</para>
			<sect3>
				<title>Parse an expression string</title>
				<para>
					This function parses an expression string and
					creates an expression tree. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					The <literal>ocrpt_report</literal> pointer may be
					valid or NULL. If valid, the expression is bound
					to this <literal>ocrpt_report</literal>, i.e.
					it will be freed automatically with
					<literal>ocrpt_free()</literal>.
					<programlisting>ocrpt_expr *
ocrpt_expr_parse(opencreport *o,
                 ocrpt_report *r,
                 const char *str,
                 char **err);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free an expression parse tree</title>
				<para>
					Free an expression parse tree. If it was bound
					to the passed-in <literal>ocrpt_report</literal>,
					this association is also deleted. Alternatively,
					the expression doesn't need to be free if it was
					bound to a report when it was parsed, as it will be
					automatically freed when freeing either the report,
					or the global <literal>opencreport</literal> structure.
					<programlisting>void
ocrpt_expr_free(opencreport *o,
                ocrpt_report *r,
                ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve expression references</title>
				<para>
					This function resolves variable (identifier)
					references in the expression. This is needed
					to bind query columns to expressions that
					use them.
					<programlisting>void
ocrpt_expr_resolve(opencreport *o,
                   ocrpt_report *r,
                   ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Optimize an expression</title>
				<para>
					This function optimizes an expression so
					it may needs fewer computation steps during
					report execution.
					<programlisting>void
ocrpt_expr_optimize(opencreport *o,
                    ocrpt_report *r,
                    ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate an expression</title>
				<para>
					This function evaluates the expression.
					It returns the expression's
					<literal>ocrpt_result</literal> result structure.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>
				</para>
				<para>
					For expressions with query column references,
					this function must be called after
					<literal>ocrpt_query_navigate_next</literal>
					otherwise the result is not valid.
					<programlisting>ocrpt_result *
ocrpt_expr_eval(opencreport *o,
                ocrpt_report *r,
                ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get expression result without evaluation</title>
				<para>
					This function returns the expression result
					if it was already evaluated.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>.
					Used by unit tests.
					<programlisting>ocrpt_result *
ocrpt_expr_get_result(opencreport *o,
                      ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree</title>
				<para>
					Print an expression tree in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_print(opencreport *o,
                 ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree with subexpressions and their results</title>
				<para>
					Print an expression tree with subexpressions
					and their results in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_result_deep_print(opencreport *o,
                             ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Count the number of expression nodes</title>
				<para>
					This function returns the number of expression nodes.
					Used by unit tests to validate optimizazion.
					<programlisting>int32_t
ocrpt_expr_nodes(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Initialize expression result type</title>
				<para>
					OpenCReports keeps track of the last three query
					rows and computes three result values for expressions
					for internal reasons. These functions initialize
					the type for either the current result or all results
					of the expression.
					<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

bool ocrpt_expr_init_result(opencreport *o,
                            ocrpt_expr *e,
                            enum ocrpt_result_type type);

void ocrpt_expr_init_results(opencreport *o,
                             ocrpt_expr *e,
                             enum ocrpt_result_type type);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set an error string as expression result</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_expr_make_error_result(opencreport *o,
                             ocrpt_expr *e,
                             const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set start value flag for an iterative expression</title>
				<para>
					Set whether the iterative expression's first
					value is computed from its base expression
					or from its result expression.
					<programlisting>void
ocrpt_expr_set_iterative_start_value(ocrpt_expr *e,
                                     bool start_with_init);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get current value of an expression in base type</title>
				<para>
					Get the current value of an expression in a C base
					type. Used by parsing report description XML files
					and unit tests.
					<programlisting>const char *
ocrpt_expr_get_string_value(opencreport *o,
                            ocrpt_expr *e);

long
ocrpt_expr_get_long_value(opencreport *o,
                          ocrpt_expr *e);

double
ocrpt_expr_get_double_value(opencreport *o,
                            ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set current value of an expression in a base type</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_expr_set_string_value(opencreport *o,
                            ocrpt_expr *e,
                            const char *s);

void
ocrpt_expr_set_long_value(opencreport *o,
                          ocrpt_expr *e,
                          long l);

void
ocrpt_expr_set_double_value(opencreport *o,
                            ocrpt_expr *e,
                            double d);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set nth value of an expression in a base type</title>
				<para>
					Expressions use <literal>OCRPT_EXPR_RESULTS</literal>
					number of values. With these functions, any of them
					can be set. Used by unit tests.
					<programlisting>void
ocrpt_expr_set_nth_result_string_value(opencreport *o,
                                       ocrpt_expr *e,
                                       int which,
                                       const char *s);

void
ocrpt_expr_set_nth_result_long_value(opencreport *o,
                                     ocrpt_expr *e,
                                     int which,
                                     long l);

void
ocrpt_expr_set_nth_result_double_value(opencreport *o,
                                       ocrpt_expr *e,
                                       int which,
                                       double d);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Compare current and previous values of and expression</title>
				<para>
					Compare current and previous values of and expression
					and return <literal>true</literal> if they are equal.
					It's used to implement <xref linkend="breaks"/>.
					<programlisting>bool
ocrpt_expr_cmp_results(opencreport *o,
                       ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set delayed flag of an expression</title>
				<para>
					<programlisting>void
ocrpt_expr_set_delayed(opencreport *o,
                       ocrpt_expr *e,
                       bool delayed);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set field expression reference for an expression</title>
				<para>
					If <literal>e</literal> contains <literal>r.value</literal>,
					the expression <literal>rvalue</literal> will be used to
					resolve this reference.
					<programlisting>void
ocrpt_expr_set_field_expr(opencreport *o,
                          ocrpt_expr *e,
                          ocrpt_expr *rvalue);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Column data or expression result related functions</title>
			<para>
				The internal type <literal>ocrpt_result</literal> holds
				values either for query columns or expression results.
			</para>
			<sect3>
				<title>Create an expression result</title>
				<para>
					The returned pointer must be freed with
					<literal>ocrpt_result_free()</literal>.
					<programlisting>ocrpt_result *
ocrpt_result_new(void);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get expression result type</title>
				<para>
					<programlisting>enum ocrpt_result_type
ocrpt_result_get_type(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Copy an expression result</title>
				<para>
					Some internal data is specific to the
					<literal>opencreport</literal> structure.
					<programlisting>void
ocrpt_result_copy(opencreport *o,
                  ocrpt_result *dst,
                  ocrpt_result *src);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression result</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_result_print(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free an expression result</title>
				<para>
					<programlisting>void
ocrpt_result_free(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is NULL</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is NULL.
					<programlisting>bool
ocrpt_result_isnull(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is numeric</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is numeric.
					<programlisting>bool
ocrpt_result_isnumber(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the numeric value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the numeric column value. It returns  NULL
					if the column is:
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a numeric result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>mpfr_ptr
ocrpt_result_get_number(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is string</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is string.
					<programlisting>bool
ocrpt_result_isstring(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the string value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the string column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a string result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>ocrpt_string *
ocrpt_result_get_string(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is datetime</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is datetime.
					<programlisting>bool
ocrpt_result_isdatetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the datetime value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the datetime column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a datetime result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>const struct tm *
ocrpt_result_get_datetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a datetime column result is interval</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value is interval.
					<programlisting>bool
ocrpt_result_datetime_is_interval(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a datetime column result has valid date</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid date.
					<programlisting>bool
ocrpt_result_datetime_is_date_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a datetime column result has valid time</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid time.
					<programlisting>bool
ocrpt_result_datetime_is_time_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Variable related functions</title>
			<para>
				Variables can be created for a report using
				the API.
			</para>
			<sect3>
				<title>Create a basic variable</title>
				<para>
					Using this function, any variable type except
					<literal>OCRPT_VARIABLE_CUSTOM</literal>
					may be created. For a custom variable,
					see the next function.
					<programlisting>enum ocrpt_var_type {
    OCRPT_VARIABLE_EXPRESSION,
    OCRPT_VARIABLE_COUNT,
    OCRPT_VARIABLE_COUNTALL,
    OCRPT_VARIABLE_SUM,
    OCRPT_VARIABLE_AVERAGE,
    OCRPT_VARIABLE_AVERAGEALL,
    OCRPT_VARIABLE_LOWEST,
    OCRPT_VARIABLE_HIGHEST,
    OCRPT_VARIABLE_CUSTOM
};
typedef enum ocrpt_var_type ocrpt_var_type;

ocrpt_var *
ocrpt_variable_new(opencreport *o,
                   ocrpt_report *r,
                   ocrpt_var_type type,
                   const char *name,
                   const char *expr,
                   const char *reset_on_break_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a custom variable</title>
				<para>
					Create a custom variable of the specified type
					with the specified subexpressions.
					<programlisting>ocrpt_var *
ocrpt_variable_new_full(opencreport *o,
                        ocrpt_report *r,
                        enum ocrpt_result_type type,
                        const char *name,
                        const char *baseexpr,
                        const char *intermedexpr,
                        const char *intermed2expr,
                        const char *resultexpr,
                        const char *reset_on_break_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get subexpressions of a variable</title>
				<para>
					Get subexpressions of a previously created
					basic or custom variable.
					<programlisting>ocrpt_expr *
ocrpt_variable_baseexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermedexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermed2expr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_resultexpr(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set precalculate flag for a variable</title>
				<para>
					<programlisting>void
ocrpt_variable_set_precalculate(ocrpt_var *var, 
                                bool value);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve a variable</title>
				<para>
					Resolve subexpressions of a variable
					so it can be evaluated correctly.
					<programlisting>void
ocrpt_variable_resolve(opencreport *o,
                       ocrpt_report *r,
                       ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate a variable</title>
				<para>
					After evaluation, the result is in the
					expression returned by
					<literal>ocrpt_variable_resultexpr()</literal>.
					<programlisting>void
ocrpt_variable_evaluate(opencreport *o,
                        ocrpt_report *r, ocrpt_var *v);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Break related functions</title>
			<sect3>
				<title>Create a break</title>
				<para>
					Create a break. No need to free it,
					<literal>ocrpt_free()</literal> does it.
					<programlisting>ocrpt_break *
ocrpt_break_new(opencreport *o,
                ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set attribute flags for a break</title>
				<para>
					Set boolean attribute flags for a break,
					either via explicit boolean value, or from
					an expression. The flags are not actually used,
					they are for RLIB compatibility.
					<programlisting>enum ocrpt_break_attr_type {
    OCRPT_BREAK_ATTR_NEWPAGE,
    OCRPT_BREAK_ATTR_HEADERNEWPAGE,
    OCRPT_BREAK_ATTR_SUPPRESSBLANK,
    OCRPT_BREAK_ATTRS_COUNT
};
typedef enum ocrpt_break_attr_type ocrpt_break_attr_type;

bool
ocrpt_break_set_attribute(opencreport *o,
                          ocrpt_report *r,
                          ocrpt_break *br,
                          const ocrpt_break_attr_type attr_type,
                          bool value);

bool
ocrpt_break_set_attribute_from_expr(opencreport *o,
                                    ocrpt_report *r,
                                    ocrpt_break *br,
                                    const ocrpt_break_attr_type attr_type,
                                    ocrpt_expr *expr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get break using its name</title>
				<para>
					Get the pointer to the break using its name.
					<programlisting>ocrpt_break *
ocrpt_break_get(opencreport *o,
                ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the name of a break</title>
				<para>
					Get the name of the break using its structure
					pointer.
					<programlisting>const char *
ocrpt_break_get_name(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a watched expression to a break</title>
				<para>
					<programlisting>bool
ocrpt_break_add_breakfield(opencreport *o,
                           ocrpt_report *r,
                           ocrpt_break *br,
                           ocrpt_expr *bf);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Iterate over breaks of a report</title>
				<para>
					Iterate over breaks of a report. The first call
					needs the iterator list pointer to be set to NULL.
					<programlisting>ocrpt_break *
ocrpt_break_get_next(ocrpt_report *r,
                     ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve and optimize break fields</title>
				<para>
					<programlisting>void
ocrpt_break_resolve_fields(opencreport *o,
                           ocrpt_report *r,
                           ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Check whether the break triggers</title>
				<para>
					<programlisting>bool
ocrpt_break_check_fields(opencreport *o,
                         ocrpt_report *r,
                         ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Reset variables for the break</title>
				<para>
					<programlisting>void
ocrpt_break_reset_vars(opencreport *o,
                       ocrpt_report *r,
                       ocrpt_break *br);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Function related functions</title>
			<sect3>
				<title>Add a user defined function</title>
				<para>
					Add a user defined function by specifying
					the name, the function pointer that contains
					the implementation, the number of operands
					(0 or greater for fixed number or operands,
					-1 is varying number of operands) and
					the function mathematical properties
					that help optimizing it.
					<programlisting>bool
ocrpt_function_add(opencreport *o,
                   const char *fname,
                   ocrpt_function_call func,
                   int32_t n_ops,
                   bool commutative,
                   bool associative,
                   bool left_associative,
                   bool dont_optimize);</programlisting>
				</para>
				<para>
					Adding a user defined function with
					a name of a pre-existing function will
					override it.
				</para>
				<para>
					OpenCReports functions are called with the
					parameters as declared below.
					<programlisting>#define OCRPT_FUNCTION_PARAMS \
    opencreport *o, \
    ocrpt_report *r OCRPT_UNUSED_PARAM, \
    ocrpt_expr *e</programlisting>
				</para>
				<para>
					OpenCReports functions may be declared
					with these convenience symbols below.
					<programlisting>#define OCRPT_FUNCTION(name) \
    void name(OCRPT_FUNCTION_PARAMS)

#define OCRPT_STATIC_FUNCTION(name) \
    static void name(OCRPT_FUNCTION_PARAMS)</programlisting>
				</para>
				<para>
					The above function
					(<literal>ocrpt_function_add()</literal>)
					is called with a function pointer which has
					this type:
					<programlisting>typedef void
(*ocrpt_function_call)(OCRPT_FUNCTION_PARAMS);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Find a named function</title>
				<para>
					<programlisting>const ocrpt_function *
ocrpt_function_get(opencreport *o,
                   const char *fname);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get number of operands for an expression (function)</title>
				<para>
					In an expression tree, functions
					are represented as subexpressions with
					operands. This call may be used by OpenCReports
					functions to inspect whether the number of
					operands is in the expected range.
					<programlisting>int32_t
ocrpt_expr_get_num_operands(ocrpt_expr *e);
</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get current value of a function operand</title>
				<para>
					This function is used by OpenCReports functions
					internally to compute the result from its
					operands.
					<programlisting>ocrpt_result *
ocrpt_expr_operand_get_result(opencreport *o,
                              ocrpt_expr *e,
                              int32_t opnum);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Report part and report related functions</title>
			<sect3>
				<title>Create a report part</title>
				<para>
					<programlisting>ocrpt_part *
ocrpt_part_new(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a row in a report part</title>
				<para>
					<programlisting>ocrpt_part_row *
ocrpt_part_new_row(opencreport *o,
                   ocrpt_part *p);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a column in report part row</title>
				<para>
					<programlisting>ocrpt_part_row_data *
ocrpt_part_row_new_data(opencreport *o,
                        ocrpt_part *p,
                        ocrpt_part_row *pr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a new report</title>
				<para>
					<programlisting>ocrpt_report *
ocrpt_report_new(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append the new report to a column</title>
				<para>
					<programlisting>ocrpt_part *
ocrpt_part_append_report(opencreport *o,
                         ocrpt_part *p,
                         ocrpt_part_row *pr,
                         ocrpt_part_row_data *pd,
                         ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Report part related iterators</title>
				<para>
					Iterators for getting report parts, part rows,
					columns in rows and reports in columns.
					Every iterator function must be called
					the first time with the list pointer set to NULL.
					<programlisting>ocrpt_part *
ocrpt_part_get_next(opencreport *o,
                    ocrpt_list **list);

ocrpt_part_row *
ocrpt_part_row_get_next(ocrpt_part *p,
                        ocrpt_list **list);

ocrpt_part_row_data *
ocrpt_part_row_data_get_next(ocrpt_part_row *pr,
                             ocrpt_list **list);

ocrpt_report *
ocrpt_report_get_next(ocrpt_part_row_data *pd,
                      ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set the main query for a report</title>
				<para>
					Set the main query for a report either by
					the query structure pointer, or by name.
					<programlisting>void
ocrpt_report_set_main_query(opencreport *o,
                            ocrpt_report *r,
                            const ocrpt_query *query);

void
ocrpt_report_set_main_query_by_name(opencreport *o,
                                    ocrpt_report *r,
                                    const char *query);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the current row number of the main query</title>
				<para>
					The row number starts from 1.
					<programlisting>long
ocrpt_report_get_query_rownum(opencreport *o,
                              ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_variables(opencreport *o,
                               ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_variables(opencreport *o,
                                ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve all report breaks</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_breaks(opencreport *o,
                            ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_expressions(opencreport *o,
                                 ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_expressions(opencreport *o,
                                  ocrpt_report *r);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Callback related functions</title>
			<para>
				Certain stages of the report execution can
				notify the application about the stage
				being executed or finished.
			</para>
			<para>
				Every "add a callback" function below return
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
			</para>
			<sect3>
				<title>Add a "part added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_part_cb)(opencreport *,
                 ocrpt_part *,
                 void *data);

bool
ocrpt_add_part_added_cb(opencreport *o,
                        ocrpt_part_cb func,
                        void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_report_cb)(opencreport *,
                   ocrpt_report *,
                   void *data);

bool
ocrpt_add_report_added_cb(opencreport *o,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "part iteration" callback</title>
				<para>
					<programlisting>bool
ocrpt_add_part_iteration_cb(opencreport *o,
                            ocrpt_part_cb func,
                            void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an "all precalculations done" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_cb)(opencreport *,
            void *data);

bool
ocrpt_add_precalculation_done_cb(opencreport *o,
                                 ocrpt_cb func,
                                 void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report started" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_start_cb(opencreport *o,
                          ocrpt_report *r,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_done_cb(opencreport *o,
                         ocrpt_report *r,
                         ocrpt_report_cb func,
                         void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "new row" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_new_row_cb(opencreport *o,
                            ocrpt_report *r,
                            ocrpt_report_cb func,
                            void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report iteration done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_iteration_cb(opencreport *o,
                              ocrpt_report *r,
                              ocrpt_report_cb func,
                              void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report precalculation done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_precalculation_done_cb(opencreport *o,
                                        ocrpt_report *r,
                                        ocrpt_report_cb func,
                                        void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "break triggers" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_break_trigger_cb)(opencreport *,
                          ocrpt_report *,
                          ocrpt_break *,
                          void *);

bool
ocrpt_break_add_trigger_cb(opencreport *o,
                           ocrpt_report *r,
                           ocrpt_break *br,
                           ocrpt_break_trigger_cb func,
                           void *data);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Environment related functions</title>
			<sect3>
				<title>Indirect function to get an environment variable</title>
				<para>
					<programlisting>typedef ocrpt_result *
(*ocrpt_environment_query_func)(const char *);

extern ocrpt_environment_query_func
ocrpt_environment_get;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set the environment query function</title>
				<para>
					<programlisting>void
ocrpt_environment_set_query_func(ocrpt_environment_query_func func);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>C API environment query function</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_environment_get_c(const char *env);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>File handling related functions</title>
			<sect3>
				<title>Return a canonical file path</title>
				<para>
					The returned path contains only single
					directory separators and doesn't contains
					symlinks.
					<programlisting>char *
ocrpt_canonicalize_path(const char *path);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add search path</title>
				<para>
					Add a new directory path to the list of
					search paths. It's useful to find files
					referenced with relative path.
					<programlisting>void
ocrpt_add_search_path(opencreport *o,
                      const char *path);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Find a file</title>
				<para>
					Find a file and return the canonicalized path to it.
					This function takes the search paths into account.
					<programlisting>char *
ocrpt_find_file(opencreport *o,
                const char *filename);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Color related functions</title>
			<sect3>
				<title>Find a color by its name</title>
				<para>
					The function fills in the
					<literal>ocrpt_color</literal> structure with
					RGB values in Cairo values (0.0 ... 1.0).
				</para>
				<para>
					If the color name starts with
					<literal>#</literal> or <literal>0x</literal> or
					<literal>0X</literal> then it must be in HTML
					notation.
				</para>
				<para>
					Otherwise, the color name is looked up in the
					color name database in a case insensitive way.
					If found, the passed-in ocrpt_color structure is
					filled with the RGB color value of that name.
				</para>
				<para>
					If not found or the passed-in color name is NULL,
					depending on the the expected usage (foreground
					or background color), the <literal>ocrpt_color</literal>
					structure is filled with either white or black.
					<programlisting>void
ocrpt_get_color(opencreport *o,
                const char *cname,
                ocrpt_color *color,
                bool bgcolor);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Paper size related functions</title>
			<para>
				Paper size in OpenCReports is handled via
				<ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>.
			</para>
			<para>
				This structure is used in OpenCReports to represent
				paper name and size:
				<programlisting>struct ocrpt_paper {
    const char *name;
    double width;
    double height;
};
typedef struct ocrpt_paper ocrpt_paper;</programlisting>
			</para>
			<sect3>
				<title>Get the system default paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_system_paper(void);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the paper specified by name</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper_by_name(const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set the global paper</title>
				<para>
					Set global paper using an
					<literal>ocrpt_paper</literal> structure.
					The contents of the structure is copied.
					<programlisting>void
ocrpt_set_paper(opencreport *o,
                const ocrpt_paper *paper);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set global paper specified by name</title>
				<para>
					Set paper for the report using a paper name.
					If the paper name is unknown, the system default paper is set.
					<programlisting>void
ocrpt_set_paper_by_name(opencreport *o,
                        const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get currently set global paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Iterate over paper sizes</title>
				<para>
					Get the next <literal>ocrpt_paper</literal> structure
					in the iterator. For the first call, the iterator
					pointer must be NULL. It returns NULL when there are
					no more papers known to the system.
					<programlisting>const ocrpt_paper *
ocrpt_paper_next(opencreport *o,
                 void **iter);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Memory handling related functions</title>
			<para>
				Memory handling is done through an indirection,
				to help with bindings (that may do their own memory
				handling) override the default.
			</para>
			<sect3>
				<title>Indirect function pointers</title>
				<para>
					<programlisting>typedef void *
(*ocrpt_mem_malloc_t)(size_t);

typedef void *
(*ocrpt_mem_realloc_t)(void *,
                       size_t);

typedef void *
(*ocrpt_mem_reallocarray_t)(void *,
                            size_t,
                            size_t);

typedef void
(*ocrpt_mem_free_t)(const void *);

typedef char *
(*ocrpt_mem_strdup_t)(const char *);

typedef char *
(*ocrpt_mem_strndup_t)(const char *,
                       size_t);

typedef void
(*ocrpt_mem_free_size_t)(void *,
                         size_t);

extern ocrpt_mem_malloc_t ocrpt_mem_malloc0;
extern ocrpt_mem_realloc_t ocrpt_mem_realloc0;
extern ocrpt_mem_reallocarray_t ocrpt_mem_reallocarray0;
extern ocrpt_mem_free_t ocrpt_mem_free0;
extern ocrpt_mem_strdup_t ocrpt_mem_strdup0;
extern ocrpt_mem_strndup_t ocrpt_mem_strndup0;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Allocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_malloc(size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Reallocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_realloc(void *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Reallocate array of memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_reallocarray(void *ptr,
                       size_t nmemb,
                       size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free memory</title>
				<para>
					<programlisting>void
ocrpt_mem_free(const void *ptr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Duplicate C string</title>
				<para>
					<programlisting>void *
ocrpt_mem_strdup(const char *ptr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Duplicate C string up to the specified length</title>
				<para>
					<programlisting>void *
ocrpt_mem_strndup(const char *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a C string</title>
				<para>
					It'a convenience alias for
					<literal>ocrpt_mem_free()</literal>.
					<programlisting>void
ocrpt_strfree(const char *s);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set indirect allocation functions</title>
				<para>
					<programlisting>void
ocrpt_mem_set_alloc_funcs(ocrpt_mem_malloc_t rmalloc,
                          ocrpt_mem_realloc_t rrealloc,
                          ocrpt_mem_reallocarray_t rreallocarray,
                          ocrpt_mem_free_t rfree,
                          ocrpt_mem_strdup_t rstrdup,
                          ocrpt_mem_strndup_t rstrndup);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>List related functions</title>
			<para>
				These functions implement a single linked list.
				The list element structure is hidden:
				<programlisting>struct ocrpt_list;
typedef struct ocrpt_list ocrpt_list;</programlisting>
			</para>
			<sect3>
				<title>Get the list length</title>
				<para>
					<programlisting>size_t
ocrpt_list_length(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Make a list from one element</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_makelist1(const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Make a list from multiple elements</title>
				<para>
					This function can be used with variable
					number of arguments.
					<programlisting>ocrpt_list *
ocrpt_makelist(const void *data1, ...);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the last element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_last(const ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the nth element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_nth(const ocrpt_list *l, uint32_t n);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_append(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append to list using the last element</title>
				<para>
					This function make appending to the list work
					<emphasis>O(1)</emphasis> instead of
					<emphasis>O(n)</emphasis>.
					<programlisting>ocrpt_list *
ocrpt_list_end_append(ocrpt_list *l,
                      ocrpt_list **e,
                      const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Prepend a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_prepend(ocrpt_list *l,
                   const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Remove a data element from a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_remove(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the data element from a list</title>
				<para>
					<programlisting>void *
ocrpt_list_get_data(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a list</title>
				<para>
					<programlisting>void
ocrpt_list_free(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a list and its data elements</title>
				<para>
					<programlisting>void
ocrpt_list_free_deep(ocrpt_list *l,
                     ocrpt_mem_free_t freefunc);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>String related functions</title>
			<para>
				For memory safety and higher performance, a wrapper
				structure is used over C functions.
				<programlisting>struct ocrpt_string {
    char *str;
    size_t allocated_len;
    size_t len;
};
typedef struct ocrpt_string ocrpt_string;</programlisting>
			</para>
			<sect3>
				<title>Create a new string</title>
				<para>
					Create a new string from a C string.
					The ownership of the input string may be
					taken over, or the original string's contents
					are copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new(const char *str,
                     bool copy);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a new string with specified allocated length</title>
				<para>
					Create a new string with specified allocated length
					so future growth can be done without reallocation.
					The input string is always copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_with_len(const char *str,
                              size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a string from a formatted string with maximum length</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_vnprintf(size_t len,
                              const char *format,
                              va_list va);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a string from a formatted string</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_printf(const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resize a string</title>
				<para>
					Resize the string to the specified allocated
					length.
					<programlisting>ocrpt_string *
ocrpt_mem_string_resize(ocrpt_string *string,
                        size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a string</title>
				<para>
					<programlisting>char *
ocrpt_mem_string_free(ocrpt_string *string,
                      bool free_str);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a C string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len(ocrpt_string *string,
                            const char *str,
                            const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a binary string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len_binary(ocrpt_string *string,
                                   const char *str,
                                   const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a C string of unspecified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append(ocrpt_string *string,
                        const char *str);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a byte to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_c(ocrpt_string *string,
                          const char c);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a formatted string to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_printf(ocrpt_string *string,
                               const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
</chapter>

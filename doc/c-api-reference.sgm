<chapter id="c-api-reference" xreflabel="C API Reference">
	<title>C language API reference</title>
	<sect1>
		<title>Header file</title>
		<para>
			For using OpenCReports, this single header must be used:
			<programlisting>#include &lt;opencreport.h&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="highlevelapi" xreflabel="High level C API">
		<title>High level C API</title>
		<para>
			Example code using the high level C API where everything
			concerning the report (including the data source)
			is described in the report XML:
			<programlisting>#include &lt;opencreport.h&gt;

int main(void) {
    opencreport *o = ocrpt_init();

    if (!ocrpt_parse_xml(o, "report.xml")) {
        printf("XML parse error\n");
        ocrpt_free(o);
        return 1;
    }

    ocrpt_set_output_format(o, OCRPT_OUTPUT_PDF);
    ocrpt_execute(o);
    ocrpt_spool(o);
    ocrpt_free(o);
    return 0;
}</programlisting>
		</para>
		<para>
			The above code will load <literal>report.xml</literal>,
			set the output format to PDF, runs the report and prints
			its output on <literal>stdout</literal>.
		</para>
		<sect2>
			<title>Report handler initialization</title>
			<para>
				<programlisting>opencreport *
ocrpt_init(void);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Load a report XML description</title>
			<para>
				This function loads the specified XML file
				into the report handler. It returns
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
				<programlisting>bool
ocrpt_parse_xml(opencreport *o,
                const char *filename);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Parse report XML description from a buffer</title>
			<para>
				This function parses the buffer as if it contained
				XML contents and loads the details into the report handler.
				It returns <literal>true</literal> for success,
				<literal>false</literal> for failure.
				<programlisting>bool
ocrpt_parse_xml_from_buffer(opencreport *o,
                            const char *buffer,
                            size_t size);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Set report output format</title>
			<para>
				<programlisting>enum ocrpt_format_type {
    OCRPT_OUTPUT_UNSET,
    OCRPT_OUTPUT_PDF,
    OCRPT_OUTPUT_HTML,
    OCRPT_OUTPUT_TXT,
    OCRPT_OUTPUT_CSV,
    OCRPT_OUTPUT_XML
};
typedef enum ocrpt_format_type ocrpt_format_type;

void
ocrpt_set_output_format(opencreport *o,
                        ocrpt_format_type format);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Run the report</title>
			<para>
				This function executes the report, constructs
				the result in memory. It returns <literal>true</literal>
				for success, <literal>false</literal> for failure.
				It is a failure if the output format is unset.
				<programlisting>bool
ocrpt_execute(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Dump report result</title>
			<para>
				Dump the report output on the program's
				standard output channel.
				<programlisting>void
ocrpt_spool(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Get report result</title>
			<para>
				Get the report output. The application
				then can save it as a file.
				<programlisting>char *
ocrpt_get_output(opencreport *o, size_t *length);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Report handler destruction</title>
			<para>
				Calling this function frees up the report handler
				structure and everything created for it, even
				the details that were created by the low level API.
				<programlisting>void
ocrpt_free(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Get library version</title>
			<para>
				This function reports the OpenCReports
				library version.
				<programlisting>const char *
ocrpt_version(void);</programlisting>
			</para>
		</sect2>
	</sect1>
	<sect1 id="lowlevelapi" xreflabel="Low level C API">
		<title>Low level C API</title>
		<para>
			The <xref linkend="highlevelapi"/> is also part of the
			low level API. The functions described below allow
			creating a report using program code, or simply
			fine tuning the report behavior by mostly using the
			<xref linkend="highlevelapi"/>.
		</para>
		<sect2 id="numerictuning" xreflabel="Numeric behavior related functions">
			<title>Numeric behavior related functions</title>
			<sect3>
				<title><literal>Set numeric precision</literal></title>
				<para>
					The default is 256 bits of floating point precision.
					<programlisting>void
ocrpt_set_numeric_precision_bits(opencreport *o,
                                 mpfr_prec_t prec);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set rounding mode</title>
				<para>
					OpenCReports uses GNU MPFR under the hood and doesn't
					hide this fact. The MPFR rounding mode constants are
					used as is to set the rounding behaviour.
					The default is <literal>MPFR_RNDN</literal>, round
					to nearest.
					<programlisting>void
ocrpt_set_rounding_mode(opencreport *o,
                        mpfr_rnd_t rndmode);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Locale related functions</title>
			<sect3>
				<title>Set up translation</title>
				<para>
					Setting up the translation needs two parameters:
					the so called <emphasis>translation domain</emphasis>
					and the toplevel directory for the translations.
					It relies on GNU Gettext.
					<programlisting>void
ocrpt_bindtextdomain(opencreport *o,
                     const char *domainname,
                     const char *dirname);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set report locale</title>
				<para>
					Setting the locale for the report does not affect
					the main program or other threads. Locale setting
					includes the language, the country. The UTF-8 suffix
					is necessary. E.g.: <literal>en_GB.UTF-8</literal> or
					<literal>de_DE.UTF-8</literal>
					<programlisting>void
ocrpt_set_locale(opencreport *o,
                 const char *locale);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print monetary data in the report locale</title>
				<para>
					A customized monetary printing function was implemented
					for the purposes of the report which MPFR doesn't
					provide. It is used in OpenCReports both internally
					and by unit tests.
					<programlisting>ssize_t
ocrpt_mpfr_strfmon(opencreport *o,
                   char *s, size_t maxsize,
                   const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Data source and query related functions</title>
			<para>
				The following <literal>enum</literal> and
				<literal>struct</literal> types are used by
				OpenCReports for datasources and queries.
				<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

struct ocrpt_datasource;
typedef struct ocrpt_datasource ocrpt_datasource;

struct ocrpt_query;
typedef struct ocrpt_query ocrpt_query;

struct ocrpt_query_result;
typedef struct ocrpt_query_result ocrpt_query_result;

struct ocrpt_input {
    void (*describe)(ocrpt_query *,
                     ocrpt_query_result **,
                     int32_t *);
    void (*rewind)(ocrpt_query *);
    bool (*next)(ocrpt_query *);
    bool (*populate_result)(ocrpt_query *);
    bool (*isdone)(ocrpt_query *);
    void (*free)(ocrpt_query *);
    bool (*set_encoding)(ocrpt_datasource *,
                         const char *);
    void (*close)(const ocrpt_datasource *);
};
typedef struct ocrpt_input ocrpt_input;</programlisting>
			</para>
			<para>
				Data sources in this context are "mini drivers".
				Data source handling is implemented via
				<literal>ocrpt_input</literal> functions.
			</para>
			<para>
				Queries are data providers over data sources. They are
				the actual sources of data using a specific data source.
				Multiple queries may use the same data source.
			</para>
			<sect3>
				<title>Add an array datasource</title>
				<para>
					Add an array datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_array(opencreport *o,
                           const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Test whether a datasource is array based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_array(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an array query</title>
				<para>
					Add an "array query" to the report handler.
					This adds the array pointer and parameters, so
					the array datasource input driver can use it.
					The provided <literal>array</literal> array pointer
					contains <literal>(rows + 1) * cols</literal> number of
					<literal>char *</literal> pointers, with the first row
					being the column (field) names. The
					<literal>types</literal> array contains
					<literal>cols</literal> number of
					<literal>enum ocrpt_result_type</literal> elements to
					indicate the column data type.
					<programlisting>ocrpt_query *
ocrpt_query_add_array(ocrpt_datasource *source,
                      const char *name,
                      const char **array,
                      int32_t rows, int32_t cols,
                      const int32_t *types,
                      int32_t types_cols);</programlisting>
				</para>
				<para>
					If the <literal>types</literal> pointer is
					<literal>NULL</literal>, the column values are treated
					as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3>
				<title>Add a CSV datasource</title>
				<para>
					Add a CSV datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_csv(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Test whether a datasource is CSV based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_csv(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a CSV query</title>
				<para>
					Add a "CSV query" to the report handler.
					This specifies the file name, so
					the CSV datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_csv(ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const int32_t *types,
                    int32_t types_cols);</programlisting>
				</para>
				<para>
					The <literal>types</literal> array pointer is optional.
					If it is <literal>NULL</literal>, the column values are
					treated as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3>
				<title>Add a JSON datasource</title>
				<para>
					Add a JSON datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_json(opencreport *o,
                          const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Test whether a datasource is JSON based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_json(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a JSON query</title>
				<para>
					Add a "JSON query" to the report handler.
					This specifies the file name, so
					the JSON datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_json(ocrpt_datasource *source,
                     const char *name,
                     const char *filename,
                     const int32_t *types,
                     int32_t types_cols);</programlisting>
				</para>
				<para>
					The JSON file format defined in <xref linkend="jsonds"/>
					contains the way to describe the column data types,
					which is optional in a JSON file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the JSON file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the JSON file doesn't
					contain type specifiers), the column values are
					treated as strings. RLIB didn't have JSON input.
				</para>
			</sect3>
			<sect3>
				<title>Add an XML datasource</title>
				<para>
					Add an XML datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_xml(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Test whether a datasource is XML based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_xml(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an XML query</title>
				<para>
					Add an "XML query" to the report handler.
					This specifies the file name, so
					the XML datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_xml(ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const int32_t *types,
                    int32_t types_cols);</programlisting>
				</para>
				<para>
					The XML file format defined in <xref linkend="xmlds"/>
					contains the way to describe the column data types,
					which is optional in an XML file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the XML file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the XML file doesn't
					contain type specifiers), the column values are
					treated as strings. This is how RLIB operated.
					The OpenCReports XML input file format is RLIB
					compatible without the type specification part.
				</para>
			</sect3>
			<sect3>
				<title>Add a PostgreSQL datasource</title>
				<para>
					Add a PostgreSQL datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_postgresql(opencreport *o,
                                const char *source_name,
                                const char *host,
                                const char *port,
                                const char *dbname,
                                const char *user,
                                const char *password);

ocrpt_datasource *
ocrpt_datasource_add_postgresql2(opencreport *o,
                                 const char *source_name,
                                 const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="postgresqlds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Test whether a datasource is PostgreSQL based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_postgresql(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a PostgreSQL query</title>
				<para>
					Add a SQL query using the PostgreSQL datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_postgresql(ocrpt_datasource *source,
                           const char *name,
                           const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a MariaDB datasource</title>
				<para>
					Add a MariaDB datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_mariadb(opencreport *o,
                             const char *source_name,
                             const char *host,
                             const char *port,
                             const char *dbname,
                             const char *user,
                             const char *password,
                             const char *unix_socket);

ocrpt_datasource *
ocrpt_datasource_add_mariadb2(opencreport *o,
                              const char *source_name,
                              const char *optionfile,
                              const char *group);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="mariadbds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Test whether a datasource is MariaDB based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_mariadb(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a MariaDB query</title>
				<para>
					Add an SQL query using the MariaDB datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_mariadb(ocrpt_datasource *source,
                        const char *name,
                        const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an ODBC datasource</title>
				<para>
					Add an ODBC datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_odbc(opencreport *o,
                          const char *source_name,
                          const char *dbname,
                          const char *user,
                          const char *password);

ocrpt_datasource *
ocrpt_datasource_add_odbc2(opencreport *o,
                           const char *source_name,
                           const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="odbcds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Test whether a datasource is ODBC based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_odbc(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an ODBC query</title>
				<para>
					Add an SQL query using the ODBC datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_odbc(ocrpt_datasource *source,
                     const char *name,
                     const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Find a datasource</title>
				<para>
					Find the data source using its name.
					It returns NULL if the named data source
					is not found.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_get(opencreport *o,
                     const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add a custom datasource</literal></title>
				<para>
					Add a custom data source to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_add_datasource(opencreport *o,
                     const char *source_name,
                     const ocrpt_input *input);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Set the encoding of a datasource</literal></title>
				<para>
					Set the encoding of a datasource in case
					if it's not already UTF-8, so data provided by
					it is automatically converted.
					<programlisting>void
ocrpt_datasource_set_encoding(ocrpt_datasource *source,
                              const char *encoding);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Free a datasource</literal></title>
				<para>
					Free a datasource from the opencreport structure
					it was added to. It's not needed to be called,
					all datasources are automatically free with
					<literal>ocrpt_free()</literal>
					<programlisting>void
ocrpt_datasource_free(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Find a query</literal></title>
				<para>
					Find a query using its name.
					<programlisting>ocrpt_query *
ocrpt_query_get(opencreport *o,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get the current data row from a query</literal></title>
				<para>
					Create (first call) or get the <literal>ocrpt_query_result</literal>
					array from a query. Output parameter <literal>cols</literal>
					returns the number of columns in the result array. It must
					be re-run after ocrpt_navigate_next() since the previously
					returned pointer becomes invalid.
					<programlisting>ocrpt_query_result *
ocrpt_query_get_result(ocrpt_query *q,
                       int32_t *cols);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get column name</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal> result
					from <literal>ocrpt_query_get_result()</literal>,
					the column names can be discovered from a query.
					<programlisting>const char *
ocrpt_query_result_column_name(ocrpt_query_result *qr,
                               int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get column data</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal>
					result from
					<literal>ocrpt_query_get_result()</literal>, get a
					pointer to the column data in its internal (hidden)
					representation.
					<programlisting>ocrpt_result *
ocrpt_query_result_column_result(ocrpt_query_result *qr,
                                 int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add a follower query</literal></title>
				<para>
					Add a <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and the follower will run in parallel with it until
					the leader runs out of rows. In case the leader has more
					rows than the follower, then for rows in the leader where
					there are no follower rows, the follower fields are set to NULL.
					<programlisting>bool
ocrpt_query_add_follower(ocrpt_query *leader,
                         ocrpt_query *follower);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add an N:1 follower query</literal></title>
				<para>
					Add an N:1 <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and rows from the follower will be matched using the
					<literal>match</literal> expression. If there are multiple
					rows in the follower matching the leader row, then the leader
					row will be listed that many times. For rows in the leader
					where there are no matching rows in the follower, the follower
					fields are set to NULL. It is similar to <literal>LEFT OUTER
					JOIN</literal> in SQL databases. For creating an
					<literal>ocrpt_expr</literal> expression pointer, see the
					next section.
					<programlisting>bool
ocrpt_query_add_follower_n_to_1(ocrpt_query *leader,
                                ocrpt_query *follower,
                                ocrpt_expr *match);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Free a query</literal></title>
				<para>
					Free a query and remove it from the report handler.
					It's optional. <literal>ocrpt_free()</literal> frees
					the queries added to the <literal>opencreport</literal>
					structure.
					<programlisting>void
ocrpt_query_free(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Start the main query</literal></title>
				<para>
					Start query (or query set) navigation.
					<literal>q</literal> should be the primary query
					of the report.
					<programlisting>void
ocrpt_query_navigate_start(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Navigate to the next query row</literal></title>
				<para>
					Navigate the query (or query set) to the next row. Returns
					<literal>false</literal> if there was no more rows.
					in which case the <literal>ocrpt_query_result</literal>
					arrays for all queries in the query set (returned by
					previous <literal>ocrpt_query_get_result()</literal>
					calls contain invalid data.
					<programlisting>bool
ocrpt_query_navigate_next(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="arraydiscoveryfunc" xreflabel="Array discovery function">
				<title><literal>API specific array discovery function</literal></title>
				<para>
					For array data sources and queries, OpenCReports
					needs a way to to find the data array and the
					supplementary type identifier array.
					These are language specific. The below ones
					are the C specific ones. The override function
					is also provided to set a new discovery function.
					The discovery function <emphasis>should</emphasis>
					return the dimensions for both the 2D
					<literal>array</literal> and the 1D
					<literal>coltypes</literal> arrays.
					<programlisting>typedef void
(*ocrpt_query_discover_func)(const char *,
                             void **,
                             int32_t *,
                             int32_t *,
                             const char *,
                             void **,
                             int32_t *);

void
ocrpt_query_set_discover_func(ocrpt_query_discover_func func);

extern ocrpt_query_discover_func ocrpt_query_discover_array;

void
ocrpt_query_discover_array_c(const char *arrayname,
                             void **array,
                             int32_t *rows,
                             int32_t *cols,
                             const char *typesname,
                             void **types,
                             int32_t *types_cols);</programlisting>
				</para>
				<para>
					Note that the C specific generic discovery function
					does not and cannot return the array dimensions,
					since there is no official API related to
					<literal>dlsym()</literal> that would return
					the size associated with a symbol.
					It's up to the application writers to come up
					with a smarter (application specific) discovery
					function that also returns the array dimensions.
					With such a smart discovery function, one can specify
					the array and the column types array name without
					the related dimensions, i.e. the <literal>rows</literal>
					and <literal>cols</literal> specifiers in
					<xref linkend="arrayqueries"/> and
					<xref linkend="filequeries"/>.
				</para>
			</sect3>
		</sect2>
		<sect2 id="exprfunc" xreflabel="Expression related functions">
			<title>Expression related functions</title>
			<para>
				Expressions in OpenCReports is explained in the
				<xref linkend="expressions"/> chapter.
			</para>
			<sect3>
				<title>Parse an expression string</title>
				<para>
					This function parses an expression string and
					creates an expression tree. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					<programlisting>ocrpt_expr *
ocrpt_expr_parse(opencreport *o,
                 const char *expr_string,
                 char **err);</programlisting>
				</para>
				<para>
					The returned pointer must be freed with
					<literal>ocrpt_expr_free()</literal>.
				</para>
			</sect3>
			<sect3>
				<title>Parse an expression string and bind it to a report</title>
				<para>
					This function parses an expression string,
					creates an expression tree and binds it to
					a report. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					<programlisting>ocrpt_expr *
ocrpt_report_expr_parse(ocrpt_report *r,
                        const char *expr_string,
                        char **err);</programlisting>
				</para>
				<para>
					The returned pointer is automatically freed by
					<literal>ocrpt_free()</literal>
				</para>
			</sect3>
			<sect3>
				<title>Free an expression parse tree</title>
				<para>
					Free an expression parse tree. If it was bound
					to the passed-in <literal>ocrpt_report</literal>,
					this association is also deleted. Alternatively,
					the expression doesn't need to be freed if it was
					bound to a report when it was parsed, as it will be
					automatically freed when freeing either the report,
					or the global <literal>opencreport</literal> structure.
					<programlisting>void
ocrpt_expr_free(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve expression references</title>
				<para>
					This function resolves variable (identifier)
					references in the expression. This is needed
					to bind query columns to expressions that
					use them.
					<programlisting>void
ocrpt_expr_resolve(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Optimize an expression</title>
				<para>
					This function optimizes an expression so
					it may needs fewer computation steps during
					report execution.
					<programlisting>void
ocrpt_expr_optimize(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate an expression</title>
				<para>
					This function evaluates the expression.
					It returns the expression's
					<literal>ocrpt_result</literal> result structure.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>
				</para>
				<para>
					For expressions with query column references,
					this function must be called after
					<literal>ocrpt_query_navigate_next</literal>
					otherwise the result is not valid.
					<programlisting>ocrpt_result *
ocrpt_expr_eval(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get expression result without evaluation</title>
				<para>
					This function returns the expression result
					if it was already evaluated.
					The result <emphasis>must not</emphasis> be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>.
					Used by unit tests.
					<programlisting>ocrpt_result *
ocrpt_expr_get_result(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree</title>
				<para>
					Print an expression tree in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_print(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree with subexpressions and their results</title>
				<para>
					Print an expression tree with subexpressions
					and their results in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_result_deep_print(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Count the number of expression nodes</title>
				<para>
					This function returns the number of expression nodes.
					Used by unit tests to validate optimizazion.
					<programlisting>int32_t
ocrpt_expr_nodes(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Initialize expression result type</title>
				<para>
					OpenCReports keeps track of the last three query
					rows and computes three result values for expressions
					for internal reasons. These functions initialize
					the type for either the current result or all results
					of the expression.
					<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

bool ocrpt_expr_init_result(ocrpt_expr *e,
                            enum ocrpt_result_type type);

void ocrpt_expr_init_results(ocrpt_expr *e,
                             enum ocrpt_result_type type);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set an error string as expression result</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_expr_make_error_result(ocrpt_expr *e,
                             const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set start value flag for an iterative expression</title>
				<para>
					Set whether the iterative expression's first
					value is computed from its base expression
					or from its result expression.
					<programlisting>void
ocrpt_expr_set_iterative_start_value(ocrpt_expr *e,
                                     bool start_with_init);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get current value of an expression in base type</title>
				<para>
					Get the current value of an expression in a C base
					type. Used by parsing report description XML files
					and unit tests.
					<programlisting>const char *
ocrpt_expr_get_string_value(ocrpt_expr *e);

long
ocrpt_expr_get_long_value(ocrpt_expr *e);

double
ocrpt_expr_get_double_value(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set current value of an expression in a base type</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_expr_set_string_value(ocrpt_expr *e,
                            const char *s);

void
ocrpt_expr_set_long_value(ocrpt_expr *e,
                          long l);

void
ocrpt_expr_set_double_value(ocrpt_expr *e,
                            double d);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set nth value of an expression in a base type</title>
				<para>
					Expressions use <literal>OCRPT_EXPR_RESULTS</literal>
					number of values. With these functions, any of them
					can be set. Used by unit tests.
					<programlisting>void
ocrpt_expr_set_nth_result_string_value(ocrpt_expr *e,
                                       int which,
                                       const char *s);

void
ocrpt_expr_set_nth_result_long_value(ocrpt_expr *e,
                                     int which,
                                     long l);

void
ocrpt_expr_set_nth_result_double_value(ocrpt_expr *e,
                                       int which,
                                       double d);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Compare current and previous values of and expression</title>
				<para>
					Compare current and previous values of and expression
					and return <literal>true</literal> if they are equal.
					It's used to implement <xref linkend="breaks"/>.
					<programlisting>bool
ocrpt_expr_cmp_results(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set delayed flag of an expression</title>
				<para>
					<programlisting>void
ocrpt_expr_set_delayed(ocrpt_expr *e,
                       bool delayed);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set field expression reference for an expression</title>
				<para>
					If <literal>e</literal> contains <literal>r.value</literal>,
					the expression <literal>rvalue</literal> will be used to
					resolve this reference.
					<programlisting>void
ocrpt_expr_set_field_expr(ocrpt_expr *e,
                          ocrpt_expr *rvalue);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Column data or expression result related functions</title>
			<para>
				The internal type <literal>ocrpt_result</literal> holds
				values either for query columns or expression results.
			</para>
			<sect3>
				<title>Create an expression result</title>
				<para>
					The returned pointer must be freed with
					<literal>ocrpt_result_free()</literal>.
					<programlisting>ocrpt_result *
ocrpt_result_new(void);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get expression result type</title>
				<para>
					<programlisting>enum ocrpt_result_type
ocrpt_result_get_type(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Copy an expression result</title>
				<para>
					Some internal data is specific to the
					<literal>opencreport</literal> structure.
					<programlisting>void
ocrpt_result_copy(opencreport *o,
                  ocrpt_result *dst,
                  ocrpt_result *src);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression result</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_result_print(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free an expression result</title>
				<para>
					<programlisting>void
ocrpt_result_free(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is NULL</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is NULL.
					<programlisting>bool
ocrpt_result_isnull(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is numeric</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is numeric.
					<programlisting>bool
ocrpt_result_isnumber(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the numeric value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the numeric column value. It returns  NULL
					if the column is:
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a numeric result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>mpfr_ptr
ocrpt_result_get_number(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is string</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is string.
					<programlisting>bool
ocrpt_result_isstring(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the string value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the string column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a string result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>ocrpt_string *
ocrpt_result_get_string(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a column result is datetime</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is datetime.
					<programlisting>bool
ocrpt_result_isdatetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the datetime value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the datetime column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a datetime result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>const struct tm *
ocrpt_result_get_datetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a datetime column result is interval</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value is interval.
					<programlisting>bool
ocrpt_result_datetime_is_interval(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a datetime column result has valid date</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid date.
					<programlisting>bool
ocrpt_result_datetime_is_date_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Detect whether a datetime column result has valid time</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid time.
					<programlisting>bool
ocrpt_result_datetime_is_time_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Variable related functions</title>
			<para>
				Variables can be created for a report using
				the API.
			</para>
			<sect3>
				<title>Create a basic variable</title>
				<para>
					Using this function, any variable type except
					<literal>OCRPT_VARIABLE_CUSTOM</literal>
					may be created. For a custom variable,
					see the next function.
					<programlisting>enum ocrpt_var_type {
    OCRPT_VARIABLE_EXPRESSION,
    OCRPT_VARIABLE_COUNT,
    OCRPT_VARIABLE_COUNTALL,
    OCRPT_VARIABLE_SUM,
    OCRPT_VARIABLE_AVERAGE,
    OCRPT_VARIABLE_AVERAGEALL,
    OCRPT_VARIABLE_LOWEST,
    OCRPT_VARIABLE_HIGHEST,
    OCRPT_VARIABLE_CUSTOM
};
typedef enum ocrpt_var_type ocrpt_var_type;

ocrpt_var *
ocrpt_variable_new(ocrpt_report *r,
                   ocrpt_var_type type,
                   const char *name,
                   const char *expr,
                   const char *reset_on_break_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a custom variable</title>
				<para>
					Create a custom variable of the specified type
					with the specified subexpressions.
					<programlisting>ocrpt_var *
ocrpt_variable_new_full(ocrpt_report *r,
                        enum ocrpt_result_type type,
                        const char *name,
                        const char *baseexpr,
                        const char *intermedexpr,
                        const char *intermed2expr,
                        const char *resultexpr,
                        const char *reset_on_break_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get subexpressions of a variable</title>
				<para>
					Get subexpressions of a previously created
					basic or custom variable.
					<programlisting>ocrpt_expr *
ocrpt_variable_baseexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermedexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermed2expr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_resultexpr(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set precalculate flag for a variable</title>
				<para>
					<programlisting>void
ocrpt_variable_set_precalculate(ocrpt_var *var, 
                                bool value);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve a variable</title>
				<para>
					Resolve subexpressions of a variable
					so it can be evaluated correctly.
					<programlisting>void
ocrpt_variable_resolve(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate a variable</title>
				<para>
					After evaluation, the result is in the
					expression returned by
					<literal>ocrpt_variable_resultexpr()</literal>.
					<programlisting>void
ocrpt_variable_evaluate(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Break related functions</title>
			<sect3>
				<title>Create a break</title>
				<para>
					Create a break. No need to free it,
					<literal>ocrpt_free()</literal> does it.
					<programlisting>ocrpt_break *
ocrpt_break_new(ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set attribute flags for a break</title>
				<para>
					Set boolean attribute flags for a break,
					either via explicit boolean value, or from
					an expression. The flags are not actually used,
					they are for RLIB compatibility.
					<programlisting>enum ocrpt_break_attr_type {
    OCRPT_BREAK_ATTR_NEWPAGE,
    OCRPT_BREAK_ATTR_HEADERNEWPAGE,
    OCRPT_BREAK_ATTR_SUPPRESSBLANK,
    OCRPT_BREAK_ATTRS_COUNT
};
typedef enum ocrpt_break_attr_type ocrpt_break_attr_type;

bool
ocrpt_break_set_attribute(ocrpt_break *br,
                          const ocrpt_break_attr_type attr_type,
                          bool value);

bool
ocrpt_break_set_attribute_from_expr(ocrpt_break *br,
                                    const
                                    ocrpt_break_attr_type
                                    attr_type,
                                    ocrpt_expr *expr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get break using its name</title>
				<para>
					Get the pointer to the break using its name.
					<programlisting>ocrpt_break *
ocrpt_break_get(ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the name of a break</title>
				<para>
					Get the name of the break using its structure
					pointer.
					<programlisting>const char *
ocrpt_break_get_name(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a watched expression to a break</title>
				<para>
					<programlisting>bool
ocrpt_break_add_breakfield(ocrpt_break *br,
                           ocrpt_expr *bf);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Iterate over breaks of a report</title>
				<para>
					Iterate over breaks of a report. The first call
					needs the iterator list pointer to be set to NULL.
					<programlisting>ocrpt_break *
ocrpt_break_get_next(ocrpt_report *r,
                     ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve and optimize break fields</title>
				<para>
					<programlisting>void
ocrpt_break_resolve_fields(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Check whether the break triggers</title>
				<para>
					<programlisting>bool
ocrpt_break_check_fields(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Reset variables for the break</title>
				<para>
					<programlisting>void
ocrpt_break_reset_vars(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Function related functions</title>
			<sect3>
				<title>Add a user defined function</title>
				<para>
					Add a user defined function by specifying
					the name, the function pointer that contains
					the implementation, the number of operands
					(0 or greater for fixed number or operands,
					-1 is varying number of operands) and
					the function mathematical properties
					that help optimizing it.
					<programlisting>bool
ocrpt_function_add(opencreport *o,
                   const char *fname,
                   ocrpt_function_call func,
                   void *user_data,
                   int32_t n_ops,
                   bool commutative,
                   bool associative,
                   bool left_associative,
                   bool dont_optimize);</programlisting>
				</para>
				<para>
					Adding a user defined function with
					a name of a pre-existing function will
					override it.
				</para>
				<para>
					OpenCReports functions are called with the
					parameters as declared below.
					<programlisting>#define OCRPT_FUNCTION_PARAMS \
    ocrpt_expr *e, void *user_data</programlisting>
				</para>
				<para>
					OpenCReports functions may be declared
					with these convenience symbols below.
					<programlisting>#define OCRPT_FUNCTION(name) \
    void name(OCRPT_FUNCTION_PARAMS)

#define OCRPT_STATIC_FUNCTION(name) \
    static void name(OCRPT_FUNCTION_PARAMS)</programlisting>
				</para>
				<para>
					The above function
					(<literal>ocrpt_function_add()</literal>)
					is called with a function pointer which has
					this type:
					<programlisting>typedef void
(*ocrpt_function_call)(OCRPT_FUNCTION_PARAMS);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Find a named function</title>
				<para>
					<programlisting>const ocrpt_function *
ocrpt_function_get(opencreport *o,
                   const char *fname);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get number of operands for an expression (function)</title>
				<para>
					In an expression tree, functions
					are represented as subexpressions with
					operands. This call may be used by OpenCReports
					functions to inspect whether the number of
					operands is in the expected range.
					<programlisting>int32_t
ocrpt_expr_get_num_operands(ocrpt_expr *e);
</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get current value of a function operand</title>
				<para>
					This function is used by OpenCReports functions
					internally to compute the result from its
					operands.
					<programlisting>ocrpt_result *
ocrpt_expr_operand_get_result(ocrpt_expr *e,
                              int32_t opnum);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Report part and report related functions</title>
			<sect3>
				<title>Create a report part</title>
				<para>
					<programlisting>ocrpt_part *
ocrpt_part_new(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a row in a report part</title>
				<para>
					<programlisting>ocrpt_part_row *
ocrpt_part_new_row(ocrpt_part *p);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a column in report part row</title>
				<para>
					<programlisting>ocrpt_part_column *
ocrpt_part_row_new_column(ocrpt_part_row *pr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a new report in a part column</title>
				<para>
					<programlisting>ocrpt_report *
ocrpt_part_column_new_report(ocrpt_part_column *pd);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Report part related iterators</title>
				<para>
					Iterators for getting report parts, part rows,
					columns in rows and reports in columns.
					Every iterator function must be called
					the first time with the list pointer set to NULL.
					<programlisting>ocrpt_part *
ocrpt_part_get_next(opencreport *o,
                    ocrpt_list **list);

ocrpt_part_row *
ocrpt_part_row_get_next(ocrpt_part *p,
                        ocrpt_list **list);

ocrpt_part_column *
ocrpt_part_column_get_next(ocrpt_part_row *pr,
                           ocrpt_list **list);

ocrpt_report *
ocrpt_report_get_next(ocrpt_part_column *pd,
                      ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set the main query for a report</title>
				<para>
					Set the main query for a report either by
					the query structure pointer, or by name.
					<programlisting>void
ocrpt_report_set_main_query(ocrpt_report *r,
                            const ocrpt_query *query);

void
ocrpt_report_set_main_query_by_name(ocrpt_report *r,
                                    const char *query);</programlisting>
				</para>
				<para>
					See <xref linkend="reportqueryname"/>.
					Unlike with the XML description, where the first
					globally declared query is used for the report
					if its main query is not set, the default via
					the low level API is unset.
				</para>
			</sect3>
			<sect3>
				<title>Get the current row number of the main query</title>
				<para>
					The row number starts from 1.
					<programlisting>long
ocrpt_report_get_query_rownum(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_variables(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_variables(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve all report breaks</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_breaks(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_expressions(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_expressions(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Layout related functions</title>
			<sect3>
				<title>Global layout options</title>
				<sect4>
					<title>Set "size units in points" option</title>
					<para>
						See <xref linkend="sizeunit"/>.
						<programlisting>void
ocrpt_set_size_unit_points(opencreport *o,
                           bool size_in_points);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set "no query show NoData" option</title>
					<para>
					See <xref linkend="noqueryshownodata"/>.
					<programlisting>void
ocrpt_set_noquery_show_nodata(opencreport *o,
                              bool noquery_show_nodata);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set "report height after last" option</title>
					<para>
						See <xref linkend="reportheightafterlast"/>.
						<programlisting>void
ocrpt_set_report_height_after_last(opencreport *o,
                                   bool
                                   report_height_after_last);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Report part options</title>
				<sect4>
					<title>Set part iterations</title>
					<para>
						See <xref linkend="partiter"/>.
						<programlisting>void
ocrpt_part_set_iterations(ocrpt_part *p,
                          int32_t iterations);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part font name</title>
					<para>
						See <xref linkend="partfontname"/>.
						<programlisting>void
ocrpt_part_set_font_name(ocrpt_part *p,
                         const char *font_name);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part font size</title>
					<para>
						See <xref linkend="partfontsize"/>.
						<programlisting>void
ocrpt_part_set_font_size(ocrpt_part *p,
                         const char *font_size);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part paper type</title>
					<para>
						See <xref linkend="papertype"/>.
						<programlisting>void
ocrpt_part_set_paper_by_name(ocrpt_part *p,
                             const char *paper_name);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part paper's landscape orientation</title>
					<para>
						By default, the part uses portrait orientation.
						See <xref linkend="partpageorientation"/>.
						<programlisting>void
ocrpt_part_set_landscape(ocrpt_part *p,
                         bool landscape);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part margins</title>
					<para>
						See <xref linkend="marginsettings"/>.
						The margin values must be passed in via strings
						as they can be expressions.
						<programlisting>void
ocrpt_part_set_top_margin(ocrpt_part *p,
                          const char *margin);

void
ocrpt_part_set_bottom_margin(ocrpt_part *p,
                             const char *margin);

void
ocrpt_part_set_left_margin(ocrpt_part *p,
                           const char *margin);

void
ocrpt_part_set_right_margin(ocrpt_part *p,
                            const char *margin);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part suppression</title>
					<para>
						See <xref linkend="partsuppress"/>.
						<programlisting>void
ocrpt_part_set_suppress(ocrpt_part *p,
                        bool suppress);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part's page header suppressed on the first page</title>
					<para>
						See <xref linkend="suppresspageheaderfirstpage"/>.
						<programlisting>void
ocrpt_part_set_suppress_pageheader_firstpage(ocrpt_part *p,
                                             bool suppress);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Part row options</title>
				<sect4>
					<title>Set part row suppression</title>
					<para>
						See <xref linkend="partrowsuppress"/>.
						<programlisting>void
ocrpt_part_row_set_suppress(ocrpt_part_row *pr,
                            bool suppress);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part row new page</title>
					<para>
						See <xref linkend="partrownewpage"/>.
						<programlisting>void
ocrpt_part_row_set_newpage(ocrpt_part_row *pr,
                           bool newpage);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part row layout fixed mode</title>
					<para>
						Not implemented.
						See <xref linkend="partrowlayout"/>.
						<programlisting>void
ocrpt_part_row_set_layout_fixed(ocrpt_part_row *pr,
                                bool fixed);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Part column options</title>
				<sect4>
					<title>Set part column suppression</title>
					<para>
						See <xref linkend="partcolsuppress"/>.
						<programlisting>void
ocrpt_part_column_set_suppress(ocrpt_part_column *pd,
                               bool suppress);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part column width</title>
					<para>
						See <xref linkend="partcolwidth"/>.
						<programlisting>void
ocrpt_part_column_set_width(ocrpt_part_column *pd,
                            double width);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part column height</title>
					<para>
						See <xref linkend="partcolheight"/>.
						<programlisting>void
ocrpt_part_column_set_height(ocrpt_part_column *pd,
                             double height);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part column border width</title>
					<para>
						See <xref linkend="pdborderwidth"/>.
						<programlisting>void
ocrpt_part_column_set_border_width(ocrpt_part_column *pd,
                                   double border_width);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part column border color</title>
					<para>
						See <xref linkend="pdbordercolor"/>.
						<programlisting>void
ocrpt_part_column_set_border_color(ocrpt_part_column *pd,
                                   const char *color);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part column's number of detail columns</title>
					<para>
						See <xref linkend="detailcolumns"/>.
						<programlisting>void
ocrpt_part_column_set_detail_columns(ocrpt_part_column *pd,
                                     int32_t detail_columns);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set part column's detail column padding</title>
					<para>
						See <xref linkend="columnpadding"/>.
						<programlisting>void
ocrpt_part_column_set_column_padding(ocrpt_part_column *pd,
                                     double padding);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Report options</title>
				<sect4>
					<title>Set report suppression</title>
					<para>
						See <xref linkend="reportsuppress"/>.
						<programlisting>void
ocrpt_report_set_suppress(ocrpt_report *r,
                          bool suppress);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set report iterations</title>
					<para>
						See <xref linkend="reportiter"/>.
						<programlisting>void
ocrpt_report_set_iterations(ocrpt_report *r,
                            int32_t iterations);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set report font name</title>
					<para>
						See <xref linkend="reportfontname"/>.
						<programlisting>void
ocrpt_report_set_font_name(ocrpt_report *r,
                           const char *font_name);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set report font size</title>
					<para>
						See <xref linkend="reportfontsize"/>.
						<programlisting>void
ocrpt_report_set_font_size(ocrpt_report *r,
                           double font_size);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set report height</title>
					<para>
						See <xref linkend="reportheight"/>.
						<programlisting>void
ocrpt_report_set_height(ocrpt_report *r,
                        double height);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set report's field header priority</title>
					<para>
						See <xref linkend="reportfhpriority"/>.
						<programlisting>void
ocrpt_report_set_fieldheader_high_priority(ocrpt_report *r,
                                           bool high_priority);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Get part layout sections</title>
				<para>
					Get the part's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;PageHeader&gt;</literal>
					or <literal>&lt;PageFooter&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_layout_part_page_header(ocrpt_part *p);

ocrpt_output *
ocrpt_layout_part_page_footer(ocrpt_part *p);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set report for part layout sections</title>
				<para>
					Set the report pointer for the part's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;PageHeader&gt;</literal>
					or <literal>&lt;PageFooter&gt;</literal>.
					<programlisting>void
ocrpt_layout_part_page_header_set_report(ocrpt_part *p,
                                         ocrpt_report *r);

void
ocrpt_layout_part_page_footer_set_report(ocrpt_part *p,
                                         ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get report layout sections</title>
				<para>
					Get the report's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;NoData&gt;</literal>,
					<literal>&lt;ReportHeader&gt;</literal>,
					<literal>&lt;ReportFooter&gt;</literal>,
					<literal>&lt;FieldHeaders&gt;</literal> or
					<literal>&lt;FieldDetails&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_layout_report_nodata(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_header(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_footer(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_field_header(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_field_details(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get break layout sections</title>
				<para>
					Get the break's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;BreakHeader&gt;</literal> or
					<literal>&lt;BreakFooter&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_break_get_header(ocrpt_break *br);

ocrpt_output *
ocrpt_break_get_footer(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set output section global settings</title>
				<para>
					Note that part (page) header and footer, and report
					header and footer sections must be constant
					expressions. Other sections may depend on data derived
					from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4>
					<title>Set output section suppression</title>
					<para>
						Set suppression from an expression string.
						<programlisting>void
ocrpt_output_set_suppress(ocrpt_output *output,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Add a text line to an output section</title>
				<para>
					<programlisting>ocrpt_line *
ocrpt_output_add_line(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Text line settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4>
					<title>Set line font name</title>
					<para>
						Set the text line's font name from
						an expression string.
						<programlisting>void
ocrpt_line_set_font_name(ocrpt_line *line,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set line font size</title>
					<para>
						Set the text line's font size from
						an expression string.
						<programlisting>void
ocrpt_line_set_font_size(ocrpt_line *line,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set line bold value</title>
					<para>
						Set the text line's bold value from
						an expression string.
						<programlisting>void
ocrpt_line_set_bold(ocrpt_line *line,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set line italic value</title>
					<para>
						Set the text line's italic value from
						an expression string.
						<programlisting>void
ocrpt_line_set_italic(ocrpt_line *line,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set line suppression</title>
					<para>
						Set the text line's suppression value from
						an expression string.
						<programlisting>void
ocrpt_line_set_suppress(ocrpt_line *line,
                        const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set line text color</title>
					<para>
						Set the text line's text color from
						an expression string.
						<programlisting>void
ocrpt_line_set_color(ocrpt_line *line,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set line background color</title>
					<para>
						Set the text line's background color from
						an expression string.
						<programlisting>void
ocrpt_line_set_bgcolor(ocrpt_line *line,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Add a text element to a text line</title>
				<para>
					<programlisting>ocrpt_text *
ocrpt_line_add_text(ocrpt_line *line);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Text element settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4>
					<title>Set text element literal value</title>
					<para>
						Set the text element's literal value from
						a string.
						<programlisting>void
ocrpt_text_set_value_string(ocrpt_text *text,
                            const char *string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element value</title>
					<para>
						Set the text element's value from
						an expression string and whether the
						expression is delayed.
						<programlisting>void
ocrpt_text_set_value_expr(ocrpt_text *text,
                          const char *expr_string,
                          bool delayed);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element format string</title>
					<para>
						Set the text element's format string from
						an expression string.
						<programlisting>void
ocrpt_text_set_format(ocrpt_text *text,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element translation</title>
					<para>
						Set the text element's translation from
						an expression string.
						<programlisting>void
ocrpt_text_set_translate(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
					<para>
						OpenCReports will attempt to translate
						both the format string and the text element's
						value.
					</para>
				</sect4>
				<sect4>
					<title>Set text element field width</title>
					<para>
						Set the text element's field width from
						an expression string.
						<programlisting>void
ocrpt_text_set_width(ocrpt_text *text,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element alignment</title>
					<para>
						Set the text element's alignment from
						a string or an expression string.
						<programlisting>void
ocrpt_text_set_alignment(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
					<para>
						String values <literal>left</literal>,
						<literal>right</literal>,
						<literal>center</literal> and
						<literal>justified</literal> are
						accepted either as is, or as an expression.
					</para>
				</sect4>
				<sect4>
					<title>Set text element text color</title>
					<para>
						Set the text element's text color from
						an expression string.
						<programlisting>void
ocrpt_text_set_color(ocrpt_text *text,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element background color</title>
					<para>
						Set the text element's background color from
						an expression string.
						<programlisting>void
ocrpt_text_set_bgcolor(ocrpt_text *text,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element font name</title>
					<para>
						Set the text element's font name from
						an expression string.
						<programlisting>void
ocrpt_text_set_font_name(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element font size</title>
					<para>
						Set the text element's font size from
						an expression string.
						<programlisting>void
ocrpt_text_set_font_size(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element bold value</title>
					<para>
						Set the text element's bold value from
						an expression string.
						<programlisting>void
ocrpt_text_set_bold(ocrpt_text *text,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element italic value</title>
					<para>
						Set the text element's italic value from
						an expression string.
						<programlisting>void
ocrpt_text_set_italic(ocrpt_text *text,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element link URL</title>
					<para>
						Set the text element's link URL from
						an expression string.
						<programlisting>void
ocrpt_text_set_link(ocrpt_text *text,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set text element multiline parameters</title>
					<para>
						Set the text element's multiline parameters.
						<programlisting>void
ocrpt_text_set_memo(ocrpt_text *text,
                    bool memo,
                    bool wrap_chars,
                    int32_t max_lines);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Add a horizontal line to an output section</title>
				<para>
					<programlisting>ocrpt_hline *
ocrpt_output_add_hline(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Horizontal line settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4>
					<title>Set horizontal line size (width)</title>
					<para>
						Set the horizontal line's size (width) from
						an expression string.
						<programlisting>void
ocrpt_hline_set_size(ocrpt_hline *hline,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set horizontal line indentation</title>
					<para>
						Set the horizontal line's indentation value from
						an expression string.
						<programlisting>void
ocrpt_hline_set_indent(ocrpt_hline *hline,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set horizontal line length</title>
					<para>
						Set the horizontal line's length from
						an expression string.
						<programlisting>void
ocrpt_hline_set_length(ocrpt_hline *hline,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set horizontal line font size</title>
					<para>
						Set the horizontal line's font size from
						an expression string. It's used in indentation
						and length calculations if <xref linkend="sizeunit"/>
						is set to <literal>rlib</literal>.
						<programlisting>void
ocrpt_hline_set_font_size(ocrpt_hline *hline,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set horizontal line suppression</title>
					<para>
						Set the horizontal line's suppression from
						an expression string.
						<programlisting>void
ocrpt_hline_set_suppress(ocrpt_hline *hline,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set horizontal line color</title>
					<para>
						Set the horizontal line's color from
						an expression string.
						<programlisting>void
ocrpt_hline_set_color(ocrpt_hline *hline,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Add an image to an output section</title>
				<para>
					<programlisting>ocrpt_image *
ocrpt_output_add_image(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an image to a text line</title>
				<para>
					<programlisting>ocrpt_image *
ocrpt_line_add_image(ocrpt_line *line);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Image settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4>
					<title>Set image value</title>
					<para>
						Set the image's value (filename) from
						an expression string.
						<programlisting>void
ocrpt_image_set_value(ocrpt_image *image,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set image suppression</title>
					<para>
						Set the image's suppression from
						an expression string.
						<programlisting>void
ocrpt_image_set_suppress(ocrpt_image *image,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set image type</title>
					<para>
						Set the image's type from
						an expression string.
						<programlisting>void
ocrpt_image_set_type(ocrpt_image *image,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set image width</title>
					<para>
						Set the image's width from
						an expression string. Used when
						the image is directly added to
						an output section.
						<programlisting>void
ocrpt_image_set_width(ocrpt_image *image,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set image height</title>
					<para>
						Set the image's width from
						an expression string. Used when
						the image is directly added to
						an output section.
						<programlisting>void
ocrpt_image_set_height(ocrpt_image *image,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set image alignment</title>
					<para>
						Set the image's alignment from
						an expression string. Used when
						the image is added to text line.
						<programlisting>void
ocrpt_image_set_align(ocrpt_image *image,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set image background color</title>
					<para>
						Set the image's background color from
						an expression string.
						<programlisting>void
ocrpt_image_set_bgcolor(ocrpt_image *image,
                        const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4>
					<title>Set image field width</title>
					<para>
						Set the image's field width from
						an expression string. Used when
						the image is added to text line.
						<programlisting>void
ocrpt_image_set_text_width(ocrpt_image *image,
                           const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3>
				<title>Add an image end marker to an output section</title>
				<para>
					<programlisting>void
ocrpt_output_add_image_end(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Callback related functions</title>
			<para>
				Certain stages of the report execution can
				notify the application about the stage
				being executed or finished.
			</para>
			<para>
				Every "add a callback" function below return
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
			</para>
			<sect3>
				<title>Add a "part added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_part_cb)(opencreport *,
                 ocrpt_part *,
                 void *data);

bool
ocrpt_add_part_added_cb(opencreport *o,
                        ocrpt_part_cb func,
                        void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_report_cb)(opencreport *,
                   ocrpt_report *,
                   void *data);

bool
ocrpt_add_report_added_cb(opencreport *o,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an "all precalculations done" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_cb)(opencreport *,
            void *data);

bool
ocrpt_add_precalculation_done_cb(opencreport *o,
                                 ocrpt_cb func,
                                 void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "part iteration" callback</title>
				<para>
					<programlisting>bool
ocrpt_part_add_iteration_cb(ocrpt_part *r,
                            ocrpt_part_cb func,
                            void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report started" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_start_cb(ocrpt_report *r,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_done_cb(ocrpt_report *r,
                         ocrpt_report_cb func,
                         void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "new row" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_new_row_cb(ocrpt_report *r,
                            ocrpt_report_cb func,
                            void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report iteration done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_iteration_cb(ocrpt_report *r,
                              ocrpt_report_cb func,
                              void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "report precalculation done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_precalculation_done_cb(ocrpt_report *r,
                                        ocrpt_report_cb func,
                                        void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a "break triggers" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_break_trigger_cb)(opencreport *,
                          ocrpt_report *,
                          ocrpt_break *,
                          void *);

bool
ocrpt_break_add_trigger_cb(ocrpt_break *br,
                           ocrpt_break_trigger_cb func,
                           void *data);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Environment related functions</title>
			<sect3>
				<title>Indirect function to get an environment variable</title>
				<para>
					<programlisting>typedef ocrpt_result *
(*ocrpt_env_query_func)(const char *);

extern ocrpt_env_query_func
ocrpt_env_get;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set the environment query function</title>
				<para>
					<programlisting>void
ocrpt_env_set_query_func(ocrpt_env_query_func func);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>C API environment query function</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_env_get_c(const char *env);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>File handling related functions</title>
			<sect3>
				<title>Return a canonical file path</title>
				<para>
					The returned path contains only single
					directory separators and doesn't contains
					symlinks.
					<programlisting>char *
ocrpt_canonicalize_path(const char *path);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add search path</title>
				<para>
					Add a new directory path to the list of
					search paths. It's useful to find files
					referenced with relative path.
					<programlisting>void
ocrpt_add_search_path(opencreport *o,
                      const char *path);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Find a file</title>
				<para>
					Find a file and return the canonicalized path to it.
					This function takes the search paths into account.
					<programlisting>char *
ocrpt_find_file(opencreport *o,
                const char *filename);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Color related functions</title>
			<sect3>
				<title>Find a color by its name</title>
				<para>
					The function fills in the
					<literal>ocrpt_color</literal> structure with
					RGB values in Cairo values (0.0 ... 1.0).
				</para>
				<para>
					If the color name starts with
					<literal>#</literal> or <literal>0x</literal> or
					<literal>0X</literal> then it must be in HTML
					notation.
				</para>
				<para>
					Otherwise, the color name is looked up in the
					color name database in a case insensitive way.
					If found, the passed-in ocrpt_color structure is
					filled with the RGB color value of that name.
				</para>
				<para>
					If not found or the passed-in color name is NULL,
					depending on the the expected usage (foreground
					or background color), the <literal>ocrpt_color</literal>
					structure is filled with either white or black.
					<programlisting>void
ocrpt_get_color(opencreport *o,
                const char *cname,
                ocrpt_color *color,
                bool bgcolor);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Paper size related functions</title>
			<para>
				Paper size in OpenCReports is handled via
				<ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>.
			</para>
			<para>
				This structure is used in OpenCReports to represent
				paper name and size:
				<programlisting>struct ocrpt_paper {
    const char *name;
    double width;
    double height;
};
typedef struct ocrpt_paper ocrpt_paper;</programlisting>
			</para>
			<sect3>
				<title>Get the system default paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_system_paper(void);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the paper specified by name</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper_by_name(const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set the global paper</title>
				<para>
					Set global paper using an
					<literal>ocrpt_paper</literal> structure.
					The contents of the structure is copied.
					<programlisting>void
ocrpt_set_paper(opencreport *o,
                const ocrpt_paper *paper);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set global paper specified by name</title>
				<para>
					Set paper for the report using a paper name.
					If the paper name is unknown, the system default paper is set.
					<programlisting>void
ocrpt_set_paper_by_name(opencreport *o,
                        const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get currently set global paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Iterate over paper sizes</title>
				<para>
					Get the next <literal>ocrpt_paper</literal> structure
					in the iterator. For the first call, the iterator
					pointer must be NULL. It returns NULL when there are
					no more papers known to the system.
					<programlisting>const ocrpt_paper *
ocrpt_paper_next(opencreport *o,
                 void **iter);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Memory handling related functions</title>
			<para>
				Memory handling is done through an indirection,
				to help with bindings (that may do their own memory
				handling) override the default.
			</para>
			<sect3>
				<title>Indirect function pointers</title>
				<para>
					<programlisting>typedef void *
(*ocrpt_mem_malloc_t)(size_t);

typedef void *
(*ocrpt_mem_realloc_t)(void *,
                       size_t);

typedef void *
(*ocrpt_mem_reallocarray_t)(void *,
                            size_t,
                            size_t);

typedef void
(*ocrpt_mem_free_t)(const void *);

typedef char *
(*ocrpt_mem_strdup_t)(const char *);

typedef char *
(*ocrpt_mem_strndup_t)(const char *,
                       size_t);

typedef void
(*ocrpt_mem_free_size_t)(void *,
                         size_t);

extern ocrpt_mem_malloc_t ocrpt_mem_malloc0;
extern ocrpt_mem_realloc_t ocrpt_mem_realloc0;
extern ocrpt_mem_reallocarray_t ocrpt_mem_reallocarray0;
extern ocrpt_mem_free_t ocrpt_mem_free0;
extern ocrpt_mem_strdup_t ocrpt_mem_strdup0;
extern ocrpt_mem_strndup_t ocrpt_mem_strndup0;</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Allocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_malloc(size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Reallocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_realloc(void *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Reallocate array of memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_reallocarray(void *ptr,
                       size_t nmemb,
                       size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free memory</title>
				<para>
					<programlisting>void
ocrpt_mem_free(const void *ptr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Duplicate C string</title>
				<para>
					<programlisting>void *
ocrpt_mem_strdup(const char *ptr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Duplicate C string up to the specified length</title>
				<para>
					<programlisting>void *
ocrpt_mem_strndup(const char *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a C string</title>
				<para>
					It'a convenience alias for
					<literal>ocrpt_mem_free()</literal>.
					<programlisting>void
ocrpt_strfree(const char *s);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set indirect allocation functions</title>
				<para>
					<programlisting>void
ocrpt_mem_set_alloc_funcs(ocrpt_mem_malloc_t rmalloc,
                          ocrpt_mem_realloc_t rrealloc,
                          ocrpt_mem_reallocarray_t rreallocarray,
                          ocrpt_mem_free_t rfree,
                          ocrpt_mem_strdup_t rstrdup,
                          ocrpt_mem_strndup_t rstrndup);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>List related functions</title>
			<para>
				These functions implement a single linked list.
				The list element structure is hidden:
				<programlisting>struct ocrpt_list;
typedef struct ocrpt_list ocrpt_list;</programlisting>
			</para>
			<sect3>
				<title>Get the list length</title>
				<para>
					<programlisting>size_t
ocrpt_list_length(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Make a list from one element</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_makelist1(const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Make a list from multiple elements</title>
				<para>
					This function can be used with variable
					number of arguments.
					<programlisting>ocrpt_list *
ocrpt_makelist(const void *data1, ...);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the last element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_last(const ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the nth element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_nth(const ocrpt_list *l, uint32_t n);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_append(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append to list using the last element</title>
				<para>
					This function make appending to the list work
					<emphasis>O(1)</emphasis> instead of
					<emphasis>O(n)</emphasis>.
					<programlisting>ocrpt_list *
ocrpt_list_end_append(ocrpt_list *l,
                      ocrpt_list **e,
                      const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Prepend a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_prepend(ocrpt_list *l,
                   const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Remove a data element from a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_remove(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Remove a data element from a list and update the last link</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_end_remove(ocrpt_list *l,
                      ocrpt_list **endptr,
                      const void *data);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get next link in the list</title>
				<para>
					This can be used to iterate through a list.
					It returns <literal>NULL</literal> if the
					passed-in link is the last list in the list
					or it's an empty list.
					<programlisting>ocrpt_list *
ocrpt_list_next(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get the data element from a list</title>
				<para>
					<programlisting>void *
ocrpt_list_get_data(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a list</title>
				<para>
					<programlisting>void
ocrpt_list_free(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a list and its data elements</title>
				<para>
					<programlisting>void
ocrpt_list_free_deep(ocrpt_list *l,
                     ocrpt_mem_free_t freefunc);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>String related functions</title>
			<para>
				For memory safety and higher performance, a wrapper
				structure is used over C functions.
				<programlisting>struct ocrpt_string {
    char *str;
    size_t allocated_len;
    size_t len;
};
typedef struct ocrpt_string ocrpt_string;</programlisting>
			</para>
			<sect3>
				<title>Create a new string</title>
				<para>
					Create a new string from a C string.
					The ownership of the input string may be
					taken over, or the original string's contents
					are copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new(const char *str,
                     bool copy);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a new string with specified allocated length</title>
				<para>
					Create a new string with specified allocated length
					so future growth can be done without reallocation.
					The input string is always copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_with_len(const char *str,
                              size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a string from a formatted string with maximum length</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_vnprintf(size_t len,
                              const char *format,
                              va_list va);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Create a string from a formatted string</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_printf(const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resize a string</title>
				<para>
					Resize the string to the specified allocated
					length.
					<programlisting>ocrpt_string *
ocrpt_mem_string_resize(ocrpt_string *string,
                        size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free a string</title>
				<para>
					<programlisting>char *
ocrpt_mem_string_free(ocrpt_string *string,
                      bool free_str);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a C string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len(ocrpt_string *string,
                            const char *str,
                            const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a binary string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len_binary(ocrpt_string *string,
                                   const char *str,
                                   const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a C string of unspecified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append(ocrpt_string *string,
                        const char *str);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a byte to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_c(ocrpt_string *string,
                          const char c);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Append a formatted string to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_printf(ocrpt_string *string,
                               const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
</chapter>

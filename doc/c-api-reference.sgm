<chapter id="c-api-reference" xreflabel="C API Reference">
	<title>C language API reference</title>
	<sect1>
		<title>Header file</title>
		<para>
			For using OpenCReports, this single header must be used:
			<programlisting>
#include &lt;opencreport.h&gt;
			</programlisting>
		</para>
	</sect1>
	<sect1 id="highlevelapi" xreflabel="High level C API">
		<title>High level C API</title>
		<para>
			Example code using the high level C API where everything
			concerning the report (including the data source)
			is described in the report XML:
			<programlisting>
#include &lt;opencreport.h&gt;

int main(void) {
    opencreport *o = ocrpt_init();

    if (!ocrpt_parse_xml(o, "report.xml")) {
        printf("XML parse error\n");
        ocrpt_free(o);
        return 1;
    }

    ocrpt_set_output_format(o, OCRPT_OUTPUT_PDF);
    ocrpt_execute(o);
    ocrpt_spool(o);
    ocrpt_free(o);
    return 0;
}
			</programlisting>
		</para>
		<para>
			The above code will load <literal>report.xml</literal>,
			set the output format to PDF, runs the report and prints
			it output on <literal>stdout</literal>.
		</para>
		<sect2>
		<title>Report handler initialization</title>
		<para>
			<programlisting>
opencreport *ocrpt_init(void);
			</programlisting>
		</para>
		</sect2>
		<sect2>
			<title>Load a report XML description</title>
			<para>
				This function loads the specified XML file
				into the report handler. It returns
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
				<programlisting>
bool ocrpt_parse_xml(opencreport *o, const char *filename);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Set report output format</title>
			<para>
				<programlisting>
enum ocrpt_format_type {
    OCRPT_OUTPUT_UNSET,
    OCRPT_OUTPUT_PDF,
    OCRPT_OUTPUT_HTML,
    OCRPT_OUTPUT_TXT,
    OCRPT_OUTPUT_CSV,
    OCRPT_OUTPUT_XML
};
typedef enum ocrpt_format_type ocrpt_format_type;

void ocrpt_set_output_format(opencreport *o,
                             ocrpt_format_type format);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Run the report</title>
			<para>
				This function executes the report, constructs
				the result in memory. It returns <literal>true</literal>
				for success, <literal>false</literal> for failure.
				It is a failure if the output format is unset.
				<programlisting>
bool ocrpt_execute(opencreport *o);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Dump report result</title>
			<para>
				Dump the report output on the program's
				standard output channel.
				<programlisting>
void ocrpt_spool(opencreport *o);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Report handler destruction</title>
			<para>
				Calling this function frees up the report handler
				structure and everything created for it, even
				the details that were created by the low level API.
				<programlisting>
void ocrpt_free(opencreport *o);
				</programlisting>
			</para>
		</sect2>
	</sect1>
	<sect1 id="lowlevelapi" xreflabel="Low level C API">
		<title>Low level C API</title>
		<para>
			The <xref linkend="highlevelapi"/> is also part of the
			low level API. The functions described below allow
			creating a report using program code, or simply
			fine tuning the report behavior by mostly using the
			<xref linkend="highlevelapi"/>.
		</para>
		<sect2 id="numerictuning" xreflabel="Numeric behavior related functions">
			<title>Numeric behavior related functions</title>
			<sect3>
				<title><literal>Set numeric precision</literal></title>
				<para>
					The default is 256 bits of floating point precision.
					<programlisting>
void ocrpt_set_numeric_precision_bits(opencreport *o,
                                      mpfr_prec_t prec);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set rounding mode</title>
				<para>
					OpenCReports uses GNU MPFR under the hood and does't
					hide this fact. The MPFR rounding mode constants are
					used as is to set the rounding behaviour.
					The default is <literal>MPFR_RNDN</literal>, round
					to nearest.
					<programlisting>
void ocrpt_set_rounding_mode(opencreport *o,
                             mpfr_rnd_t rndmode);
					</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Locale related functions</title>
			<sect3>
				<title>Set report locale</title>
				<para>
					Setting the locale for the report does not affect
					the main program or other threads. Locale setting
					includes the language, the country. The UTF-8 suffix
					is necessary. E.g.: <literal>en_GB.UTF-8</literal> or
					<literal>de_DE.UTF-8</literal>
					<programlisting>
void ocrpt_set_locale(opencreport *o,
                      const char *locale);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print monetary data in the report locale</title>
				<para>
					A customized monetary printing function was implemented
					for the purposes of the report which MPFR doesn't
					provide. It is used in OpenCReports both internally
					and by unit tests.
					<programlisting>
ssize_t ocrpt_mpfr_strfmon(opencreport *o,
                           char *s, size_t maxsize,
                           const char *format, ...);
					</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="exprfunc" xreflabel="Expression related functions">
			<title>Expression related functions</title>
			<para>
				Expressions in OpenCReports is explained in the
				<xref linkend="expressions"/> chapter.
			</para>
			<sect3>
				<title>Parse an expression string</title>
				<para>
					This function parses an expression string and
					creates an expression tree. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					The <literal>ocrpt_report</literal> pointer may be
					valid or NULL. If valid, the expression is bound
					to this <literal>ocrpt_report</literal>.
					<programlisting>
ocrpt_expr *ocrpt_expr_parse(opencreport *o,
                             ocrpt_report *r,
                             const char *str,
                             char **err);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free an expression parse tree</title>
				<para>
					Free an expression parse tree. If it was bound
					to the passed-in <literal>ocrpt_report</literal>,
					this association is also deleted.
					<programlisting>
void ocrpt_expr_free(opencreport *o,
                     ocrpt_report *r,
                     ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve expression references</title>
				<para>
					This function resolves variable (identifier)
					references in the expression. This is needed
					to bind query columns to expressions that
					use them.
					<programlisting>
void ocrpt_expr_resolve(opencreport *o,
                        ocrpt_report *r,
                        ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Optimize an expression</title>
				<para>
					This function optimizes an expression so
					it may needs fewer computation steps during
					report execution.
					<programlisting>
void ocrpt_expr_optimize(opencreport *o,
                         ocrpt_report *r,
                         ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate an expression</title>
				<para>
					This function evaluates the expression.
					It returns the expression's
					<literal>ocrpt_result</literal> result structure.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>
				</para>
				<para>
					For expressions with query column references,
					this function must be called after
					<literal>ocrpt_query_navigate_next</literal>
					otherwise the result is not valid.
					<programlisting>
ocrpt_result *ocrpt_expr_eval(opencreport *o,
                              ocrpt_report *r,
                              ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get expression result without evaluation</title>
				<para>
					This function returns the expression result
					if it was already evaluated.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>.
					Used by unit tests.
					<programlisting>
ocrpt_result *ocrpt_expr_get_result(opencreport *o,
                                    ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree</title>
				<para>
					Print an expression tree in its processed form on the
					standard output. Used by unit tests.
					<programlisting>
void ocrpt_expr_print(opencreport *o,
                      ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree with subexpressions and their results</title>
				<para>
					Print an expression tree with subexpressions
					and their results in its processed form on the
					standard output. Used by unit tests.
					<programlisting>
void ocrpt_expr_result_deep_print(opencreport *o,
                                  ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Count the number of expression nodes</title>
				<para>
					This function returns the number of expression nodes.
					Used by unit tests to validate optimizazion.
					<programlisting>
int32_t ocrpt_expr_nodes(ocrpt_expr *e);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Initialize expression result type</title>
				<para>
					OpenCReports keeps track of the last three query
					rows and computes three result values for expressions
					for internal reasons. These functions initialize
					the type for either the current result or all results
					of the expression.
					<programlisting>
enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

bool ocrpt_expr_init_result(opencreport *o,
                            ocrpt_expr *e,
                            enum ocrpt_result_type type);

void ocrpt_expr_init_results(opencreport *o,
                             ocrpt_expr *e,
                             enum ocrpt_result_type type);
					</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set an error string as expression result</title>
				<para>
					<programlisting>
ocrpt_result *
ocrpt_expr_make_error_result(opencreport *o,
                             ocrpt_expr *e,
                             const char *format, ...);
					</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1>
		<title>Data source related functions</title>
		<para>
			The following <literal>enum</literal> and <literal>struct</literal>
			types are used by OpenCReports.
			<programlisting>
enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

struct ocrpt_string {
    char *str;
    size_t allocated_len;
    size_t len;
};
typedef struct ocrpt_string ocrpt_string;

struct ocrpt_result {
    enum ocrpt_result_type type;
    ocrpt_string *string;
    mpfr_t number;
    bool number_initialized;
    bool string_owned;
    bool isnull;
    struct tm datetime;
};
typedef struct ocrpt_result ocrpt_result;

struct ocrpt_query_result {
    const char *name;
    bool name_allocated;
    ocrpt_result result;
};
typedef struct ocrpt_query_result ocrpt_query_result;

struct ocrpt_input {
    void (*describe)(ocrpt_query *, ocrpt_query_result **, int32_t *);
    void (*rewind)(ocrpt_query *);
    bool (*next)(ocrpt_query *);
    bool (*populate_result)(ocrpt_query *);
    bool (*isdone)(ocrpt_query *);
    void (*free)(ocrpt_query *);
};
typedef struct ocrpt_input ocrpt_input;
			</programlisting>
		</para>
		<para>
			Data source handling is implemented via <literal>ocrpt_input</literal>
			functions.
		</para>
		<sect2>
			<title><literal>ocrpt_add_datasource</literal></title>
			<para>
				Add a (custom) data source to the report handler.
				<programlisting>
ocrpt_datasource *ocrpt_add_datasource(opencreport *o,
                                       const char *source_name,
                                       const ocrpt_input *input);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_datasource_get</literal></title>
			<para>
				Find the data source using its name. It returns NULL
				if the named data source is not found.
				<programlisting>
ocrpt_datasource *ocrpt_datasource_get(opencreport *o,
                                        const char *source_name);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_validate_datasource</literal></title>
			<para>
				Check that the provided <literal>source</literal> pointer
				is valid for the <literal>o</literal> report handler.
				<programlisting>
ocrpt_datasource *ocrpt_validate_datasource(opencreport *o,
                                            ocrpt_datasource *source);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_add_array_datasource</literal></title>
			<para>
				Add a named array data source. It is optional, as a array
				data source called <literal>array</literal> is added to the
				report handler implicitly.
				<programlisting>
ocrpt_datasource *ocrpt_add_array_datasource(opencreport *o,
                                             const char *source_name);
				</programlisting>
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Query related functions</title>
		<para>
			Queries are super-entities over data sources. They are
			the actual sources of data using a specific data source.
			Multiple queries may use the same data source.
		</para>
		<sect2>
			<title><literal>ocrpt_add_array_query</literal></title>
			<para>
				Add a named query of the array type. The provided
				<literal>array</literal> array contains
				<literal>(rows + 1) * cols</literal> number of
				<literal>char *</literal> pointers, with the first row
				being the column (or field) names. The <literal>types</literal>
				array contains <literal>cols</literal> number of
				<literal>enum ocrpt_result_type</literal> elements to
				indicate the column data type.
				<programlisting>
ocrpt_query *ocrpt_add_array_query(opencreport *o, ocrpt_datasource *source,
                                    const char *name, void *array,
                                    int32_t rows, int32_t cols,
                                    const enum ocrpt_result_type *types);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_add_array_query_as</literal></title>
			<para>
				Add a named query of the array type using the data source name.
				For the other parameters, see the previous function.
				<programlisting>
ocrpt_query *ocrpt_add_array_query_as(opencreport *o, const char *source_name,
                                    const char *name, void *array,
                                    int32_t rows, int32_t cols,
                                    const enum ocrpt_result_type *types);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_query_get_result</literal></title>
			<para>
				Create and get the <literal>ocrpt_query_result</literal>
				array from a query. Output parameter <literal>cols</literal>
				returns the number of columns in the result array. It must
                be (re-)run after ocrpt_navigate_next() since the previously
                returned pointer becomes invalid.
				<programlisting>
ocrpt_query_result *ocrpt_query_get_result(ocrpt_query *q, int32_t *cols);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_add_query_follower</literal></title>
			<para>
				Add a <literal>follower</literal> query to the
				<literal>leader</literal> query. The leader is the primary
				query and the follower will run in parallel with it until
				the leader runs out of rows. In case the leader has more
				rows than the follower, then for rows in the leader where
				there are no follower rows, the follower fields are set to NULL.
				<programlisting>
bool ocrpt_add_query_follower(opencreport *o,
                              ocrpt_query *leader,
                              ocrpt_query *follower);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_add_query_follower_n_to_1</literal></title>
			<para>
				Add an N:1 <literal>follower</literal> query to the
				<literal>leader</literal> query. The leader is the primary
				query and rows from the follower will be matched using the
				<literal>match</literal> expression. If there are multiple
				rows in the follower matching the leader row, then the leader
				row will be listed that many times. For rows in the leader
				where there are no matching rows in the follower, the follower
				fields are set to NULL. It is similar to <literal>LEFT OUTER
				JOIN</literal> in SQL databases. For creating an
				<literal>ocrpt_expr</literal> expression pointer, see the
				next section.
				<programlisting>
bool ocrpt_add_query_follower_n_to_1(opencreport *o,
                                     ocrpt_query *leader,
                                     ocrpt_query *follower,
                                     ocrpt_expr *match);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_free_query</literal></title>
			<para>
				Free a query and remove it from the report handler.
				<programlisting>
void ocrpt_free_query(opencreport *o, ocrpt_query *q);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			 <title><literal>ocrpt_navigate_start</literal></title>
			<para>
				Start query or query set navigation. <literal>q</literal>
				should be the primary query of the report.
				<programlisting>
void ocrpt_navigate_start(opencreport *o, ocrpt_query *q);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_navigate_next</literal></title>
			<para>
				Navigate the query set to the next row. Returns
				<literal>false</literal> if there was no more rows.
				in which case the <literal>ocrpt_query_result</literal>
				arrays for all queries in the query set (returned by
				previous <literal>ocrpt_query_get_result()</literal>
				calls contain invalid data.
				<programlisting>
bool ocrpt_navigate_next(opencreport *o, ocrpt_query *q);
				</programlisting>
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Paper size related functions</title>
		<para>
			Paper size in OpenCReports is handled via
			<ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>.
		</para>
		<para>
			This structure is used in OpenCReports to represent
			paper name and size:
			<programlisting>
struct ocrpt_paper {
    const char *name;
    double width;
    double height;
};
typedef struct ocrpt_paper ocrpt_paper;
			</programlisting>
		</para>
		<sect2>
			<title><literal>ocrpt_get_system_paper</literal></title>
			<para>
				Get the system default <literal>ocrpt_paper</literal>.
				<programlisting>
const ocrpt_paper *ocrpt_get_system_paper(void);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_get_paper_by_name</literal></title>
			<para>
				Get paper size of the specified paper name.
				<programlisting>
const ocrpt_paper *ocrpt_get_paper_by_name(const char *paper);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_set_paper</literal></title>
			<para>
				Set paper for the report using an <literal>ocrpt_paper</literal> structure.
				The contents of the structure is copied.
				<programlisting>
void ocrpt_set_paper(opencreport *o, const ocrpt_paper *paper);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_set_paper_by_name</literal></title>
			<para>
				Set paper for the report using a paper name.
				If the paper name is unknown, the system default paper is set.
				<programlisting>
void ocrpt_set_paper_by_name(opencreport *o, const char *paper);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_get_paper</literal></title>
			<para>
				Get the report's currently set paper.
				<programlisting>
const ocrpt_paper *ocrpt_get_paper(opencreport *o);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_paper_first</literal></title>
			<para>
				Start an iterator for supported paper names and sizes.
				The returned paper structures are library-global but
				the iterator is per report handler. Only one iterator
				per report handler can be run at a time.
				<programlisting>
const ocrpt_paper *ocrpt_paper_first(opencreport *o);
				</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_paper_next</literal></title>
			<para>
				Get the next <literal>ocrpt_paper</literal> structure
				in the iterator. It returns NULL when there is no more
				paper known to the system.
				<programlisting>
const ocrpt_paper *ocrpt_paper_next(opencreport *o);
				</programlisting>
			</para>
		</sect2>
	</sect1>
</chapter>

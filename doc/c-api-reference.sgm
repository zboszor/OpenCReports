<chapter id="c-api-reference" xreflabel="C API Reference">
	<title>C language API reference</title>
	<sect1 id="c_header">
		<title>Header file</title>
		<para>
			For using OpenCReports, this single header must be used:
			<programlisting>#include &lt;opencreport.h&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="highlevelapi" xreflabel="High level C API">
		<title>High level C API</title>
		<para>
			Example code using the high level C API where everything
			concerning the report (including the data source)
			is described in the report XML:
			<programlisting>#include &lt;opencreport.h&gt;

int main(void) {
    opencreport *o = ocrpt_init();

    if (!ocrpt_parse_xml(o, "report.xml")) {
        printf("XML parse error\n");
        ocrpt_free(o);
        return 1;
    }

    ocrpt_set_output_format(o, OCRPT_OUTPUT_PDF);
    ocrpt_execute(o);
    ocrpt_spool(o);
    ocrpt_free(o);
    return 0;
}</programlisting>
		</para>
		<para>
			The above code will load <literal>report.xml</literal>,
			set the output format to PDF, runs the report and prints
			its output on <literal>stdout</literal>.
		</para>
		<sect2 id="rephndinit">
			<title>Report handler initialization</title>
			<para>
				<programlisting>opencreport *
ocrpt_init(void);</programlisting>
			</para>
		</sect2>
		<sect2 id="loadrepxml">
			<title>Load a report XML description</title>
			<para>
				This function loads the specified XML file
				into the report handler. It returns
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
				<programlisting>bool
ocrpt_parse_xml(opencreport *o,
                const char *filename);</programlisting>
			</para>
		</sect2>
		<sect2 id="parsexmlfrombuf">
			<title>Parse report XML description from a buffer</title>
			<para>
				This function parses the buffer as if it contained
				XML contents and loads the details into the report handler.
				It returns <literal>true</literal> for success,
				<literal>false</literal> for failure.
				<programlisting>bool
ocrpt_parse_xml_from_buffer(opencreport *o,
                            const char *buffer,
                            size_t size);</programlisting>
			</para>
		</sect2>
		<sect2 id="setoutpfmt">
			<title>Set report output format</title>
			<para>
				<programlisting>enum ocrpt_format_type {
    OCRPT_OUTPUT_UNSET,
    OCRPT_OUTPUT_PDF,
    OCRPT_OUTPUT_HTML,
    OCRPT_OUTPUT_TXT,
    OCRPT_OUTPUT_CSV,
    OCRPT_OUTPUT_XML
};
typedef enum ocrpt_format_type ocrpt_format_type;

void
ocrpt_set_output_format(opencreport *o,
                        ocrpt_format_type format);</programlisting>
			</para>
		</sect2>
		<sect2 id="setoutpparam">
			<title>Set report output parameter</title>
			<para>
				Set output parameters for the report.
				<programlisting>void
ocrpt_set_output_parameter(opencreport *o,
                           const char *param,
                           const char *value);</programlisting>
			</para>
			<para>
				Possible parameters for the HTML output driver:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							<literal>meta</literal> extends
							the default
							<literal>&lt;meta charset="utf-8"&gt;</literal>.
                            <literal>literal</literal> (see
							The passed-in string value may contain
							the whole <literal>&lt;meta ...&gt;</literal>,
							in which case the inner parameters are
							used only. The <literal>charset</literal>
							specification is ignored. Only the rest is used.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							<literal>suppress_head</literal> suppresses the default
							<literal>&lt;head&gt; ... &lt;/head&gt;</literal> section.
							Possible values to enable suppressing the
							default <literal>&lt;head&gt; ... &lt;/head&gt;</literal>
							are <literal>yes</literal>,
							<literal>true</literal>,
							<literal>on</literal> or any positive non-zero
							number. Anything else disables it.
							Be aware, that the default section contains
							importand CSS stylesheet settings that are
							needed for the correct layout.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Possible parameters for the CSV output driver:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							<literal>csv_filename</literal> sets the file
							name for <literal>Content-Disposition</literal>
							in the HTTP metadata returned by
							<literal>ocrpt_get_content_type()</literal>.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							<literal>csv_as_text</literal> sets the MIME type
							for <literal>Content-Type</literal>
							in the HTTP metadata returned by
							<literal>ocrpt_get_content_type()</literal>
							to <literal>text/plain</literal> when enabled.
							By default it's <literal>text/csv</literal>.
							Possible values to enable it are
							<literal>yes</literal>,
							<literal>true</literal>,
							<literal>on</literal> or any positive non-zero
							number. Anything else disables it.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							<literal>csv_delimiter</literal> (also aliased as
							<literal>csv_delimeter</literal> according to
							the historical typo in RLIB) sets the CSV field
							delimiter to the first character of the string.
							By default it's a comma.
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							<literal>no_quotes</literal> will create a CSV
							output with values unquoted.
							Possible values to enable it are
							<literal>yes</literal>,
							<literal>true</literal>,
							<literal>on</literal> or any positive non-zero
							number. Anything else disables it.
							It takes precedence over
							<literal>only_quote_strings</literal>
						</para>
					</listitem>
					<listitem override="bullet">
						<para>
							<literal>only_quote_strings</literal>
							will create a CSV output with only string
							values quoted.
							Possible values to enable it are
							<literal>yes</literal>,
							<literal>true</literal>,
							<literal>on</literal> or any positive non-zero
							number. Anything else disables it.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Note that some languages (e.g. German, Swedish
				and Hungarian) use comma as the decimal separator
				instead of decimal point. For these languages,
				either set <literal>csv_delimiter</literal> or
				set neither <literal>no_quotes</literal>, nor
				<literal>only_quote_strings</literal>
			</para>
			<para>
				Possible parameters for the XML output driver:
				<itemizedlist>
					<listitem override="bullet">
						<para>
							<literal>xml_rlib_compat</literal> sets the
							flag to create an RLIB compatible XML output.
							Possible values to enable it are
							<literal>yes</literal>,
							<literal>true</literal>,
							<literal>on</literal> or any positive non-zero
							number. Anything else disables it.
						</para>
						<para>
							When enabled, the toplevel element
							will be <literal>&lt;rlib&gt;</literal>
							and <literal>&lt;Report&gt;</literal>s
							inside <literal>&lt;pd&gt;</literal>
							won't be embedded in a
							<literal>report</literal> element.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2 id="runreport">
			<title>Run the report</title>
			<para>
				This function executes the report, constructs
				the result in memory. It returns <literal>true</literal>
				for success, <literal>false</literal> for failure.
				It is a failure if the output format is unset.
				<programlisting>bool
ocrpt_execute(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2 id="dumpreport">
			<title>Dump report result</title>
			<para>
				Dump the report output on the program's
				standard output channel.
				<programlisting>void
ocrpt_spool(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2 id="getresult">
			<title>Get report result</title>
			<para>
				Get the report output. The application
				then can save it as a file.
				<programlisting>const char *
ocrpt_get_output(opencreport *o, size_t *length);</programlisting>
			</para>
		</sect2>
		<sect2 id="getcontenttype">
			<title>Get report content type</title>
			<para>
				Get the report content type for web publishing.
				The content type depends on the output type
				the report was executed with.
				It returns an array of
				<literal>ocrpt_string *</literal> pointers
				for potentially multiple HTTP header lines.
				The last pointer in the array is
				<literal>NULL</literal>.
				<programlisting>const ocrpt_string **
ocrpt_get_content_type(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2 id="rephnddestroy">
			<title>Report handler destruction</title>
			<para>
				Calling this function frees up the report handler
				structure and everything created for it, even
				the details that were created by the low level API.
				<programlisting>void
ocrpt_free(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2 id="getlibver">
			<title>Get library version</title>
			<para>
				This function reports the OpenCReports
				library version.
				<programlisting>const char *
ocrpt_version(void);</programlisting>
			</para>
		</sect2>
	</sect1>
	<sect1 id="lowlevelapi" xreflabel="Low level C API">
		<title>Low level C API</title>
		<para>
			The <xref linkend="highlevelapi"/> is also part of the
			low level API. The functions described below allow
			creating a report using program code, or simply
			fine tuning the report behavior by mostly using the
			<xref linkend="highlevelapi"/>.
		</para>
		<sect2 id="numerictuning" xreflabel="Numeric behavior related functions">
			<title>Numeric behavior related functions</title>
			<sect3 id="setnumprec">
				<title><literal>Set numeric precision</literal></title>
				<para>
					The default is 256 bits of floating point precision.
					The expression string must evaluate to a numeric
					value, the integer part will be used to set
					the number of precision bits for numeric calculations.
					<programlisting>void
ocrpt_set_numeric_precision_bits(opencreport *o,
                                 const char *expr_string);</programlisting>
				</para>
			</sect3>
			<sect3 id="setroundingmode">
				<title>Set rounding mode</title>
				<para>
					Set the rounding mode. The expression string must
					evaluate to a string value with values
					<literal>nearest</literal>,
					<literal>to_minus_inf</literal>,
					<literal>to_inf</literal>,
					<literal>to_zero</literal>,
					<literal>away_from_zero</literal> and
					<literal>faithful</literal>.
					The default is <literal>nearest</literal>.
					<programlisting>void
ocrpt_set_rounding_mode(opencreport *o,
                        const char *expr_string);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="localefuncs">
			<title>Locale related functions</title>
			<sect3 id="setupxlate">
				<title>Set up translation</title>
				<para>
					Setting up the translation needs two parameters:
					the so called <emphasis>translation domain</emphasis>
					and the toplevel directory for the translations.
					It relies on GNU Gettext.
					<programlisting>void
ocrpt_bindtextdomain(opencreport *o,
                     const char *domainname,
                     const char *dirname);</programlisting>
				</para>
			</sect3>
			<sect3 id="setupxlate2">
				<title>Set up translation (delayed variant)</title>
				<para>
					Setting up the translation needs two parameters:
					the so called <emphasis>translation domain</emphasis>
					and the toplevel directory for the translations.
					It relies on GNU Gettext. This function allows
					setting the translation from a supplemental query.
					The passed in expressions strings must evaluate
					to string values, with potential fallbacks to
					plain strings in case of parse errors or if the
					expressions may be interpreted as query columns
					but no such column names exist in any query.
					<programlisting>void
ocrpt_bindtextdomain_from_expr(opencreport *o,
                               const char *domain_expr,
                               const char *dir_expr);</programlisting>
				</para>
			</sect3>
			<sect3 id="setlocale">
				<title>Set report locale</title>
				<para>
					Setting the locale for the report does not affect
					the main program or other threads. Locale setting
					includes the language, the country. The UTF-8 suffix
					is necessary. E.g.: <literal>en_GB.UTF-8</literal> or
					<literal>de_DE.UTF-8</literal>
					<programlisting>void
ocrpt_set_locale(opencreport *o,
                 const char *locale);</programlisting>
				</para>
			</sect3>
			<sect3 id="setlocale2">
				<title>Set report locale (delayed variant)</title>
				<para>
					This function allows setting the locale
					from a supplementary query of the report.
					It is used by the report XML parser code
					and it's a lower priority setting than the
					previous function: the application executing
					the report may need to be run a different locale.
					The expression string must evaluate to a string
					value that's a valid locale string.
					<programlisting>void
ocrpt_set_locale_from_expr(opencreport *o,
                           const char *expr_string);</programlisting>
				</para>
			</sect3>
			<sect3 id="printmoneyinlocale">
				<title>Print monetary data in the report locale</title>
				<para>
					A customized monetary printing function was implemented
					for the purposes of the report which MPFR doesn't
					provide. It is used in OpenCReports both internally
					and by unit tests.
					<programlisting>ssize_t
ocrpt_mpfr_strfmon(opencreport *o,
                   char *s, size_t maxsize,
                   const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="dsqfuncs">
			<title>Data source and query related functions</title>
			<para>
				The following <literal>enum</literal> and
				<literal>struct</literal> types are used by
				OpenCReports for datasources and queries.
				<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

struct ocrpt_datasource;
typedef struct ocrpt_datasource ocrpt_datasource;

struct ocrpt_query;
typedef struct ocrpt_query ocrpt_query;

struct ocrpt_query_result;
typedef struct ocrpt_query_result ocrpt_query_result;

struct ocrpt_input {
    void (*describe)(ocrpt_query *,
                     ocrpt_query_result **,
                     int32_t *);
    void (*rewind)(ocrpt_query *);
    bool (*next)(ocrpt_query *);
    bool (*populate_result)(ocrpt_query *);
    bool (*isdone)(ocrpt_query *);
    void (*free)(ocrpt_query *);
    bool (*set_encoding)(ocrpt_datasource *,
                         const char *);
    void (*close)(const ocrpt_datasource *);
};
typedef struct ocrpt_input ocrpt_input;</programlisting>
			</para>
			<para>
				Data sources in this context are "mini drivers".
				Data source handling is implemented via
				<literal>ocrpt_input</literal> functions.
			</para>
			<para>
				Queries are data providers over data sources. They are
				the actual sources of data using a specific data source.
				Multiple queries may use the same data source.
			</para>
			<sect3 id="addarrayds">
				<title>Add an array datasource</title>
				<para>
					Add an array datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_array(opencreport *o,
                           const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="testdsforarray">
				<title>Test whether a datasource is array based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_array(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="addarrayquery">
				<title>Add an array query</title>
				<para>
					Add an "array query" to the report handler.
					This adds the array pointer and parameters, so
					the array datasource input driver can use it.
					The provided <literal>array</literal> array pointer
					contains <literal>(rows + 1) * cols</literal> number of
					<literal>char *</literal> pointers, with the first row
					being the column (field) names. The
					<literal>types</literal> array contains
					<literal>cols</literal> number of
					<literal>enum ocrpt_result_type</literal> elements to
					indicate the column data type.
					<programlisting>ocrpt_query *
ocrpt_query_add_array(ocrpt_datasource *source,
                      const char *name,
                      const char **array,
                      int32_t rows, int32_t cols,
                      const int32_t *types,
                      int32_t types_cols);</programlisting>
				</para>
				<para>
					If the <literal>types</literal> pointer is
					<literal>NULL</literal>, the column values are treated
					as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3 id="addcsvds">
				<title>Add a CSV datasource</title>
				<para>
					Add a CSV datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_csv(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="testdsforcsv">
				<title>Test whether a datasource is CSV based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_csv(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="addcsvquery">
				<title>Add a CSV query</title>
				<para>
					Add a "CSV query" to the report handler.
					This specifies the file name, so
					the CSV datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_csv(ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const int32_t *types,
                    int32_t types_cols);</programlisting>
				</para>
				<para>
					The <literal>types</literal> array pointer is optional.
					If it is <literal>NULL</literal>, the column values are
					treated as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3 id="addjsonds">
				<title>Add a JSON datasource</title>
				<para>
					Add a JSON datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_json(opencreport *o,
                          const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="testdsforjson">
				<title>Test whether a datasource is JSON based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_json(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="addjsonquery">
				<title>Add a JSON query</title>
				<para>
					Add a "JSON query" to the report handler.
					This specifies the file name, so
					the JSON datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_json(ocrpt_datasource *source,
                     const char *name,
                     const char *filename,
                     const int32_t *types,
                     int32_t types_cols);</programlisting>
				</para>
				<para>
					The JSON file format defined in <xref linkend="jsonds"/>
					contains the way to describe the column data types,
					which is optional in a JSON file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the JSON file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the JSON file doesn't
					contain type specifiers), the column values are
					treated as strings. RLIB didn't have JSON input.
				</para>
			</sect3>
			<sect3 id="addxmlds">
				<title>Add an XML datasource</title>
				<para>
					Add an XML datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_xml(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="testdsforxml">
				<title>Test whether a datasource is XML based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_xml(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="addxmlquery">
				<title>Add an XML query</title>
				<para>
					Add an "XML query" to the report handler.
					This specifies the file name, so
					the XML datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_xml(ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const int32_t *types,
                    int32_t types_cols);</programlisting>
				</para>
				<para>
					The XML file format defined in <xref linkend="xmlds"/>
					contains the way to describe the column data types,
					which is optional in an XML file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the XML file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the XML file doesn't
					contain type specifiers), the column values are
					treated as strings. This is how RLIB operated.
					The OpenCReports XML input file format is RLIB
					compatible without the type specification part.
				</para>
			</sect3>
			<sect3 id="addpgds">
				<title>Add a PostgreSQL datasource</title>
				<para>
					Add a PostgreSQL datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_postgresql(opencreport *o,
                                const char *source_name,
                                const char *host,
                                const char *port,
                                const char *dbname,
                                const char *user,
                                const char *password);

ocrpt_datasource *
ocrpt_datasource_add_postgresql2(opencreport *o,
                                 const char *source_name,
                                 const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="postgresqlds"/>.
				</para>
			</sect3>
			<sect3 id="testdsforpg">
				<title>Test whether a datasource is PostgreSQL based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_postgresql(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="addpgquery">
				<title>Add a PostgreSQL query</title>
				<para>
					Add a SQL query using the PostgreSQL datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_postgresql(ocrpt_datasource *source,
                           const char *name,
                           const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3 id="addmariads">
				<title>Add a MariaDB datasource</title>
				<para>
					Add a MariaDB datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_mariadb(opencreport *o,
                             const char *source_name,
                             const char *host,
                             const char *port,
                             const char *dbname,
                             const char *user,
                             const char *password,
                             const char *unix_socket);

ocrpt_datasource *
ocrpt_datasource_add_mariadb2(opencreport *o,
                              const char *source_name,
                              const char *optionfile,
                              const char *group);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="mariadbds"/>.
				</para>
			</sect3>
			<sect3 id="testdsformaria">
				<title>Test whether a datasource is MariaDB based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_mariadb(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="addmariaquery">
				<title>Add a MariaDB query</title>
				<para>
					Add an SQL query using the MariaDB datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_mariadb(ocrpt_datasource *source,
                        const char *name,
                        const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3 id="addodbcds">
				<title>Add an ODBC datasource</title>
				<para>
					Add an ODBC datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_odbc(opencreport *o,
                          const char *source_name,
                          const char *dbname,
                          const char *user,
                          const char *password);

ocrpt_datasource *
ocrpt_datasource_add_odbc2(opencreport *o,
                           const char *source_name,
                           const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="odbcds"/>.
				</para>
			</sect3>
			<sect3 id="testdsforodbc">
				<title>Test whether a datasource is ODBC based</title>
				<para>
					<programlisting>bool
ocrpt_datasource_is_odbc(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="addodbcquery">
				<title>Add an ODBC query</title>
				<para>
					Add an SQL query using the ODBC datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_odbc(ocrpt_datasource *source,
                     const char *name,
                     const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3 id="findds">
				<title>Find a datasource</title>
				<para>
					Find the data source using its name.
					It returns NULL if the named data source
					is not found.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_get(opencreport *o,
                     const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="addcustomds">
				<title><literal>Add a custom datasource</literal></title>
				<para>
					Add a custom data source to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_add_datasource(opencreport *o,
                     const char *source_name,
                     const ocrpt_input *input);</programlisting>
				</para>
			</sect3>
			<sect3 id="setdsencoding">
				<title><literal>Set the encoding of a datasource</literal></title>
				<para>
					Set the encoding of a datasource in case
					if it's not already UTF-8, so data provided by
					it is automatically converted.
					<programlisting>void
ocrpt_datasource_set_encoding(ocrpt_datasource *source,
                              const char *encoding);</programlisting>
				</para>
			</sect3>
			<sect3 id="freeds">
				<title><literal>Free a datasource</literal></title>
				<para>
					Free a datasource from the opencreport structure
					it was added to. It's not needed to be called,
					all datasources are automatically free with
					<literal>ocrpt_free()</literal>
					<programlisting>void
ocrpt_datasource_free(ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3 id="findquery">
				<title><literal>Find a query</literal></title>
				<para>
					Find a query using its name.
					<programlisting>ocrpt_query *
ocrpt_query_get(opencreport *o,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3 id="getcurrentrowofquery">
				<title><literal>Get the current data row from a query</literal></title>
				<para>
					Create (first call) or get the <literal>ocrpt_query_result</literal>
					array from a query. Output parameter <literal>cols</literal>
					returns the number of columns in the result array. It must
					be re-run after ocrpt_navigate_next() since the previously
					returned pointer becomes invalid.
					<programlisting>ocrpt_query_result *
ocrpt_query_get_result(ocrpt_query *q,
                       int32_t *cols);</programlisting>
				</para>
			</sect3>
			<sect3 id="getcolname">
				<title><literal>Get column name</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal> result
					from <literal>ocrpt_query_get_result()</literal>,
					the column names can be discovered from a query.
					<programlisting>const char *
ocrpt_query_result_column_name(ocrpt_query_result *qr,
                               int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3 id="getcoldata">
				<title><literal>Get column data</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal>
					result from
					<literal>ocrpt_query_get_result()</literal>, get a
					pointer to the column data in its internal (hidden)
					representation.
					<programlisting>ocrpt_result *
ocrpt_query_result_column_result(ocrpt_query_result *qr,
                                 int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3 id="addfollowerquery">
				<title><literal>Add a follower query</literal></title>
				<para>
					Add a <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and the follower will run in parallel with it until
					the leader runs out of rows. In case the leader has more
					rows than the follower, then for rows in the leader where
					there are no follower rows, the follower fields are set to NULL.
					<programlisting>bool
ocrpt_query_add_follower(ocrpt_query *leader,
                         ocrpt_query *follower);</programlisting>
				</para>
			</sect3>
			<sect3 id="addn1followerquery">
				<title><literal>Add an N:1 follower query</literal></title>
				<para>
					Add an N:1 <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and rows from the follower will be matched using the
					<literal>match</literal> expression. If there are multiple
					rows in the follower matching the leader row, then the leader
					row will be listed that many times. For rows in the leader
					where there are no matching rows in the follower, the follower
					fields are set to NULL. It is similar to <literal>LEFT OUTER
					JOIN</literal> in SQL databases. For creating an
					<literal>ocrpt_expr</literal> expression pointer, see the
					next section.
					<programlisting>bool
ocrpt_query_add_follower_n_to_1(ocrpt_query *leader,
                                ocrpt_query *follower,
                                ocrpt_expr *match);</programlisting>
				</para>
			</sect3>
			<sect3 id="freequery">
				<title><literal>Free a query</literal></title>
				<para>
					Free a query and remove it from the report handler.
					It's optional. <literal>ocrpt_free()</literal> frees
					the queries added to the <literal>opencreport</literal>
					structure.
					<programlisting>void
ocrpt_query_free(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="startmainquery">
				<title><literal>Start the main query</literal></title>
				<para>
					Start query (or query set) navigation.
					<literal>q</literal> should be the primary query
					of the report.
					<programlisting>void
ocrpt_query_navigate_start(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="gonextrow">
				<title><literal>Navigate to the next query row</literal></title>
				<para>
					Navigate the query (or query set) to the next row. Returns
					<literal>false</literal> if there was no more rows.
					in which case the <literal>ocrpt_query_result</literal>
					arrays for all queries in the query set (returned by
					previous <literal>ocrpt_query_get_result()</literal>
					calls contain invalid data.
					<programlisting>bool
ocrpt_query_navigate_next(ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3 id="arraydiscoveryfunc" xreflabel="Array discovery function">
				<title><literal>API specific array discovery function</literal></title>
				<para>
					For array data sources and queries, OpenCReports
					needs a way to to find the data array and the
					supplementary type identifier array.
					These are language specific. The below ones
					are the C specific ones. The override function
					is also provided to set a new discovery function.
					The discovery function <emphasis>should</emphasis>
					return the dimensions for both the 2D
					<literal>array</literal> and the 1D
					<literal>coltypes</literal> arrays.
					<programlisting>typedef void
(*ocrpt_query_discover_func)(const char *,
                             void **,
                             int32_t *,
                             int32_t *,
                             const char *,
                             void **,
                             int32_t *);

void
ocrpt_query_set_discover_func(ocrpt_query_discover_func func);

extern ocrpt_query_discover_func ocrpt_query_discover_array;

void
ocrpt_query_discover_array_c(const char *arrayname,
                             void **array,
                             int32_t *rows,
                             int32_t *cols,
                             const char *typesname,
                             void **types,
                             int32_t *types_cols);</programlisting>
				</para>
				<para>
					Note that the C specific generic discovery function
					does not and cannot return the array dimensions,
					since there is no official API related to
					<literal>dlsym()</literal> that would return
					the size associated with a symbol.
					It's up to the application writers to come up
					with a smarter (application specific) discovery
					function that also returns the array dimensions.
					With such a smart discovery function, one can specify
					the array and the column types array name without
					the related dimensions, i.e. the <literal>rows</literal>
					and <literal>cols</literal> specifiers in
					<xref linkend="arrayqueries"/> and
					<xref linkend="filequeries"/>.
				</para>
			</sect3>
		</sect2>
		<sect2 id="exprfunc" xreflabel="Expression related functions">
			<title>Expression related functions</title>
			<para>
				Expressions in OpenCReports is explained in the
				<xref linkend="expressions"/> chapter.
			</para>
			<sect3 id="parseexpr">
				<title>Parse an expression string</title>
				<para>
					This function parses an expression string and
					creates an expression tree. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					<programlisting>ocrpt_expr *
ocrpt_expr_parse(opencreport *o,
                 const char *expr_string,
                 char **err);</programlisting>
				</para>
				<para>
					The returned pointer must be freed with
					<literal>ocrpt_expr_free()</literal>.
				</para>
			</sect3>
			<sect3 id="parsereportexpr">
				<title>Parse an expression string and bind it to a report</title>
				<para>
					This function parses an expression string,
					creates an expression tree and binds it to
					a report. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					<programlisting>ocrpt_expr *
ocrpt_report_expr_parse(ocrpt_report *r,
                        const char *expr_string,
                        char **err);</programlisting>
				</para>
				<para>
					The returned pointer is automatically freed by
					<literal>ocrpt_free()</literal>
				</para>
			</sect3>
			<sect3 id="freeexpr">
				<title>Free an expression parse tree</title>
				<para>
					Free an expression parse tree. If it was bound
					to the passed-in <literal>ocrpt_report</literal>,
					this association is also deleted. Alternatively,
					the expression doesn't need to be freed if it was
					bound to a report when it was parsed, as it will be
					automatically freed when freeing either the report,
					or the global <literal>opencreport</literal> structure.
					<programlisting>void
ocrpt_expr_free(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="resolveexpr">
				<title>Resolve expression references</title>
				<para>
					This function resolves variable (identifier)
					references in the expression. This is needed
					to bind query columns to expressions that
					use them.
					<programlisting>void
ocrpt_expr_resolve(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="optimizeexpr">
				<title>Optimize an expression</title>
				<para>
					This function optimizes an expression so
					it may needs fewer computation steps during
					report execution.
					<programlisting>void
ocrpt_expr_optimize(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="evalexpr">
				<title>Evaluate an expression</title>
				<para>
					This function evaluates the expression.
					It returns the expression's
					<literal>ocrpt_result</literal> result structure.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>
				</para>
				<para>
					For expressions with query column references,
					this function must be called after
					<literal>ocrpt_query_navigate_next</literal>
					otherwise the result is not valid.
					<programlisting>ocrpt_result *
ocrpt_expr_eval(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="getexprresultwnoeval">
				<title>Get expression result without evaluation</title>
				<para>
					This function returns the expression result
					if it was already evaluated.
					The result <emphasis>must not</emphasis> be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>.
					Used by unit tests.
					<programlisting>ocrpt_result *
ocrpt_expr_get_result(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="printexpr">
				<title>Print an expression tree</title>
				<para>
					Print an expression tree in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_print(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="printexprwresult">
				<title>Print an expression tree with subexpressions and their results</title>
				<para>
					Print an expression tree with subexpressions
					and their results in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void
ocrpt_expr_result_deep_print(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="exprnodesnum">
				<title>Count the number of expression nodes</title>
				<para>
					This function returns the number of expression nodes.
					Used by unit tests to validate optimizazion.
					<programlisting>int32_t
ocrpt_expr_nodes(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="initexprtype">
				<title>Initialize expression result type</title>
				<para>
					OpenCReports keeps track of the last three query
					rows and computes three result values for expressions
					for internal reasons. These functions initialize
					the type for either the current result or all results
					of the expression.
					<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

bool ocrpt_expr_init_result(ocrpt_expr *e,
                            enum ocrpt_result_type type);

void ocrpt_expr_init_results(ocrpt_expr *e,
                             enum ocrpt_result_type type);</programlisting>
				</para>
			</sect3>
			<sect3 id="seterror">
				<title>Set an error string as expression result</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_expr_make_error_result(ocrpt_expr *e,
                             const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3 id="setstartflag">
				<title>Set start value flag for an iterative expression</title>
				<para>
					Set whether the iterative expression's first
					value is computed from its base expression
					or from its result expression.
					<programlisting>void
ocrpt_expr_set_iterative_start_value(ocrpt_expr *e,
                                     bool start_with_init);</programlisting>
				</para>
			</sect3>
			<sect3 id="getexprcurval">
				<title>Get current value of an expression in base type</title>
				<para>
					Get the current value of an expression in a C base
					type. Used by parsing report description XML files
					and unit tests.
					<programlisting>const char *
ocrpt_expr_get_string(ocrpt_expr *e);

long
ocrpt_expr_get_long(ocrpt_expr *e);

double
ocrpt_expr_get_double(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="setexprcurval">
				<title>Set current value of an expression in a base type</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_expr_set_string(ocrpt_expr *e,
                            const char *s);

void
ocrpt_expr_set_long(ocrpt_expr *e,
                          long l);

void
ocrpt_expr_set_double(ocrpt_expr *e,
                            double d);</programlisting>
				</para>
			</sect3>
			<sect3 id="setnthexprvalue">
				<title>Set nth value of an expression in a base type</title>
				<para>
					Expressions use <literal>OCRPT_EXPR_RESULTS</literal>
					number of values. With these functions, any of them
					can be set. Used by unit tests.
					<programlisting>void
ocrpt_expr_set_nth_result_string(ocrpt_expr *e,
                                       int which,
                                       const char *s);

void
ocrpt_expr_set_nth_result_long(ocrpt_expr *e,
                                     int which,
                                     long l);

void
ocrpt_expr_set_nth_result_double(ocrpt_expr *e,
                                       int which,
                                       double d);</programlisting>
				</para>
			</sect3>
			<sect3 id="cmpexprvalues">
				<title>Compare the current of an expression with its previous value</title>
				<para>
					Compare the current value of an expression with its
					previous value and return <literal>true</literal>
					if they are equal. It's used to implement
					<xref linkend="breaks"/>.
					<programlisting>bool
ocrpt_expr_cmp_results(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3 id="setexprdelayed">
				<title>Set delayed flag of an expression</title>
				<para>
					<programlisting>void
ocrpt_expr_set_delayed(ocrpt_expr *e,
                       bool delayed);</programlisting>
				</para>
			</sect3>
			<sect3 id="setexprfieldexprref">
				<title>Set field expression reference for an expression</title>
				<para>
					If <literal>e</literal> contains <literal>r.value</literal>,
					the expression <literal>rvalue</literal> will be used to
					resolve this reference.
					<programlisting>void
ocrpt_expr_set_field_expr(ocrpt_expr *e,
                          ocrpt_expr *rvalue);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="resultfuncs">
			<title>Column data or expression result related functions</title>
			<para>
				The internal type <literal>ocrpt_result</literal> holds
				values either for query columns or expression results.
			</para>
			<sect3 id="createexprresult">
				<title>Create an expression result</title>
				<para>
					The returned pointer must be freed with
					<literal>ocrpt_result_free()</literal>.
					<programlisting>ocrpt_result *
ocrpt_result_new(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="getexprresulttype">
				<title>Get expression result type</title>
				<para>
					<programlisting>enum ocrpt_result_type
ocrpt_result_get_type(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="copyexprresult">
				<title>Copy an expression result</title>
				<para>
					Copy expression result from source to
					destination. Both results must have been
					created for the same
					<literal>opencreport</literal> structure,
					either explicitly with <literal>ocrpt_result_new()</literal>
					or implicitly with an expression parsed for
					this <literal>opencreport</literal> structure
					or a report structure owned by it.
					<programlisting>void
ocrpt_result_copy(ocrpt_result *dst,
                  ocrpt_result *src);</programlisting>
				</para>
			</sect3>
			<sect3 id="printexprresult">
				<title>Print an expression result</title>
				<para>
					Used by unit tests.
					<programlisting>void
ocrpt_result_print(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="freeexprresult">
				<title>Free an expression result</title>
				<para>
					<programlisting>void
ocrpt_result_free(ocrpt_result *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisnull">
				<title>Detect whether a column result is NULL</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is NULL.
					<programlisting>bool
ocrpt_result_isnull(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisnumeric">
				<title>Detect whether a column result is numeric</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is numeric.
					<programlisting>bool
ocrpt_result_isnumber(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="getresultnumericvalue">
				<title>Get the numeric value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the numeric column value. It returns  NULL
					if the column is:
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a numeric result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>mpfr_ptr
ocrpt_result_get_number(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisstring">
				<title>Detect whether a column result is string</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is string.
					<programlisting>bool
ocrpt_result_isstring(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="getresultstringvalue">
				<title>Get the string value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the string column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a string result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>ocrpt_string *
ocrpt_result_get_string(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisdatetime">
				<title>Detect whether a column result is datetime</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the column value is datetime.
					<programlisting>bool
ocrpt_result_isdatetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="getresultdatetimevalue">
				<title>Get the datetime value of a column result</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					get the datetime column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a datetime result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>const struct tm *
ocrpt_result_get_datetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resultisinterval">
				<title>Detect whether a datetime column result is interval</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value is interval.
					<programlisting>bool
ocrpt_result_datetime_is_interval(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resulthasvaliddate">
				<title>Detect whether a datetime column result has valid date</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid date.
					<programlisting>bool
ocrpt_result_datetime_is_date_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3 id="resulthasvalidtime">
				<title>Detect whether a datetime column result has valid time</title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from a query column or an expression,
					detect whether the datetime column value has valid time.
					<programlisting>bool
ocrpt_result_datetime_is_time_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="uservarrelatedfuncs">
			<title>Variable related functions</title>
			<para>
				Variables can be created for a report using
				the API.
			</para>
			<sect3 id="createbasicuservar">
				<title>Create a basic variable</title>
				<para>
					Using this function, any variable type except
					<literal>OCRPT_VARIABLE_CUSTOM</literal>
					may be created. For a custom variable,
					see the next function.
					<programlisting>enum ocrpt_var_type {
    OCRPT_VARIABLE_EXPRESSION,
    OCRPT_VARIABLE_COUNT,
    OCRPT_VARIABLE_COUNTALL,
    OCRPT_VARIABLE_SUM,
    OCRPT_VARIABLE_AVERAGE,
    OCRPT_VARIABLE_AVERAGEALL,
    OCRPT_VARIABLE_LOWEST,
    OCRPT_VARIABLE_HIGHEST,
    OCRPT_VARIABLE_CUSTOM
};
typedef enum ocrpt_var_type ocrpt_var_type;

ocrpt_var *
ocrpt_variable_new(ocrpt_report *r,
                   ocrpt_var_type type,
                   const char *name,
                   const char *expr,
                   const char *reset_on_break_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="createcustomuservar">
				<title>Create a custom variable</title>
				<para>
					Create a custom variable of the specified type
					with the specified subexpressions.
					<programlisting>ocrpt_var *
ocrpt_variable_new_full(ocrpt_report *r,
                        enum ocrpt_result_type type,
                        const char *name,
                        const char *baseexpr,
                        const char *intermedexpr,
                        const char *intermed2expr,
                        const char *resultexpr,
                        const char *reset_on_break_name);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservargetsubexprs">
				<title>Get subexpressions of a variable</title>
				<para>
					Get subexpressions of a previously created
					basic or custom variable.
					<programlisting>ocrpt_expr *
ocrpt_variable_baseexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermedexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermed2expr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_resultexpr(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservarsetprecalc">
				<title>Set precalculate flag for a variable</title>
				<para>
					The expression must evaluate to a
					numeric (boolean) value.
					<programlisting>void
ocrpt_variable_set_precalculate(ocrpt_var *var, 
                                const char *expr_string);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservarresolve">
				<title>Resolve a variable</title>
				<para>
					Resolve subexpressions of a variable
					so it can be evaluated correctly.
					<programlisting>void
ocrpt_variable_resolve(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
			<sect3 id="uservareval">
				<title>Evaluate a variable</title>
				<para>
					After evaluation, the result is in the
					expression returned by
					<literal>ocrpt_variable_resultexpr()</literal>.
					<programlisting>void
ocrpt_variable_evaluate(ocrpt_var *v);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="breakrelatedfuncs">
			<title>Break related functions</title>
			<sect3 id="createbreak">
				<title>Create a break</title>
				<para>
					Create a break. No need to free it,
					<literal>ocrpt_free()</literal> does it.
					<programlisting>ocrpt_break *
ocrpt_break_new(ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakattfuncs">
				<title>Set attribute flag expressions for a break</title>
				<para>
					Set break attributes from expression strings
					for <literal>headernewpage</literal> and
					<literal>suppressblank</literal>.
					There is a 3rd flag accepted in the report
					XML DTD called <literal>newpage</literal>
					which is not represented (ignored) in the API,
					because it's also ignored in RLIB and is only
					handled for RLIB compatibility.
					<programlisting>void
ocrpt_break_set_headernewpage(ocrpt_break *br,
                              const char *headernewpage);

void
ocrpt_break_set_suppressblank(ocrpt_break *br,
                              const char *suppressblank);</programlisting>
				</para>
				<para>
					<literal>headernewpage="yes"</literal> instructs the
					layout to render <literal>&lt;BreakHeader&gt;</literal>
					on a new page.
				</para>
				<para>
					<literal>suppressblank="yes"</literal> instructs the
					layout to suppress <literal>&lt;BreakHeader&gt;</literal>
					if any of the <literal>&lt;BreakField&gt;</literal>s
					are <literal>NULL</literal> value or an empty string,
					if the break field is of the string type.
				</para>
			</sect3>
			<sect3 id="breakgetbyname">
				<title>Get break using its name</title>
				<para>
					Get the pointer to the break using its name.
					<programlisting>ocrpt_break *
ocrpt_break_get(ocrpt_report *r,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakgetname">
				<title>Get the name of a break</title>
				<para>
					Get the name of the break using its structure
					pointer.
					<programlisting>const char *
ocrpt_break_get_name(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakaddbreakfield">
				<title>Add a watched expression to a break</title>
				<para>
					<programlisting>bool
ocrpt_break_add_breakfield(ocrpt_break *br,
                           ocrpt_expr *bf);</programlisting>
				</para>
			</sect3>
			<sect3 id="iteratebreaks">
				<title>Iterate over breaks of a report</title>
				<para>
					Iterate over breaks of a report. The first call
					needs the iterator list pointer to be set to NULL.
					<programlisting>ocrpt_break *
ocrpt_break_get_next(ocrpt_report *r,
                     ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakresolveandopt">
				<title>Resolve and optimize break fields</title>
				<para>
					<programlisting>void
ocrpt_break_resolve_fields(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakchecktrigger">
				<title>Check whether the break triggers</title>
				<para>
					<programlisting>bool
ocrpt_break_check_fields(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakcheckblank">
				<title>Check whether break field values are blank</title>
				<para>
					The second parameter <literal>evaluate</literal>
					allows skipping evaluating the breakfield values.
					(This is an optimization in case it's executed after
					<literal>ocrpt_break_check_fields()</literal> which
					already evaluated the breakfields.)
					<programlisting>bool
ocrpt_break_check_blank(ocrpt_break *br,
                        bool evaluate);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakresetvars">
				<title>Reset variables for the break</title>
				<para>
					<programlisting>void
ocrpt_break_reset_vars(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="userfuncfuncs">
			<title>Function related functions</title>
			<sect3 id="adduserfunc">
				<title>Add a user defined function</title>
				<para>
					Add a user defined function by specifying
					the name, the function pointer that contains
					the implementation, the number of operands
					(0 or greater for fixed number or operands,
					-1 is varying number of operands) and
					the function mathematical properties
					that help optimizing it.
					<programlisting>bool
ocrpt_function_add(opencreport *o,
                   const char *fname,
                   ocrpt_function_call func,
                   void *user_data,
                   int32_t n_ops,
                   bool commutative,
                   bool associative,
                   bool left_associative,
                   bool dont_optimize);</programlisting>
				</para>
				<para>
					Adding a user defined function with
					a name of a pre-existing function will
					override it.
				</para>
				<para>
					OpenCReports functions are called with the
					parameters as declared below.
					<programlisting>#define OCRPT_FUNCTION_PARAMS \
    ocrpt_expr *e, void *user_data</programlisting>
				</para>
				<para>
					OpenCReports functions may be declared
					with these convenience symbols below.
					<programlisting>#define OCRPT_FUNCTION(name) \
    void name(OCRPT_FUNCTION_PARAMS)

#define OCRPT_STATIC_FUNCTION(name) \
    static void name(OCRPT_FUNCTION_PARAMS)</programlisting>
				</para>
				<para>
					The above function
					(<literal>ocrpt_function_add()</literal>)
					is called with a function pointer which has
					this type:
					<programlisting>typedef void
(*ocrpt_function_call)(OCRPT_FUNCTION_PARAMS);</programlisting>
				</para>
			</sect3>
			<sect3 id="findfunc">
				<title>Find a named function</title>
				<para>
					<programlisting>const ocrpt_function *
ocrpt_function_get(opencreport *o,
                   const char *fname);</programlisting>
				</para>
			</sect3>
			<sect3 id="exprgetops">
				<title>Get number of operands for an expression (function)</title>
				<para>
					In an expression tree, functions
					are represented as subexpressions with
					operands. This call may be used by OpenCReports
					functions to inspect whether the number of
					operands is in the expected range.
					<programlisting>int32_t
ocrpt_expr_get_num_operands(ocrpt_expr *e);
</programlisting>
				</para>
			</sect3>
			<sect3 id="expropgetvalue">
				<title>Get current value of a function operand</title>
				<para>
					This function is used by OpenCReports functions
					internally to compute the result from its
					operands.
					<programlisting>ocrpt_result *
ocrpt_expr_operand_get_result(ocrpt_expr *e,
                              int32_t opnum);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="partandreportfuncs">
			<title>Report part and report related functions</title>
			<sect3 id="createpart">
				<title>Create a report part</title>
				<para>
					<programlisting>ocrpt_part *
ocrpt_part_new(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="createpartrow">
				<title>Create a row in a report part</title>
				<para>
					<programlisting>ocrpt_part_row *
ocrpt_part_new_row(ocrpt_part *p);</programlisting>
				</para>
			</sect3>
			<sect3 id="createpartcol">
				<title>Create a column in report part row</title>
				<para>
					<programlisting>ocrpt_part_column *
ocrpt_part_row_new_column(ocrpt_part_row *pr);</programlisting>
				</para>
			</sect3>
			<sect3 id="createpartreport">
				<title>Create a new report in a part column</title>
				<para>
					<programlisting>ocrpt_report *
ocrpt_part_column_new_report(ocrpt_part_column *pd);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportiterators">
				<title>Report part related iterators</title>
				<para>
					Iterators for getting report parts, part rows,
					columns in rows and reports in columns.
					Every iterator function must be called
					the first time with the list pointer set to NULL.
					<programlisting>ocrpt_part *
ocrpt_part_get_next(opencreport *o,
                    ocrpt_list **list);

ocrpt_part_row *
ocrpt_part_row_get_next(ocrpt_part *p,
                        ocrpt_list **list);

ocrpt_part_column *
ocrpt_part_column_get_next(ocrpt_part_row *pr,
                           ocrpt_list **list);

ocrpt_report *
ocrpt_report_get_next(ocrpt_part_column *pd,
                      ocrpt_list **list);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportsetmainquery">
				<title>Set the main query for a report</title>
				<para>
					Set the main query for a report either by
					the query structure pointer, or from expression.
					The expression must resolve to a string value,
					with fallback to a plain string.
					<programlisting>void
ocrpt_report_set_main_query(ocrpt_report *r,
                            const ocrpt_query *query);

void
ocrpt_report_set_main_query_from_expr(ocrpt_report *r,
                                    const char *expr_string);</programlisting>
				</para>
				<para>
					See <xref linkend="reportqueryname"/>.
					Unlike with the XML description, where the first
					globally declared query is used for the report
					if its main query is not set, the default via
					the low level API is unset.
				</para>
			</sect3>
			<sect3 id="reportgetcurrentrownum">
				<title>Get the current row number of the main query</title>
				<para>
					The row number starts from 1.
					<programlisting>long
ocrpt_report_get_query_rownum(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportresolvevars">
				<title>Resolve all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_variables(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportevalvars">
				<title>Evaluate all report variables</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_variables(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportresolvebreaks">
				<title>Resolve all report breaks</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_breaks(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportresolveexprs">
				<title>Resolve all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_resolve_expressions(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportevalexprs">
				<title>Evaluate all report expressions</title>
				<para>
					<programlisting>void
ocrpt_report_evaluate_expressions(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="layoutfuncs">
			<title>Layout related functions</title>
			<sect3 id="layoutglobalopts">
				<title>Global layout options</title>
				<sect4 id="layoutsizeunit">
					<title>Set "size unit" option</title>
					<para>
						See <xref linkend="sizeunit"/>.
						The expression string must evaluate to
						a string value, where <literal>points</literal>
						will set the layout rendering to use
						<emphasis>points</emphasis> for size units.
						Any other value will make the layout rendering
						use the convoluted RLIB compatible size units,
						mostly based on font sizes.
						<programlisting>void
ocrpt_set_size_unit(opencreport *o,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="layoutnqsnd">
					<title>Set "no query show NoData" option</title>
					<para>
						See <xref linkend="noqueryshownodata"/>.
						The expression string should evaluate to
						a boolean value.
						<programlisting>void
ocrpt_set_noquery_show_nodata(opencreport *o,
                              const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="layoutrhal">
					<title>Set "report height after last" option</title>
					<para>
						See <xref linkend="reportheightafterlast"/>.
						The expression string should evaluate to
						a boolean value.
						<programlisting>void
ocrpt_set_report_height_after_last(opencreport *o,
                                   const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partopts">
				<title>Report part options</title>
				<sect4 id="setpartiter">
					<title>Set part iterations</title>
					<para>
						See <xref linkend="partiter"/>.
						The expression string must evaluate to
						a numeric value.
						<programlisting>void
ocrpt_part_set_iterations(ocrpt_part *p,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartfontname">
					<title>Set part font name</title>
					<para>
						See <xref linkend="partfontname"/>.
						<programlisting>void
ocrpt_part_set_font_name(ocrpt_part *p,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartfontsize">
					<title>Set part font size</title>
					<para>
						See <xref linkend="partfontsize"/>.
						<programlisting>void
ocrpt_part_set_font_size(ocrpt_part *p,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartpapertype">
					<title>Set part paper type</title>
					<para>
						See <xref linkend="papertype"/>.
						<programlisting>void
ocrpt_part_set_paper_by_name(ocrpt_part *p,
                             const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="setpartorientation">
					<title>Set part paper's orientation</title>
					<para>
						See <xref linkend="partpageorientation"/>.
						The expression string must evaluate to a string
						value, with possible options of
						<literal>portrait</literal> and
						<literal>landscape</literal>. By default,
						the part uses <literal>portrait</literal>
						orientation.
						<programlisting>void
ocrpt_part_set_orientation(ocrpt_part *p,
                           const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partsetmargins">
					<title>Set part margins</title>
					<para>
						See <xref linkend="marginsettings"/>.
						The margin values must be passed in via strings
						as they can be expressions.
						<programlisting>void
ocrpt_part_set_top_margin(ocrpt_part *p,
                          const char *expr_string);

void
ocrpt_part_set_bottom_margin(ocrpt_part *p,
                             const char *expr_string);

void
ocrpt_part_set_left_margin(ocrpt_part *p,
                           const char *expr_string);

void
ocrpt_part_set_right_margin(ocrpt_part *p,
                            const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partsetsuppress">
					<title>Set part suppression</title>
					<para>
						See <xref linkend="partsuppress"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>void
ocrpt_part_set_suppress(ocrpt_part *p,
                        const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partsetphsfp">
					<title>Set part's page header suppressed on the first page</title>
					<para>
						See <xref linkend="suppresspageheaderfirstpage"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>void
ocrpt_part_set_suppress_pageheader_firstpage(ocrpt_part *p,
                                             const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partrowopts">
				<title>Part row options</title>
				<sect4 id="partrowsetsuppress">
					<title>Set part row suppression</title>
					<para>
						See <xref linkend="partrowsuppress"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>void
ocrpt_part_row_set_suppress(ocrpt_part_row *pr,
                            const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partrowsetnewpage">
					<title>Set part row new page</title>
					<para>
						See <xref linkend="partrownewpage"/>.
						The expression string must evaluate to
						a numeric (boolean) value.
						<programlisting>void
ocrpt_part_row_set_newpage(ocrpt_part_row *pr,
                           const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partrowsetlayout">
					<title>Set part row layout mode</title>
					<para>
						See <xref linkend="partrowlayout"/>.
						The expression string must evaluate
						to a string value, with possible options
						<literal>flow</literal> and
						<literal>fixed</literal>. This setting
						is ignored, it's only accepted for RLIB
						compatibility.
						<programlisting>void
ocrpt_part_row_set_layout(ocrpt_part_row *pr,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partcolopts">
				<title>Part column options</title>
				<sect4 id="partcolsetsuppress">
					<title>Set part column suppression</title>
					<para>
						See <xref linkend="partcolsuppress"/>.
						The expression must evaluate to a numeric
						(boolean) value.
						<programlisting>void
ocrpt_part_column_set_suppress(ocrpt_part_column *pd,
                               const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetwidth">
					<title>Set part column width</title>
					<para>
						See <xref linkend="partcolwidth"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_part_column_set_width(ocrpt_part_column *pd,
                            const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetheight">
					<title>Set part column height</title>
					<para>
						See <xref linkend="partcolheight"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_part_column_set_height(ocrpt_part_column *pd,
                             const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetborderwidth">
					<title>Set part column border width</title>
					<para>
						See <xref linkend="pdborderwidth"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_part_column_set_border_width(ocrpt_part_column *pd,
                                   const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetbordercolor">
					<title>Set part column border color</title>
					<para>
						See <xref linkend="pdbordercolor"/>.
						The expression must evaluate to a string
						value with a valid color name or specification.
						<programlisting>void
ocrpt_part_column_set_border_color(ocrpt_part_column *pd,
                                   const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetcolumns">
					<title>Set part column's number of detail columns</title>
					<para>
						See <xref linkend="detailcolumns"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_part_column_set_detail_columns(ocrpt_part_column *pd,
                                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="partcolsetpadding">
					<title>Set part column's detail column padding</title>
					<para>
						See <xref linkend="columnpadding"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_part_column_set_column_padding(ocrpt_part_column *pd,
                                     const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="reportsopts">
				<title>Report options</title>
				<sect4 id="reportsetsuppress">
					<title>Set report suppression</title>
					<para>
						See <xref linkend="reportsuppress"/>.
						The expression must evaluate to a numeric
						(boolean) value.
						<programlisting>void
ocrpt_report_set_suppress(ocrpt_report *r,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetiteration">
					<title>Set report iterations</title>
					<para>
						See <xref linkend="reportiter"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_report_set_iterations(ocrpt_report *r,
                            const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetfontname">
					<title>Set report font name</title>
					<para>
						See <xref linkend="reportfontname"/>.
						The expression must evaluate to a string
						value, with fallback to plain string:
						in case of a parsing error, the value
						string is taken as is.
						<programlisting>void
ocrpt_report_set_font_name(ocrpt_report *r,
                           const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetfontsize">
					<title>Set report font size</title>
					<para>
						See <xref linkend="reportfontsize"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_report_set_font_size(ocrpt_report *r,
                           const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetheight">
					<title>Set report height</title>
					<para>
						See <xref linkend="reportheight"/>.
						The expression must evaluate to a numeric
						value.
						<programlisting>void
ocrpt_report_set_height(ocrpt_report *r,
                        const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="reportsetfhprio">
					<title>Set report's field header priority</title>
					<para>
						See <xref linkend="reportfhpriority"/>.
						The expression must evaluate to a string
						value with the options of <literal>high</literal>
						and <literal>low</literal>. Default is
						<literal>low</literal>.
						<programlisting>void
ocrpt_report_set_fieldheader_priority(ocrpt_report *r,
                                      const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="partgetlayoutsections">
				<title>Get part layout sections</title>
				<para>
					Get the part's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;PageHeader&gt;</literal>
					or <literal>&lt;PageFooter&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_layout_part_page_header(ocrpt_part *p);

ocrpt_output *
ocrpt_layout_part_page_footer(ocrpt_part *p);</programlisting>
				</para>
			</sect3>
			<sect3 id="partlayoutsetreport">
				<title>Set report for part layout sections</title>
				<para>
					Set the report pointer for the part's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;PageHeader&gt;</literal>
					or <literal>&lt;PageFooter&gt;</literal>.
					<programlisting>void
ocrpt_layout_part_page_header_set_report(ocrpt_part *p,
                                         ocrpt_report *r);

void
ocrpt_layout_part_page_footer_set_report(ocrpt_part *p,
                                         ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="reportgetlayoutsections">
				<title>Get report layout sections</title>
				<para>
					Get the report's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;NoData&gt;</literal>,
					<literal>&lt;ReportHeader&gt;</literal>,
					<literal>&lt;ReportFooter&gt;</literal>,
					<literal>&lt;FieldHeaders&gt;</literal> or
					<literal>&lt;FieldDetails&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_layout_report_nodata(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_header(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_footer(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_field_header(ocrpt_report *r);

ocrpt_output *
ocrpt_layout_report_field_details(ocrpt_report *r);</programlisting>
				</para>
			</sect3>
			<sect3 id="breakgetlayoutsections">
				<title>Get break layout sections</title>
				<para>
					Get the break's
					<literal>&lt;Output&gt;</literal> sections for
					<literal>&lt;BreakHeader&gt;</literal> or
					<literal>&lt;BreakFooter&gt;</literal>.
					<programlisting>ocrpt_output *
ocrpt_break_get_header(ocrpt_break *br);

ocrpt_output *
ocrpt_break_get_footer(ocrpt_break *br);</programlisting>
				</para>
			</sect3>
			<sect3 id="outputglobalsections">
				<title>Set output section global settings</title>
				<para>
					Note that part (page) header and footer, and report
					header and footer sections must be constant
					expressions. Other sections may depend on data derived
					from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="outputsetsuppress">
					<title>Set output section suppression</title>
					<para>
						Set suppression from an expression string.
						<programlisting>void
ocrpt_output_set_suppress(ocrpt_output *output,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddline">
				<title>Add a text line to an output section</title>
				<para>
					<programlisting>ocrpt_line *
ocrpt_output_add_line(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3 id="outputlinesettings">
				<title>Text line settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="linesetfontname">
					<title>Set line font name</title>
					<para>
						Set the text line's font name from
						an expression string.
						<programlisting>void
ocrpt_line_set_font_name(ocrpt_line *line,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetfontsize">
					<title>Set line font size</title>
					<para>
						Set the text line's font size from
						an expression string.
						<programlisting>void
ocrpt_line_set_font_size(ocrpt_line *line,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetbold">
					<title>Set line bold value</title>
					<para>
						Set the text line's bold value from
						an expression string.
						<programlisting>void
ocrpt_line_set_bold(ocrpt_line *line,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetitalic">
					<title>Set line italic value</title>
					<para>
						Set the text line's italic value from
						an expression string.
						<programlisting>void
ocrpt_line_set_italic(ocrpt_line *line,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetsuppress">
					<title>Set line suppression</title>
					<para>
						Set the text line's suppression value from
						an expression string.
						<programlisting>void
ocrpt_line_set_suppress(ocrpt_line *line,
                        const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="linessettextcolor">
					<title>Set line text color</title>
					<para>
						Set the text line's text color from
						an expression string.
						<programlisting>void
ocrpt_line_set_color(ocrpt_line *line,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="linesetbgcolor">
					<title>Set line background color</title>
					<para>
						Set the text line's background color from
						an expression string.
						<programlisting>void
ocrpt_line_set_bgcolor(ocrpt_line *line,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="lineaddtext">
				<title>Add a text element to a text line</title>
				<para>
					<programlisting>ocrpt_text *
ocrpt_line_add_text(ocrpt_line *line);</programlisting>
				</para>
			</sect3>
			<sect3 id="textsettings">
				<title>Text element settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="textsetliteral">
					<title>Set text element literal value</title>
					<para>
						Set the text element's literal value from
						a string.
						<programlisting>void
ocrpt_text_set_value_string(ocrpt_text *text,
                            const char *string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetvalue">
					<title>Set text element value</title>
					<para>
						Set the text element's value from
						an expression string.
						<programlisting>void
ocrpt_text_set_value_expr(ocrpt_text *text,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetdelayed">
					<title>Set text element value's delayed property</title>
					<para>
						Set the text element value's delayed
						property from an expression string.
						<programlisting>void
ocrpt_text_set_value_delayed(ocrpt_text *text,
                             const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetformatstring">
					<title>Set text element format string</title>
					<para>
						Set the text element's format string from
						an expression string.
						<programlisting>void
ocrpt_text_set_format(ocrpt_text *text,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetxlate">
					<title>Set text element translation</title>
					<para>
						Set the text element's translation from
						an expression string.
						<programlisting>void
ocrpt_text_set_translate(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
					<para>
						OpenCReports will attempt to translate
						both the format string and the text element's
						value.
					</para>
				</sect4>
				<sect4 id="textsetwidth">
					<title>Set text element field width</title>
					<para>
						Set the text element's field width from
						an expression string.
						<programlisting>void
ocrpt_text_set_width(ocrpt_text *text,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetalignment">
					<title>Set text element alignment</title>
					<para>
						Set the text element's alignment from
						a string or an expression string.
						<programlisting>void
ocrpt_text_set_alignment(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
					<para>
						String values <literal>left</literal>,
						<literal>right</literal>,
						<literal>center</literal> and
						<literal>justified</literal> are
						accepted either as is, or as an expression.
					</para>
				</sect4>
				<sect4 id="textsetcolor">
					<title>Set text element text color</title>
					<para>
						Set the text element's text color from
						an expression string.
						<programlisting>void
ocrpt_text_set_color(ocrpt_text *text,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetbgcolor">
					<title>Set text element background color</title>
					<para>
						Set the text element's background color from
						an expression string.
						<programlisting>void
ocrpt_text_set_bgcolor(ocrpt_text *text,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetfontname">
					<title>Set text element font name</title>
					<para>
						Set the text element's font name from
						an expression string.
						<programlisting>void
ocrpt_text_set_font_name(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetfontsize">
					<title>Set text element font size</title>
					<para>
						Set the text element's font size from
						an expression string.
						<programlisting>void
ocrpt_text_set_font_size(ocrpt_text *text,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetbold">
					<title>Set text element bold value</title>
					<para>
						Set the text element's bold value from
						an expression string.
						<programlisting>void
ocrpt_text_set_bold(ocrpt_text *text,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetitalic">
					<title>Set text element italic value</title>
					<para>
						Set the text element's italic value from
						an expression string.
						<programlisting>void
ocrpt_text_set_italic(ocrpt_text *text,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetlink">
					<title>Set text element link URL</title>
					<para>
						Set the text element's link URL from
						an expression string.
						<programlisting>void
ocrpt_text_set_link(ocrpt_text *text,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetmemo">
					<title>Set text element multiline property</title>
					<para>
						Set the text element's multiline property
						from an expression string. The expression
						must evaluate to a numeric (boolean) value.
						<programlisting>void
ocrpt_text_set_memo(ocrpt_text *text,
                    const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetmemowrap">
					<title>Set text element "wrap at characters" property</title>
					<para>
						Set the text element's "wrap at characters"
						property from an expression string.
						The expression must evaluate to a numeric
						(boolean) value. This setting is only used
						for multiline fields. When unset or set to
						<literal>false</literal>, multiline text
						fields wrap at word boundaries.
						<programlisting>void
ocrpt_text_set_memo_wrap_chars(ocrpt_text *text,
                               const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="textsetmemolines">
					<title>Set text element maximum lines</title>
					<para>
						Set the text element's maximum lines
						property from an expression string.
						The expression must evaluate to a numeric
						value. This setting is only used for multiline
						fields. When unset or set to <literal>0</literal>,
						the whole content of the multiline field is
						rendered. Otherwise, not more than the
						maximum lines are rendered from the multiline
						field value. The used font size, the field's width
						and word/character wrapping influence the
						number of lines the field value is rendered into.
						<programlisting>void
ocrpt_text_set_memo_max_lines(ocrpt_text *text,
                              const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddhline">
				<title>Add a horizontal line to an output section</title>
				<para>
					<programlisting>ocrpt_hline *
ocrpt_output_add_hline(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3 id="hlinesettings">
				<title>Horizontal line settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="hlinesetwidth">
					<title>Set horizontal line size (width)</title>
					<para>
						Set the horizontal line's size (width) from
						an expression string.
						<programlisting>void
ocrpt_hline_set_size(ocrpt_hline *hline,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetindentation">
					<title>Set horizontal line indentation</title>
					<para>
						Set the horizontal line's indentation value from
						an expression string.
						<programlisting>void
ocrpt_hline_set_indent(ocrpt_hline *hline,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetlength">
					<title>Set horizontal line length</title>
					<para>
						Set the horizontal line's length from
						an expression string.
						<programlisting>void
ocrpt_hline_set_length(ocrpt_hline *hline,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetfontsize">
					<title>Set horizontal line font size</title>
					<para>
						Set the horizontal line's font size from
						an expression string. It's used in indentation
						and length calculations if <xref linkend="sizeunit"/>
						is set to <literal>rlib</literal>.
						<programlisting>void
ocrpt_hline_set_font_size(ocrpt_hline *hline,
                          const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetsuppress">
					<title>Set horizontal line suppression</title>
					<para>
						Set the horizontal line's suppression from
						an expression string.
						<programlisting>void
ocrpt_hline_set_suppress(ocrpt_hline *hline,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="hlinesetcolor">
					<title>Set horizontal line color</title>
					<para>
						Set the horizontal line's color from
						an expression string.
						<programlisting>void
ocrpt_hline_set_color(ocrpt_hline *hline,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddimage">
				<title>Add an image to an output section</title>
				<para>
					<programlisting>ocrpt_image *
ocrpt_output_add_image(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
			<sect3 id="textaddimage">
				<title>Add an image to a text line</title>
				<para>
					<programlisting>ocrpt_image *
ocrpt_line_add_image(ocrpt_line *line);</programlisting>
				</para>
			</sect3>
			<sect3 id="imagesettings">
				<title>Image settings</title>
				<para>
					Note that settings in the part (page) header and
					footer sections must be constant expressions.
					Settings in other sections may depend
					on data derived from query columns.
					See <xref linkend="expressions"/>.
				</para>
				<sect4 id="imagesetvalue">
					<title>Set image value</title>
					<para>
						Set the image's value (filename) from
						an expression string.
						<programlisting>void
ocrpt_image_set_value(ocrpt_image *image,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetsuppress">
					<title>Set image suppression</title>
					<para>
						Set the image's suppression from
						an expression string.
						<programlisting>void
ocrpt_image_set_suppress(ocrpt_image *image,
                         const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesettype">
					<title>Set image type</title>
					<para>
						Set the image's type from
						an expression string.
						<programlisting>void
ocrpt_image_set_type(ocrpt_image *image,
                     const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetwidth">
					<title>Set image width</title>
					<para>
						Set the image's width from
						an expression string. Used when
						the image is directly added to
						an output section.
						<programlisting>void
ocrpt_image_set_width(ocrpt_image *image,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetheight">
					<title>Set image height</title>
					<para>
						Set the image's width from
						an expression string. Used when
						the image is directly added to
						an output section.
						<programlisting>void
ocrpt_image_set_height(ocrpt_image *image,
                       const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetalignment">
					<title>Set image alignment</title>
					<para>
						Set the image's alignment from
						an expression string. Used when
						the image is added to text line.
						<programlisting>void
ocrpt_image_set_align(ocrpt_image *image,
                      const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagesetbgcolor">
					<title>Set image background color</title>
					<para>
						Set the image's background color from
						an expression string.
						<programlisting>void
ocrpt_image_set_bgcolor(ocrpt_image *image,
                        const char *expr_string);</programlisting>
					</para>
				</sect4>
				<sect4 id="imagessetfieldwidth">
					<title>Set image field width</title>
					<para>
						Set the image's field width from
						an expression string. Used when
						the image is added to text line.
						<programlisting>void
ocrpt_image_set_text_width(ocrpt_image *image,
                           const char *expr_string);</programlisting>
					</para>
				</sect4>
			</sect3>
			<sect3 id="outputaddimageend">
				<title>Add an image end marker to an output section</title>
				<para>
					<programlisting>void
ocrpt_output_add_image_end(ocrpt_output *output);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="callbackfuncs">
			<title>Callback related functions</title>
			<para>
				Certain stages of the report execution can
				notify the application about the stage
				being executed or finished.
			</para>
			<para>
				Every "add a callback" function below return
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
			</para>
			<sect3 id="addpartaddedcb">
				<title>Add a "part added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_part_cb)(opencreport *,
                 ocrpt_part *,
                 void *data);

bool
ocrpt_add_part_added_cb(opencreport *o,
                        ocrpt_part_cb func,
                        void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="addreportaddedcb">
				<title>Add a "report added" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_report_cb)(opencreport *,
                   ocrpt_report *,
                   void *data);

bool
ocrpt_add_report_added_cb(opencreport *o,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="addprecalcsdonecb">
				<title>Add an "all precalculations done" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_cb)(opencreport *,
            void *data);

bool
ocrpt_add_precalculation_done_cb(opencreport *o,
                                 ocrpt_cb func,
                                 void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="addpartitercb">
				<title>Add a "part iteration" callback</title>
				<para>
					<programlisting>bool
ocrpt_part_add_iteration_cb(ocrpt_part *r,
                            ocrpt_part_cb func,
                            void *data);

bool
ocrpt_part_add_iteration_cb2(opencreport *o,
                             ocrpt_part_cb func,
                             void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report part. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportstartedcb">
				<title>Add a "report started" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_start_cb(ocrpt_report *r,
                          ocrpt_report_cb func,
                          void *data);

bool
ocrpt_report_add_start_cb2(opencreport *o,
                           ocrpt_report_cb func,
                           void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportdonecb">
				<title>Add a "report done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_done_cb(ocrpt_report *r,
                         ocrpt_report_cb func,
                         void *data);

bool
ocrpt_report_add_done_cb2(opencreport *o,
                          ocrpt_report_cb func,
                          void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addnewrowcb">
				<title>Add a "new row" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_new_row_cb(ocrpt_report *r,
                            ocrpt_report_cb func,
                            void *data);

bool
ocrpt_report_add_new_row_cb2(opencreport *o,
                             ocrpt_report_cb func,
                             void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportiterdonecb">
				<title>Add a "report iteration done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_iteration_cb(ocrpt_report *r,
                              ocrpt_report_cb func,
                              void *data);

bool
ocrpt_report_add_iteration_cb2(opencreport *o,
                               ocrpt_report_cb func,
                               void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addreportprecalcdone">
				<title>Add a "report precalculation done" callback</title>
				<para>
					<programlisting>bool
ocrpt_report_add_precalculation_done_cb(ocrpt_report *r,
                                        ocrpt_report_cb func,
                                        void *data);

bool
ocrpt_report_add_precalculation_done_cb2(opencreport *o,
                                         ocrpt_report_cb func,
                                         void *data);</programlisting>
				</para>
				<para>
					The second variant adds the callback in the
					<literal>opencreport</literal> structure
					context, making the callback apply to
					every report. It's for RLIB compatibility.
				</para>
			</sect3>
			<sect3 id="addbreaktriggerscb">
				<title>Add a "break triggers" callback</title>
				<para>
					<programlisting>typedef void
(*ocrpt_break_trigger_cb)(opencreport *,
                          ocrpt_report *,
                          ocrpt_break *,
                          void *);

bool
ocrpt_break_add_trigger_cb(ocrpt_break *br,
                           ocrpt_break_trigger_cb func,
                           void *data);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="envfuncs">
			<title>Environment related functions</title>
			<sect3 id="getenvvarindirect">
				<title>Indirect function to get an environment variable</title>
				<para>
					<programlisting>typedef ocrpt_result *
(*ocrpt_env_query_func)(opencreport *,
                        const char *);

extern ocrpt_env_query_func
ocrpt_env_get;</programlisting>
				</para>
			</sect3>
			<sect3 id="setenvqueryfunc">
				<title>Set the environment query function</title>
				<para>
					<programlisting>void
ocrpt_env_set_query_func(ocrpt_env_query_func func);</programlisting>
				</para>
			</sect3>
			<sect3 id="capienvqueryfunc">
				<title>C API environment query function</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_env_get_c(opencreport *o,
                const char *env);</programlisting>
				</para>
			</sect3>
			<sect3 id="setmvarfunc">
				<title>Add an "m" domain variable</title>
				<para>
					Set an "m" domain variable.
					If such a variable <literal>name</literal>
					didn't exist yet, and <literal>value</literal>
					is not <literal>NULL</literal>, then
					the variable is set. If <literal>value</literal>
					is <literal>NULL</literal>, the variable is
					removed. Such an explicit variable takes
					precedence over the environment variable
					of the same name when used in expressions.
					<programlisting>void
ocrpt_set_mvariable(opencreport *o,
                    const char *name,
                    const char *value);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="filefuncs">
			<title>File handling related functions</title>
			<sect3 id="getcanonfile">
				<title>Return a canonical file path</title>
				<para>
					The returned path contains only single
					directory separators and doesn't contains
					symlinks.
					<programlisting>char *
ocrpt_canonicalize_path(const char *path);</programlisting>
				</para>
			</sect3>
			<sect3 id="addsearchpath">
				<title>Add search path</title>
				<para>
					Add a new directory path to the list of
					search paths. It's useful to find files
					referenced with relative path.
					<programlisting>void
ocrpt_add_search_path(opencreport *o,
                      const char *path);</programlisting>
				</para>
			</sect3>
			<sect3 id="addsearchpath2">
				<title>Add search path (delayed variant)</title>
				<para>
					Add a new directory path from an expression string
					to the list of search paths. It's useful to find
					files referenced with relative path.
					The expression must evaluate to a string value.
					It is evaluated at the beginning of the report
					execution. This function may be used explicitly
					but it's also used when parsing the
					<literal>&lt;Path&gt;</literal> nodes in a
					report XML description.
					<programlisting>void
ocrpt_add_search_path_from_expr(opencreport *o,
                                const char *expr_string);</programlisting>
				</para>
			</sect3>
			<sect3 id="resolvesearchpaths">
				<title>Resolve search paths</title>
				<para>
					Resolve expressions added by
					<literal>ocrpt_add_search_path_from_expr()</literal>.
					It's used internally when executing the report.
					<programlisting>void
ocrpt_resolve_search_paths(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="findfile">
				<title>Find a file</title>
				<para>
					Find a file and return the canonicalized path to it.
					This function takes the search paths into account.
					<programlisting>char *
ocrpt_find_file(opencreport *o,
                const char *filename);</programlisting>
				</para>
				<para>
					Note that search paths added by
					<literal>ocrpt_add_search_path()</literal>
					and <literal>ocrpt_add_search_path_from_expr()</literal>
					are used in their order of appearance when searching
					for files during executing the report.
				</para>
			</sect3>
		</sect2>
		<sect2 id="colorfuncs">
			<title>Color related functions</title>
			<sect3 id="findcolor">
				<title>Find a color by its name</title>
				<para>
					The function fills in the
					<literal>ocrpt_color</literal> structure with
					RGB values in Cairo values (0.0 ... 1.0).
				</para>
				<para>
					If the color name starts with
					<literal>#</literal> or <literal>0x</literal> or
					<literal>0X</literal> then it must be in HTML
					notation.
				</para>
				<para>
					Otherwise, the color name is looked up in the
					color name database in a case insensitive way.
					If found, the passed-in ocrpt_color structure is
					filled with the RGB color value of that name.
				</para>
				<para>
					If not found or the passed-in color name is NULL,
					depending on the the expected usage (foreground
					or background color), the <literal>ocrpt_color</literal>
					structure is filled with either white or black.
					<programlisting>void
ocrpt_get_color(opencreport *o,
                const char *cname,
                ocrpt_color *color,
                bool bgcolor);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="paperfuncs">
			<title>Paper size related functions</title>
			<para>
				Paper size in OpenCReports is handled via
				<ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>.
			</para>
			<para>
				This structure is used in OpenCReports to represent
				paper name and size:
				<programlisting>struct ocrpt_paper {
    const char *name;
    double width;
    double height;
};
typedef struct ocrpt_paper ocrpt_paper;</programlisting>
			</para>
			<sect3 id="getdefsystempaper">
				<title>Get the system default paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_system_paper(void);</programlisting>
				</para>
			</sect3>
			<sect3 id="getpaperbyname">
				<title>Get the paper specified by name</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper_by_name(const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3 id="setglobalpaper">
				<title>Set the global paper</title>
				<para>
					Set global paper using an
					<literal>ocrpt_paper</literal> structure.
					The contents of the structure is copied.
					<programlisting>void
ocrpt_set_paper(opencreport *o,
                const ocrpt_paper *paper);</programlisting>
				</para>
			</sect3>
			<sect3 id="setglobalpaperbyname">
				<title>Set global paper specified by name</title>
				<para>
					Set paper for the report using a paper name.
					If the paper name is unknown, the system default paper is set.
					<programlisting>void
ocrpt_set_paper_by_name(opencreport *o,
                        const char *paper);</programlisting>
				</para>
			</sect3>
			<sect3 id="getglobalpaper">
				<title>Get currently set global paper</title>
				<para>
					<programlisting>const ocrpt_paper *
ocrpt_get_paper(opencreport *o);</programlisting>
				</para>
			</sect3>
			<sect3 id="paperiterator">
				<title>Iterate over paper sizes</title>
				<para>
					Get the next <literal>ocrpt_paper</literal> structure
					in the iterator. For the first call, the iterator
					pointer must be NULL. It returns NULL when there are
					no more papers known to the system.
					<programlisting>const ocrpt_paper *
ocrpt_paper_next(opencreport *o,
                 void **iter);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="memoryfuncs">
			<title>Memory handling related functions</title>
			<para>
				Memory handling is done through an indirection,
				to help with bindings (that may do their own memory
				handling) override the default.
			</para>
			<sect3 id="funcptrs">
				<title>Indirect function pointers</title>
				<para>
					<programlisting>typedef void *
(*ocrpt_mem_malloc_t)(size_t);

typedef void *
(*ocrpt_mem_realloc_t)(void *,
                       size_t);

typedef void *
(*ocrpt_mem_reallocarray_t)(void *,
                            size_t,
                            size_t);

typedef void
(*ocrpt_mem_free_t)(const void *);

typedef char *
(*ocrpt_mem_strdup_t)(const char *);

typedef char *
(*ocrpt_mem_strndup_t)(const char *,
                       size_t);

typedef void
(*ocrpt_mem_free_size_t)(void *,
                         size_t);

extern ocrpt_mem_malloc_t ocrpt_mem_malloc0;
extern ocrpt_mem_realloc_t ocrpt_mem_realloc0;
extern ocrpt_mem_reallocarray_t ocrpt_mem_reallocarray0;
extern ocrpt_mem_free_t ocrpt_mem_free0;
extern ocrpt_mem_strdup_t ocrpt_mem_strdup0;
extern ocrpt_mem_strndup_t ocrpt_mem_strndup0;</programlisting>
				</para>
			</sect3>
			<sect3 id="allocmem">
				<title>Allocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_malloc(size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="reallocmem">
				<title>Reallocate memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_realloc(void *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="reallocarray">
				<title>Reallocate array of memory</title>
				<para>
					<programlisting>void *
ocrpt_mem_reallocarray(void *ptr,
                       size_t nmemb,
                       size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="freemem">
				<title>Free memory</title>
				<para>
					<programlisting>void
ocrpt_mem_free(const void *ptr);</programlisting>
				</para>
			</sect3>
			<sect3 id="duplicatecstring">
				<title>Duplicate C string</title>
				<para>
					<programlisting>void *
ocrpt_mem_strdup(const char *ptr);</programlisting>
				</para>
			</sect3>
			<sect3 id="duplicatecstringlen">
				<title>Duplicate C string up to the specified length</title>
				<para>
					<programlisting>void *
ocrpt_mem_strndup(const char *ptr,
                  size_t sz);</programlisting>
				</para>
			</sect3>
			<sect3 id="freecstring">
				<title>Free a C string</title>
				<para>
					It'a convenience alias for
					<literal>ocrpt_mem_free()</literal>.
					<programlisting>void
ocrpt_strfree(const char *s);</programlisting>
				</para>
			</sect3>
			<sect3 id="setallocptrs">
				<title>Set indirect allocation functions</title>
				<para>
					<programlisting>void
ocrpt_mem_set_alloc_funcs(ocrpt_mem_malloc_t rmalloc,
                          ocrpt_mem_realloc_t rrealloc,
                          ocrpt_mem_reallocarray_t rreallocarray,
                          ocrpt_mem_free_t rfree,
                          ocrpt_mem_strdup_t rstrdup,
                          ocrpt_mem_strndup_t rstrndup);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="listfuncs">
			<title>List related functions</title>
			<para>
				These functions implement a single linked list.
				The list element structure is hidden:
				<programlisting>struct ocrpt_list;
typedef struct ocrpt_list ocrpt_list;</programlisting>
			</para>
			<sect3 id="listgetlength">
				<title>Get the list length</title>
				<para>
					<programlisting>size_t
ocrpt_list_length(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listmake1">
				<title>Make a list from one element</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_makelist1(const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listmakemulti">
				<title>Make a list from multiple elements</title>
				<para>
					This function can be used with variable
					number of arguments.
					<programlisting>ocrpt_list *
ocrpt_makelist(const void *data1, ...);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetlast">
				<title>Get the last element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_last(const ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetnth">
				<title>Get the nth element of a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_nth(const ocrpt_list *l, uint32_t n);</programlisting>
				</para>
			</sect3>
			<sect3 id="listappend">
				<title>Append a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_append(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listappendwend">
				<title>Append to list using the last element</title>
				<para>
					This function make appending to the list work
					<emphasis>O(1)</emphasis> instead of
					<emphasis>O(n)</emphasis>.
					<programlisting>ocrpt_list *
ocrpt_list_end_append(ocrpt_list *l,
                      ocrpt_list **e,
                      const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listprepend">
				<title>Prepend a new element to a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_prepend(ocrpt_list *l,
                   const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listremove">
				<title>Remove a data element from a list</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_remove(ocrpt_list *l,
                  const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listremovewend">
				<title>Remove a data element from a list and update the last link</title>
				<para>
					<programlisting>ocrpt_list *
ocrpt_list_end_remove(ocrpt_list *l,
                      ocrpt_list **endptr,
                      const void *data);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetnext">
				<title>Get next link in the list</title>
				<para>
					This can be used to iterate through a list.
					It returns <literal>NULL</literal> if the
					passed-in link is the last list in the list
					or it's an empty list.
					<programlisting>ocrpt_list *
ocrpt_list_next(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listgetdata">
				<title>Get the data element from a list</title>
				<para>
					<programlisting>void *
ocrpt_list_get_data(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listfree">
				<title>Free a list</title>
				<para>
					<programlisting>void
ocrpt_list_free(ocrpt_list *l);</programlisting>
				</para>
			</sect3>
			<sect3 id="listdeepfree">
				<title>Free a list and its data elements</title>
				<para>
					<programlisting>void
ocrpt_list_free_deep(ocrpt_list *l,
                     ocrpt_mem_free_t freefunc);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="stringfuncs">
			<title>String related functions</title>
			<para>
				For memory safety and higher performance, a wrapper
				structure is used over C functions.
				<programlisting>struct ocrpt_string {
    char *str;
    size_t allocated_len;
    size_t len;
};
typedef struct ocrpt_string ocrpt_string;</programlisting>
			</para>
			<sect3 id="stringcreate">
				<title>Create a new string</title>
				<para>
					Create a new string from a C string.
					The ownership of the input string may be
					taken over, or the original string's contents
					are copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new(const char *str,
                     bool copy);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringcreatelen">
				<title>Create a new string with specified allocated length</title>
				<para>
					Create a new string with specified allocated length
					so future growth can be done without reallocation.
					The input string is always copied.
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_with_len(const char *str,
                              size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringcreatevnprintf">
				<title>Create a string from a formatted string with maximum length</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_vnprintf(size_t len,
                              const char *format,
                              va_list va);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringcreateprintf">
				<title>Create a string from a formatted string</title>
				<para>
					<programlisting>ocrpt_string *
ocrpt_mem_string_new_printf(const char *format, ...);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringresize">
				<title>Resize a string</title>
				<para>
					Resize the string to the specified allocated
					length.
					<programlisting>ocrpt_string *
ocrpt_mem_string_resize(ocrpt_string *string,
                        size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringfree">
				<title>Free a string</title>
				<para>
					<programlisting>char *
ocrpt_mem_string_free(ocrpt_string *string,
                      bool free_str);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendcstring">
				<title>Append a C string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len(ocrpt_string *string,
                            const char *str,
                            const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendbinary">
				<title>Append a binary string of the specified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_len_binary(ocrpt_string *string,
                                   const char *str,
                                   const size_t len);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendcstringwlen">
				<title>Append a C string of unspecified length to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append(ocrpt_string *string,
                        const char *str);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendchar">
				<title>Append a byte to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_c(ocrpt_string *string,
                          const char c);</programlisting>
				</para>
			</sect3>
			<sect3 id="stringappendprintf">
				<title>Append a formatted string to a string</title>
				<para>
					<programlisting>void
ocrpt_mem_string_append_printf(ocrpt_string *string,
                               const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
</chapter>

<chapter id="c-api-reference" xreflabel="C API Reference">
	<title>C language API reference</title>
	<sect1>
		<title>Header file</title>
		<para>
			For using OpenCReports, this single header must be used:
			<programlisting>#include &lt;opencreport.h&gt;</programlisting>
		</para>
	</sect1>
	<sect1 id="highlevelapi" xreflabel="High level C API">
		<title>High level C API</title>
		<para>
			Example code using the high level C API where everything
			concerning the report (including the data source)
			is described in the report XML:
			<programlisting>#include &lt;opencreport.h&gt;

int main(void) {
    opencreport *o = ocrpt_init();

    if (!ocrpt_parse_xml(o, "report.xml")) {
        printf("XML parse error\n");
        ocrpt_free(o);
        return 1;
    }

    ocrpt_set_output_format(o, OCRPT_OUTPUT_PDF);
    ocrpt_execute(o);
    ocrpt_spool(o);
    ocrpt_free(o);
    return 0;
}</programlisting>
		</para>
		<para>
			The above code will load <literal>report.xml</literal>,
			set the output format to PDF, runs the report and prints
			it output on <literal>stdout</literal>.
		</para>
		<sect2>
		<title>Report handler initialization</title>
		<para>
			<programlisting>opencreport *ocrpt_init(void);</programlisting>
		</para>
		</sect2>
		<sect2>
			<title>Load a report XML description</title>
			<para>
				This function loads the specified XML file
				into the report handler. It returns
				<literal>true</literal> for success,
				<literal>false</literal> for failure.
				<programlisting>bool ocrpt_parse_xml(opencreport *o, const char *filename);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Set report output format</title>
			<para>
				<programlisting>enum ocrpt_format_type {
    OCRPT_OUTPUT_UNSET,
    OCRPT_OUTPUT_PDF,
    OCRPT_OUTPUT_HTML,
    OCRPT_OUTPUT_TXT,
    OCRPT_OUTPUT_CSV,
    OCRPT_OUTPUT_XML
};
typedef enum ocrpt_format_type ocrpt_format_type;

void ocrpt_set_output_format(opencreport *o,
                             ocrpt_format_type format);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Run the report</title>
			<para>
				This function executes the report, constructs
				the result in memory. It returns <literal>true</literal>
				for success, <literal>false</literal> for failure.
				It is a failure if the output format is unset.
				<programlisting>bool ocrpt_execute(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Dump report result</title>
			<para>
				Dump the report output on the program's
				standard output channel.
				<programlisting>void ocrpt_spool(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title>Report handler destruction</title>
			<para>
				Calling this function frees up the report handler
				structure and everything created for it, even
				the details that were created by the low level API.
				<programlisting>void ocrpt_free(opencreport *o);</programlisting>
			</para>
		</sect2>
	</sect1>
	<sect1 id="lowlevelapi" xreflabel="Low level C API">
		<title>Low level C API</title>
		<para>
			The <xref linkend="highlevelapi"/> is also part of the
			low level API. The functions described below allow
			creating a report using program code, or simply
			fine tuning the report behavior by mostly using the
			<xref linkend="highlevelapi"/>.
		</para>
		<sect2 id="numerictuning" xreflabel="Numeric behavior related functions">
			<title>Numeric behavior related functions</title>
			<sect3>
				<title><literal>Set numeric precision</literal></title>
				<para>
					The default is 256 bits of floating point precision.
					<programlisting>void ocrpt_set_numeric_precision_bits(opencreport *o,
                                      mpfr_prec_t prec);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set rounding mode</title>
				<para>
					OpenCReports uses GNU MPFR under the hood and does't
					hide this fact. The MPFR rounding mode constants are
					used as is to set the rounding behaviour.
					The default is <literal>MPFR_RNDN</literal>, round
					to nearest.
					<programlisting>void ocrpt_set_rounding_mode(opencreport *o,
                             mpfr_rnd_t rndmode);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Locale related functions</title>
			<sect3>
				<title>Set report locale</title>
				<para>
					Setting the locale for the report does not affect
					the main program or other threads. Locale setting
					includes the language, the country. The UTF-8 suffix
					is necessary. E.g.: <literal>en_GB.UTF-8</literal> or
					<literal>de_DE.UTF-8</literal>
					<programlisting>void ocrpt_set_locale(opencreport *o,
                      const char *locale);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print monetary data in the report locale</title>
				<para>
					A customized monetary printing function was implemented
					for the purposes of the report which MPFR doesn't
					provide. It is used in OpenCReports both internally
					and by unit tests.
					<programlisting>ssize_t ocrpt_mpfr_strfmon(opencreport *o,
                           char *s, size_t maxsize,
                           const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Data source and query related functions</title>
			<para>
				The following <literal>enum</literal> and
				<literal>struct</literal> types are used by
				OpenCReports for datasources and queries.
				<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

struct ocrpt_datasource;
typedef struct ocrpt_datasource ocrpt_datasource;

struct ocrpt_query;
typedef struct ocrpt_query ocrpt_query;

struct ocrpt_query_result;
typedef struct ocrpt_query_result ocrpt_query_result;

struct ocrpt_input {
    void (*describe)(ocrpt_query *,
                     ocrpt_query_result **,
                     int32_t *);
    void (*rewind)(ocrpt_query *);
    bool (*next)(ocrpt_query *);
    bool (*populate_result)(ocrpt_query *);
    bool (*isdone)(ocrpt_query *);
    void (*free)(ocrpt_query *);
    bool (*set_encoding)(ocrpt_datasource *,
                         const char *);
    void (*close)(const ocrpt_datasource *);
};
typedef struct ocrpt_input ocrpt_input;</programlisting>
			</para>
			<para>
				Data sources in this context are "mini drivers".
				Data source handling is implemented via
				<literal>ocrpt_input</literal> functions.
			</para>
			<para>
				Queries are data providers over data sources. They are
				the actual sources of data using a specific data source.
				Multiple queries may use the same data source.
			</para>
			<sect3>
				<title>Add an array datasource</title>
				<para>
					Add an array datasource to the report handler.
					It's optional, as an array datasource called
					"array" is automatically added to an opencreport
					structure.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_array(opencreport *o,
                           const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an array query</title>
				<para>
					Add an "array query" to the report handler.
					This adds the array pointer and parameters, so
					the array datasource input driver can use it.
					The provided <literal>array</literal> array pointer
					contains <literal>(rows + 1) * cols</literal> number of
					<literal>char *</literal> pointers, with the first row
					being the column (field) names. The
					<literal>types</literal> array contains
					<literal>cols</literal> number of
					<literal>enum ocrpt_result_type</literal> elements to
					indicate the column data type.
					<programlisting>ocrpt_query *
ocrpt_query_add_array(opencreport *o,
                      ocrpt_datasource *source,
                      const char *name,
                      const char **array,
                      int32_t rows, int32_t cols,
                      const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					If the <literal>types</literal> pointer is
					<literal>NULL</literal>, the column values are treated
					as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3>
				<title>Add a CSV datasource</title>
				<para>
					Add a CSV datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_csv(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a CSV query</title>
				<para>
					Add a "CSV query" to the report handler.
					This specifies the file name, so
					the CSV datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_csv(opencreport *o,
                    ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					The <literal>types</literal> array pointer is optional.
					If it is <literal>NULL</literal>, the column values are
					treated as strings. This is how RLIB operated.
				</para>
			</sect3>
			<sect3>
				<title>Add a JSON datasource</title>
				<para>
					Add a JSON datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_json(opencreport *o,
                          const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a JSON query</title>
				<para>
					Add a "JSON query" to the report handler.
					This specifies the file name, so
					the JSON datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_json(opencreport *o,
                     ocrpt_datasource *source,
                     const char *name,
                     const char *filename,
                     const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					The JSON file format defined in <xref linkend="jsonds"/>
					contains the way to describe the column data types,
					which is optional in a JSON file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the JSON file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the JSON file doesn't
					contain type specifiers), the column values are
					treated as strings. RLIB didn't have JSON input.
				</para>
			</sect3>
			<sect3>
				<title>Add an XML datasource</title>
				<para>
					Add an XML datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_xml(opencreport *o,
                         const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an XML query</title>
				<para>
					Add an "XML query" to the report handler.
					This specifies the file name, so
					the XML datasource input driver can load it.
					<programlisting>ocrpt_query *
ocrpt_query_add_xml(opencreport *o,
                    ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const enum ocrpt_result_type *types);</programlisting>
				</para>
				<para>
					The XML file format defined in <xref linkend="xmlds"/>
					contains the way to describe the column data types,
					which is optional in an XML file.
					The <literal>types</literal> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the XML file itself doesn't
					contain the type description for the columns. If it is
					<literal>NULL</literal> (and the XML file doesn't
					contain type specifiers), the column values are
					treated as strings. This is how RLIB operated.
					The OpenCReports XML input file format is RLIB
					compatible without the type specification part.
				</para>
			</sect3>
			<sect3>
				<title>Add a PostgreSQL datasource</title>
				<para>
					Add a PostgreSQL datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_postgresql(opencreport *o,
                                const char *source_name,
                                const char *host,
                                const char *port,
                                const char *dbname,
                                const char *user,
                                const char *password);

ocrpt_datasource *
ocrpt_datasource_add_postgresql2(opencreport *o,
                                 const char *source_name,
                                 const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="postgresqlds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Add a PostgreSQL query</title>
				<para>
					Add a SQL query using the PostgreSQL datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_postgresql(opencreport *o,
                           ocrpt_datasource *source,
                           const char *name,
                           const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add a MariaDB datasource</title>
				<para>
					Add a MariaDB datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_mariadb(opencreport *o,
                             const char *source_name,
                             const char *host,
                             const char *port,
                             const char *dbname,
                             const char *user,
                             const char *password,
                             const char *unix_socket);

ocrpt_datasource *
ocrpt_datasource_add_mariadb2(opencreport *o,
                              const char *source_name,
                              const char *optionfile,
                              const char *group);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="mariadbds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Add a MariaDB query</title>
				<para>
					Add an SQL query using the MariaDB datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_mariadb(opencreport *o,
                        ocrpt_datasource *source,
                        const char *name,
                        const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Add an ODBC datasource</title>
				<para>
					Add an ODBC datasource to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_add_odbc(opencreport *o,
                          const char *source_name,
                          const char *dbname,
                          const char *user, const char *password);

ocrpt_datasource *
ocrpt_datasource_add_odbc2(opencreport *o,
                           const char *source_name,
                           const char *conninfo);</programlisting>
				</para>
				<para>
					For the parameters, see <xref linkend="odbcds"/>.
				</para>
			</sect3>
			<sect3>
				<title>Add an ODBC query</title>
				<para>
					Add an SQL query using the ODBC datasource
					to the report handler.
					<programlisting>ocrpt_query *
ocrpt_query_add_odbc(opencreport *o,
                     ocrpt_datasource *source,
                     const char *name,
                     const char *querystr);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Find a datasource</title>
				<para>
					Find the data source using its name.
					It returns NULL if the named data source
					is not found.
					<programlisting>ocrpt_datasource *
ocrpt_datasource_get(opencreport *o,
                     const char *source_name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add a custom datasource</literal></title>
				<para>
					Add a custom data source to the report handler.
					<programlisting>ocrpt_datasource *
ocrpt_add_datasource(opencreport *o,
                     const char *source_name,
                     const ocrpt_input *input);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Set the encoding of a datasource</literal></title>
				<para>
					Set the encoding of a datasource in case
					if it's not already UTF-8, so data provided by
					it is automatically converted.
					<programlisting>void
ocrpt_datasource_set_encoding(opencreport *o,
                              ocrpt_datasource *source,
                              const char *encoding);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Free a datasource</literal></title>
				<para>
					Free a datasource from the opencreport structure
					it was added to. It's not needed to be called,
					all datasources are automatically free with
					<literal>ocrpt_free()</literal>
					<programlisting>void
ocrpt_datasource_free(opencreport *o,
                      ocrpt_datasource *source);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Find a query</literal></title>
				<para>
					Find a query using its name.
					<programlisting>ocrpt_query *
ocrpt_query_get(opencreport *o,
                const char *name);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get the current data row from a query</literal></title>
				<para>
					Create (first call) or get the <literal>ocrpt_query_result</literal>
					array from a query. Output parameter <literal>cols</literal>
					returns the number of columns in the result array. It must
					be re-run after ocrpt_navigate_next() since the previously
					returned pointer becomes invalid.
					<programlisting>ocrpt_query_result *
ocrpt_query_get_result(ocrpt_query *q,
                       int32_t *cols);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get column name</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal> result
					from <literal>ocrpt_query_get_result()</literal>,
					the column names can be discovered from a query.
					<programlisting>const char *
ocrpt_query_result_column_name(ocrpt_query_result *qr,
                               int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get column data</literal></title>
				<para>
					Using the <literal>ocrpt_query_result *</literal>
					result from
					<literal>ocrpt_query_get_result()</literal>, get a
					pointer to the column data in its internal (hidden)
					representation.
					<programlisting>ocrpt_result *
ocrpt_query_result_column_result(ocrpt_query_result *qr,
                                 int32_t col);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Detect whether a column result is NULL</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					detect whether the column value is NULL.
					<programlisting>bool
ocrpt_result_isnull(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Detect whether a column result is numeric</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					detect whether the column value is numeric.
					<programlisting>bool
ocrpt_result_isnumber(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get the numeric value of a column result</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					get the numeric column value. It returns  NULL
					if the column is:
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a numeric result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>mpfr_ptr
ocrpt_result_get_number(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Detect whether a column result is string</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					detect whether the column value is string.
					<programlisting>bool
ocrpt_result_isstring(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get the string value of a column result</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					get the string column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a string result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>ocrpt_string *
ocrpt_result_get_string(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Detect whether a column result is datetime</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					detect whether the column value is datetime.
					<programlisting>bool
ocrpt_result_isdatetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Get the datetime value of a column result</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					get the datetime column value. It returns  NULL
					if the column is
					<itemizedlist>
						<listitem override="bullet">
							<para>
								not a datetime result
							</para>
						</listitem>
						<listitem override="bullet">
							<para>
								NULL
							</para>
						</listitem>
					</itemizedlist>
					<programlisting>const struct tm *
ocrpt_result_get_datetime(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Detect whether a datetime column result is interval</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					detect whether the datetime column value is interval.
					<programlisting>bool
ocrpt_result_datetime_is_interval(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Detect whether a datetime column result has valid date</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					detect whether the datetime column value has valid date.
					<programlisting>bool
ocrpt_result_datetime_is_date_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Detect whether a datetime column result has valid time</literal></title>
				<para>
					Using the <literal>ocrpt_result *</literal>
					result from
					<literal>ocrpt_query_result_column_result()</literal>,
					detect whether the datetime column value has valid time.
					<programlisting>bool
ocrpt_result_datetime_is_time_valid(ocrpt_result *result);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add a follower query</literal></title>
				<para>
					Add a <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and the follower will run in parallel with it until
					the leader runs out of rows. In case the leader has more
					rows than the follower, then for rows in the leader where
					there are no follower rows, the follower fields are set to NULL.
					<programlisting>bool
ocrpt_add_query_follower(opencreport *o,
                         ocrpt_query *leader,
                         ocrpt_query *follower);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Add an N:1 follower query</literal></title>
				<para>
					Add an N:1 <literal>follower</literal> query to the
					<literal>leader</literal> query. The leader is the primary
					query and rows from the follower will be matched using the
					<literal>match</literal> expression. If there are multiple
					rows in the follower matching the leader row, then the leader
					row will be listed that many times. For rows in the leader
					where there are no matching rows in the follower, the follower
					fields are set to NULL. It is similar to <literal>LEFT OUTER
					JOIN</literal> in SQL databases. For creating an
					<literal>ocrpt_expr</literal> expression pointer, see the
					next section.
					<programlisting>bool
ocrpt_add_query_follower_n_to_1(opencreport *o,
                                ocrpt_query *leader,
                                ocrpt_query *follower,
                                ocrpt_expr *match);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Free a query</literal></title>
				<para>
					Free a query and remove it from the report handler.
					It's optional. <literal>ocrpt_free()</literal> frees
					the queries added to the <literal>opencreport</literal>
					structure.
					<programlisting>void
ocrpt_query_free(opencreport *o,
                 ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Start the main query</literal></title>
				<para>
					Start query (or query set) navigation.
					<literal>q</literal> should be the primary query
					of the report.
					<programlisting>void
ocrpt_query_navigate_start(opencreport *o,
                           ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>Navigate to the next query row</literal></title>
				<para>
					Navigate the query (or query set) to the next row. Returns
					<literal>false</literal> if there was no more rows.
					in which case the <literal>ocrpt_query_result</literal>
					arrays for all queries in the query set (returned by
					previous <literal>ocrpt_query_get_result()</literal>
					calls contain invalid data.
					<programlisting>bool
ocrpt_query_navigate_next(opencreport *o,
                          ocrpt_query *q);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title><literal>API specific array discovery function</literal></title>
				<para>
					For array data sources and queries, OpenCReports
					needs a way to to find the data array and the
					supplementary type identifier array.
					These are language specific. The below ones
					are the C specific ones. The override function
					is also provided to set a new discovery function.
					<programlisting>typedef void
(*ocrpt_query_discover_func)(const char *,
                             void **,
                             const char *,
                             void **);

void
ocrpt_query_set_discover_func(ocrpt_query_discover_func func);

extern ocrpt_query_discover_func ocrpt_query_discover_array;

void
ocrpt_query_discover_array_c(const char *arrayname,
                             void **array,
                             const char *typesname,
                             void **types);</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="exprfunc" xreflabel="Expression related functions">
			<title>Expression related functions</title>
			<para>
				Expressions in OpenCReports is explained in the
				<xref linkend="expressions"/> chapter.
			</para>
			<sect3>
				<title>Parse an expression string</title>
				<para>
					This function parses an expression string and
					creates an expression tree. It returns a pointer
					to the <literal>ocrpt_expr</literal> structure.
				</para>
				<para>
					If an error occurs, it returns NULL and optionally
					returns the error message in <literal>err</literal>
					pointer if it's not <literal>NULL</literal>.
				</para>
				<para>
					The <literal>ocrpt_report</literal> pointer may be
					valid or NULL. If valid, the expression is bound
					to this <literal>ocrpt_report</literal>, i.e.
					it will be freed automatically with
					<literal>ocrpt_free()</literal>.
					<programlisting>ocrpt_expr *ocrpt_expr_parse(opencreport *o,
                             ocrpt_report *r,
                             const char *str,
                             char **err);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Free an expression parse tree</title>
				<para>
					Free an expression parse tree. If it was bound
					to the passed-in <literal>ocrpt_report</literal>,
					this association is also deleted. Alternatively,
					the expression doesn't need to be free if it was
					bound to a report when it was parsed, as it will be
					automatically freed when freeing either the report,
					or the global <literal>opencreport</literal> structure.
					<programlisting>void ocrpt_expr_free(opencreport *o,
                     ocrpt_report *r,
                     ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Resolve expression references</title>
				<para>
					This function resolves variable (identifier)
					references in the expression. This is needed
					to bind query columns to expressions that
					use them.
					<programlisting>void ocrpt_expr_resolve(opencreport *o,
                        ocrpt_report *r,
                        ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Optimize an expression</title>
				<para>
					This function optimizes an expression so
					it may needs fewer computation steps during
					report execution.
					<programlisting>void ocrpt_expr_optimize(opencreport *o,
                         ocrpt_report *r,
                         ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Evaluate an expression</title>
				<para>
					This function evaluates the expression.
					It returns the expression's
					<literal>ocrpt_result</literal> result structure.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>
				</para>
				<para>
					For expressions with query column references,
					this function must be called after
					<literal>ocrpt_query_navigate_next</literal>
					otherwise the result is not valid.
					<programlisting>ocrpt_result *ocrpt_expr_eval(opencreport *o,
                              ocrpt_report *r,
                              ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Get expression result without evaluation</title>
				<para>
					This function returns the expression result
					if it was already evaluated.
					The result must not be freed with
					<literal>ocrpt_result_free()</literal>.
					It will be done by <literal>ocrpt_expr_free()</literal>.
					Used by unit tests.
					<programlisting>ocrpt_result *ocrpt_expr_get_result(opencreport *o,
                                    ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree</title>
				<para>
					Print an expression tree in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void ocrpt_expr_print(opencreport *o,
                      ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Print an expression tree with subexpressions and their results</title>
				<para>
					Print an expression tree with subexpressions
					and their results in its processed form on the
					standard output. Used by unit tests.
					<programlisting>void ocrpt_expr_result_deep_print(opencreport *o,
                                  ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Count the number of expression nodes</title>
				<para>
					This function returns the number of expression nodes.
					Used by unit tests to validate optimizazion.
					<programlisting>int32_t ocrpt_expr_nodes(ocrpt_expr *e);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Initialize expression result type</title>
				<para>
					OpenCReports keeps track of the last three query
					rows and computes three result values for expressions
					for internal reasons. These functions initialize
					the type for either the current result or all results
					of the expression.
					<programlisting>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

bool ocrpt_expr_init_result(opencreport *o,
                            ocrpt_expr *e,
                            enum ocrpt_result_type type);

void ocrpt_expr_init_results(opencreport *o,
                             ocrpt_expr *e,
                             enum ocrpt_result_type type);</programlisting>
				</para>
			</sect3>
			<sect3>
				<title>Set an error string as expression result</title>
				<para>
					<programlisting>ocrpt_result *
ocrpt_expr_make_error_result(opencreport *o,
                             ocrpt_expr *e,
                             const char *format, ...);</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1>
		<title>Paper size related functions</title>
		<para>
			Paper size in OpenCReports is handled via
			<ulink url="http://packages.qa.debian.org/libp/libpaper.html">libpaper</ulink>.
		</para>
		<para>
			This structure is used in OpenCReports to represent
			paper name and size:
			<programlisting>struct ocrpt_paper {
    const char *name;
    double width;
    double height;
};
typedef struct ocrpt_paper ocrpt_paper;</programlisting>
		</para>
		<sect2>
			<title><literal>ocrpt_get_system_paper</literal></title>
			<para>
				Get the system default <literal>ocrpt_paper</literal>.
				<programlisting>const ocrpt_paper *ocrpt_get_system_paper(void);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_get_paper_by_name</literal></title>
			<para>
				Get paper size of the specified paper name.
				<programlisting>const ocrpt_paper *ocrpt_get_paper_by_name(const char *paper);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_set_paper</literal></title>
			<para>
				Set paper for the report using an <literal>ocrpt_paper</literal> structure.
				The contents of the structure is copied.
				<programlisting>void ocrpt_set_paper(opencreport *o, const ocrpt_paper *paper);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_set_paper_by_name</literal></title>
			<para>
				Set paper for the report using a paper name.
				If the paper name is unknown, the system default paper is set.
				<programlisting>void ocrpt_set_paper_by_name(opencreport *o, const char *paper);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_get_paper</literal></title>
			<para>
				Get the report's currently set paper.
				<programlisting>const ocrpt_paper *ocrpt_get_paper(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_paper_first</literal></title>
			<para>
				Start an iterator for supported paper names and sizes.
				The returned paper structures are library-global but
				the iterator is per report handler. Only one iterator
				per report handler can be run at a time.
				<programlisting>const ocrpt_paper *ocrpt_paper_first(opencreport *o);</programlisting>
			</para>
		</sect2>
		<sect2>
			<title><literal>ocrpt_paper_next</literal></title>
			<para>
				Get the next <literal>ocrpt_paper</literal> structure
				in the iterator. It returns NULL when there is no more
				paper known to the system.
				<programlisting>const ocrpt_paper *ocrpt_paper_next(opencreport *o);</programlisting>
			</para>
		</sect2>
	</sect1>
</chapter>

<chapter id="expressions" xreflabel="Expressions">
	<title>Expressions in OpenCReports</title>
	<sect1 id="exprintro">
		<title>Introduction</title>
		<para>
			There are four data types in OpenCReports:
			<literal>numeric</literal>, <literal>string</literal>,
			<literal>datetime</literal> and <literal>error</literal>.
			Expressions can return any of these types.
		</para>
		<para>
			A <literal>numeric</literal> expression's result is
			a number. It uses high numeric precision. Most functions
			and operators deal with numbers.
		</para>
		<para>
			A <literal>string</literal> expression's result is a
			string. Strings can be concatenated or otherwise processed
			by string functions.
		</para>
		<para>
			A <literal>datetime</literal> expression may store a date,
			a time (with or without timezone) or both. Also, it may store
			a time interval, e.g. <literal>2 months</literal> that can be
			added to or subtracted from another <literal>datetime</literal>
			value.
		</para>
		<para>
			An <literal>error</literal> expression is a special case of
			strings: it stores a string literal (which is an error message)
			but it cannot be further processed by functions or operators.
			Instead, an error is propagated up from subexpressions to
			the final result of the expression.
		</para>
	</sect1>
	<sect1 id="constants" xreflabel="Constants">
		<title>Constants</title>
		<sect2 id="stringliterals" xreflabel="String literals">
			<title>String literals</title>
			<para>
				String literals in OpenCReports can be either single or double quoted.
				Some examples:
				<programlisting>"apple"
&#8217;apple&#8217;
"I&#8217;ve eaten an apple"
&#8217;This an "apple".&#8217;</programlisting>
				The values of these strings are:
				<programlisting>apple
apple
I&#8217;ve eaten an apple
This an "apple".</programlisting>
				We can see how the other quoting character can be used as part
				of the string value.
			</para>
			<para>
				String literals can also use BASIC language style double quoting
				to embed a single quoting character used for quoting the string
				itself:
				<programlisting>&#8217;apple&#8217;&#8217;&#8217;
&#8217;apple&#8217;&#8217;pear&#8217;
&#8217;apple&#8217;&#8217;&#8217;&#8217;pear&#8217;
"apple"""
"apple""pear"
"apple""""pear"</programlisting>			
				The values of these strings are:
				<programlisting>apple&#8217;
apple&#8217;pear
apple&#8217;&#8217;pear
apple"
apple"pear
apple""pear</programlisting>
			</para>
			<para>
				String literals can also use C language string continuation if
				there's at least one whitespace character (space, TAB or new line)
				between doubled quoting characters. String continuation can also
				switch quoting characters without whitespace between quoting.
				<programlisting>"apple" "pear"
"apple" &#8217;pear&#8217;
"apple"&#8217;pear&#8217;</programlisting>
				The value of all these strings is:
				<programlisting>applepear</programlisting>
			</para>
		</sect2>
		<sect2 id="numericconstants" xreflabel="Numeric constants">
			<title>Numeric constants</title>
			<para>
				Numeric values in OpenCReports are handled with GNU MPFR with
				arbitrary precision, by default 256 bits. This allows for
				very high precision, i.e. very long numbers. This is good
				for directly using e.g. arbitrary precision
				<literal>numeric</literal> type columns from PostgreSQL.
			</para>
			<para>
				Numeric constants can be integer or fractional numbers with or
				without the so called <emphasis>e-notation</emphasis> or
				scientific notation. Some examples:
				<programlisting>1
1.234
1e4
1e-4
1.234e-5</programlisting>
				E-notation means that that number preceding the letter "e" or
				"E" is multiplied by ten to the power of the number after the
				letter "e" or "E", the latter being an integer value. The
				values of the above examples are:
				<programlisting>1
1.234
10000
0.0001
0.00001234</programlisting>
			</para>
			<para>
				Numbers greater than 0 and less than 1 can be written with
				or without the leading zero.
				<programlisting>0.123
.123</programlisting>
			</para>
		</sect2>
		<sect2 id="boolconstants" xreflabel="Boolean constants">
			<title>Boolean constants</title>
			<para>
				Boolean constants evalutate to numeric constans
				<literal>1</literal> and <literal>0</literal>.
				The boolean constants are:
				<programlisting>yes
no
true
false</programlisting>
			</para>
		</sect2>
		<sect2 id="datetimeconstants" xreflabel="Datetime constants">
			<title>Datetime constants</title>
			<para>
				There are no datetime constants per se, although expressions
				like <literal>stodt('1980-06-30 16:00:00')</literal> (i.e.
				function calls with constant arguments that result in a
				<literal>datetime</literal> value) implicitly turn into
				constants through expression optimization.
			</para>
		</sect2>
		<sect2 id="constexpr" xreflabel="Constant expressions">
			<title>Constant expressions</title>
			<para>
				Constant expressions are ones that contain
				constant values (of any type) and operators
				or functions.
			</para>
		</sect2>
	</sect1>
	<sect1 id="precalcexpr" xreflabel="precalculated">
		<title>Precalculated expressions</title>
		<para>
			Due to the possibility of precalculated variables
			expressions, reports are actually run (and layed out)
			twice. The second run uses the precalculated values
			from the first run. Because of this,
			<literal>OpenCReports</literal> allows mixing precalculated
			<xref linkend="variables"/> and non-precalculated
			variables and subexpressions in the same expression.
			The result is intuitively expected.
		</para>
		<para>
			The actual report output is generated in the second run.
		</para>
	</sect1>
	<sect1 id="identifiers" xreflabel="Identifiers">
		<title>Identifiers</title>
		<para>
			Expressions may reference query column names, environment
			variables, internal variables and user defined
			<xref linkend="variables"/>.
			These references are called <emphasis>identifiers</emphasis>.
			Their values are evaluated during the report execution.
		</para>
		<sect2 id="identnames">
			<title>Identifier names</title>
			<para>
				Identifiers are in the format <literal>domain.identifier</literal>
				where the domain name or the dot are optional.
			</para>
			<para>
				OpenCReports is using UTF-8 encoding even in identifier
				names. Accented characters are accepted as identifiers.
			</para>
			<para>
				Valid names for <literal>domain</literal> and
				<literal>identifier</literal> may start with an underscore
				or UTF-8 letters and may contain underscore, UTF-8 letters
				and numbers in subsequent characters.
			</para>
		</sect2>
		<sect2 id="queryidents">
			<title>Query field identifiers</title>
			<para>
				Any valid identifier is by default a query column
				reference, with or without the domain name. Examples:
				<programlisting>field_name
field_name5
myquery1.field_name
oszlop_név
lekérdezés.oszlop_név</programlisting>
				By the way, in the above example,
				<literal>oszlop_név</literal> means
				<literal>field_name</literal>, and
				<literal>lekérdezés.oszlop_név</literal> means
				<literal>query.field_name</literal> in Hungarian.
				The accented characters are a courtesy of UTF-8.
			</para>
			<para>
				Query field identifiers in expressions are matched
				during expression resolution. If the domain name
				is specified, a query with that name must be present
				in the report, either as the main query or as a
				follower query. If the domain name is not specified,
				the field names of the main query and all the follower
				queries are matched with the expression.
			</para>
			<para>
				For exceptions (and exceptions from under the exceptions!),
				see below.
			</para>
		</sect2>
		<sect2 id="speciddomains" xreflabel="Special purpose identifier domains">
			<title>Special purpose identifier domains</title>
			<para>
				Some domain names carry special meaning for the report.
			</para>
			<sect3 id="envidents">
				<title>Environment variables</title>
				<para>
					Domain <literal>m</literal> indicates the domain
					of environment variables. The nature of environment
					variables depend on the languange binding. In C,
					it's the variables in the operating environment.
					In PHP, they are simply global PHP variables. Example:
					<programlisting>m.current_date</programlisting>
				</para>
				<para>
					Since such a setting is controlled outside the report,
					and for the duration of running the report, its value
					cannot (or <emphasis>shouldn't</emphasis>) change,
					environment variable references are treated as constants
					and are optimized as constant at the start of the report
					execution.
				</para>
				<para>
					Environment variables can't change during report
					execution in single threaded applications,
					<emphasis>but they can in multi-threaded ones</emphasis>.
					By optimizing environment variables into constants
					in expressions instead of querying the environment
					every time the same expression is evaluated,
					potential data races (that may result in inconsistent
					results) are eliminated or reduced.
				</para>
			</sect3>
			<sect3 id="internalvaridents">
				<title>Internal report variables</title>
				<para>
					Domain <literal>r</literal> indicates the domain
					of internal report variables.
				</para>
				<sect4 id="currpage">
					<title>Current page number</title>
					<para>
						<programlisting>r.pageno</programlisting>
						The current page of the report is maintained by
						the report layout and is intertwined with running
						a report. For example, if an expression is evaluated
						on page 4 of the report, and happens to reference
						the current page number variable, then this variable
						will have the value 4 in the result.
					</para>
				</sect4>
				<sect4 id="totpages" xreflabel="r.totpages">
					<title>Total number of pages</title>
					<para>
						<programlisting>r.totpages</programlisting>
						This variable carries the total number of pages
						in the report. Its value is maintained by the
						report. This variable is inherently
						<xref linkend="precalcexpr"/>.
					</para>
				</sect4>
				<sect4 id="lineno">
					<title>Line number</title>
					<para>
						<programlisting>r.lineno</programlisting>
						This variable is an alias to the
						<literal>rownum()</literal> function, i.e.
						it is the current row (line) number in the data set.
					</para>
					<para>
						Being an alias means that the variable is replaced by
						the <literal>rownum()</literal> function call in the
						grammar. Please, be aware, that functions may be
						overridden by user defined functions. If
						<literal>rownum()</literal> is overridden, then it will
						be called with zero arguments by the grammar transformation,
						which may or may not work for the user defined function
						and the variable will not work as intended.
					</para>
				</sect4>
				<sect4 id="detailcount">
					<title>Detail count</title>
					<para>
						<programlisting>r.detailcnt</programlisting>
						This variable works similarly to the row number
						counter, e.g. <literal>rownum()</literal> or
						<literal>r.lineno</literal>, except it restarts
						from 1 at every <literal>&lt;FieldHeaders&gt;</literal>.
					</para>
					<para>
						With the default behaviour of
						<literal>&lt;Breaks&gt;</literal> vs
						<literal>&lt;FieldHeaders&gt;</literal>,
						i.e. when <literal>&lt;FieldHeaders&gt;</literal>
						is printed on the top of every page,
						<literal>r.detailcnt</literal> works as a per page
						line count value.
					</para>
					<para>
						When <literal>&lt;Report field_header_priority="low"&gt;</literal>
						is used, the effect may be more emphasized because
						the value of this variable is reset more often.
					</para>
				</sect4>
				<sect4 id="fieldval">
					<title>Field value</title>
					<para>
						<programlisting>r.value</programlisting>
						The report field description has an expression for its
						value in the  form of
						<literal>&lt;field value="..." /&gt;</literal>.
						It also has supplementary expressions, like the
						foreground and background colors, the format string,
						and others.
					</para>
					<para>
						The supplementary expressions may reference the field
						value, without having to type out the field expression
						multiple times.
					</para>
					<para>
						Using <literal>r.value</literal> also helps reducing
						the report runtime because the value expression is not
						computed multiple times. This is a manual
						optimization.
					</para>
					<para>
						Referencing <literal>r.value</literal> is only possible
						for supplementary expressions for the same field
						description, i.e. other XML attributes for a
						<literal>&lt;field value="..." .../&gt;</literal>
						line. This variable cannot cross-reference other
						field descriptions, or anything not in the same scope.
						For this purpose, there are user
						<xref linkend="variables"/>.
					</para>
				</sect4>
				<sect4 id="fieldformat">
					<title>Format string value</title>
					<para>
						<programlisting>r.format</programlisting>
						Similarly to the field value a.k.a.
						<literal>r.value</literal>, the field description
						has an an optional expression for its formatting
						in the form of
						<literal>&lt;field format="..." /&gt;</literal>.
					</para>
					<para>
						This internal variable may be used by other
						expressions. It has very few use cases, if any.
						It only exists for compatibility with RLIB that
						has this internal variable.
					</para>
				</sect4>
				<sect4 id="exprself" xreflabel="Expression self reference">
					<title>Expression self reference</title>
					<para>
						<programlisting>r.self</programlisting>
						This variable references the previous result of
						the expression. It is used in iterative expressions,
						like in user-defined <xref linkend="variables"/>.
						It can be used in any user defined expression.
					</para>
				</sect4>
				<sect4 id="uservarsubexpr">
					<title>Subexpressions of user-defined variables</title>
					<para>
						<programlisting>r.baseexpr
r.intermedexpr
r.intermed2expr</programlisting>
						These variables are references for the three
						subexpressions that potentially make up a
						user-defined custom variable. The expressions in
						order are: base expression, intermediary expressions
						one and two. Their evaluation order is the same
						as in the order they are mentioned here.
					</para>
					<para>
						Actually, there's a fourth subexpression that exists
						in every user defined variable, namely the result
						expression. It's reference is simply the user variable
						reference, see <xref linkend="uservariables"/>.
						See also <xref linkend="customvarattrs"/>.
					</para>
					<para>
						For example, a running average over a data series
						needs two intermediary expressions: one for
						the sum of the values, the other for the number
						of values in the series. The result is the
						sum of values divided by the number of values.
					</para>
					<para>
						Their usage is only valid when declaring a custom
						user defined variable.
					</para>
				</sect4>
			</sect3>
			<sect3 id="uservariables" xreflabel="User defined variables">
				<title>User defined variables</title>
				<para>
					Domain <literal>v</literal> signifies user defined
					report variables, which can be used in breaks or
					to shortcut expressions. Example:
					<programlisting>v.my_variable
					</programlisting>
				</para>
			</sect3>
			<sect3 id="quotedidents">
				<title>Quoted and dot-prefixed identifiers</title>
				<para>
					Both <literal>domain</literal> and <literal>identifier</literal>
					names may be quoted or unquoted. Quoting names allow using
					semi-reserved and reserved words as identifiers and also
					allow special characters in identifier names. Examples:
					<programlisting>query.field_name1
query."field_name2"
query."field with space in the name"
"query2".field_name3
"query2"."and"
					</programlisting>
				</para>
			</sect3>
			<sect3 id="dotprefixedidents">
				<title>Dot-prefixed identifiers</title>
				<para>
					A dot-prefixed identifier is one where the domain name
					is not specified, but the identifier name is prefixed
					with a dot. Examples:
					<programlisting>.field_name
."field_name"
					</programlisting>
				</para>
				<para>
					Semi-reserved words are the boolean constants. They can be used
					as identifiers with dot-prefixed identifier names without
					a domain name and without quoting:
					<programlisting>.yes
.no
.true
.false
yes.no
					</programlisting>
					The above unquoted identifiers are equivalent with
					these quoted ones below:
					<programlisting>."yes"
."no"
."true"
."false"
"yes"."no"
					</programlisting>
				</para>
				<para>
					Operator names are reserved words, e.g. <literal>and</literal>
					and <literal>or</literal>. They cannot be used with dot-prefixed
					operator names without quoting, as it would cause an
					expression syntax error. But they can be used as quoted
					identifiers, in case you would want to use such a query name
					and column name:
					<programlisting>."and"
."or"
"and"."or"
					</programlisting>
				</para>
			</sect3>
			<sect3 id="quotedinternaldomains">
				<title>Quoted special purpose identifier domains</title>
				<para>
					When identifier domains are quoted, they lose their special
					meaning and the identifiers become query field identifiers.
					Of course, in this case, such a query name must exist and
					the query must have a field name specified in the identifier.
					Examples:
					<programlisting>"m".current_date
"r".totpages
"v".my_variable
					</programlisting>
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="opsandfunc" xreflabel="Operators and functions">
		<title>Operators and functions</title>
		<para>
			OpenCReports expressions can use several operators and functions.
			The operator precedence is mostly as expected from the C
			programming language. One notable exception is implicit
			multiplication. The precedence classes are as below,
			in increasing order of precedence.
		</para>
		<sect2 id="ternaryop">
			<title>Ternary operator</title>
			<para>
				The ternary operator is as in the C language:
				<programlisting>expression1 ? expression2 : expression3
				</programlisting>
				It's evaluated as follows: if the value of numeric
				<literal>expression1</literal> is <literal>true</literal>
				(i.e. non-zero), then the result is the <literal>expression2</literal>,
				otherwise it's <literal>expression3</literal>.
				Type of <literal>expression2</literal> and
				<literal>expression3</literal> may differ, i.e. the
				result type will be the type of the underlying expression
				but it can result in runtime errors.
			</para>
		</sect2>
		<sect2 id="logicalops">
			<title>Logical operators with two operands</title>
			<para>
				Logical OR can be written as <literal>||</literal> or
				<literal>or</literal>. Example: <literal>a || b</literal>
			</para>
			<para>
				Logical AND can be written as <literal>&amp;&amp;</literal> or
				<literal>and</literal>. Logical AND has precedence over OR.
				Example: <literal>a &amp;&amp; b</literal>
			</para>
		</sect2>
		<sect2 id="bitwiseops">
			<title>Bitwise operators with two operands</title>
			<para>
			The bitwise operators in this precedence class and in their
			increasing order of precedence are:
			bitwise OR (<literal>|</literal>) and
            bitwise AND (<literal>&amp;</literal>).
			</para>
		</sect2>
		<sect2 id="eqneops">
			<title>Equality and inequality comparison operators</title>
			<para>
				The equality comparison operator can be written as
				<literal>=</literal> or <literal>==</literal>.
			</para>
			<para>
				The inequality comparison operator can be written as
				<literal>&lt;&gt;</literal> or <literal>!=</literal>.
			</para>
		</sect2>
		<sect2 id="cmpops">
			<title>Other comparison operators</title>
			<para>
				Less-than (<literal>&lt;</literal>),
				less-or-equal (<literal>&lt;=</literal>),
				greater-than (<literal>&gt;</literal>) and
				greater-or-equal (<literal>&gt;=</literal>).
			</para>
		</sect2>
		<sect2 id="shiftops">
			<title>Bitwise shifts</title>
			<para>
				Bitwise shift left (<literal>a &gt;&gt; b</literal>) and
				bitwise shift right (<literal>a &lt;&lt; b</literal>).
			</para>
		</sect2>
		<sect2 id="addsubops">
			<title>Addition and subtraction</title>
			<para>
				<literal>a + b</literal> and <literal>a - b</literal>.
			</para>
		</sect2>
		<sect2 id="muldivmodops">
			<title>Multiplication, division and modulo (remainder)</title>
			<para>
				<literal>a * b</literal>, <literal>a / b</literal> and
				<literal>a % b</literal>.
			</para>
		</sect2>
		<sect2 id="powop">
			<title>Power-of operator</title>
			<para>
				<literal>a ^ b</literal> works as a-to-the-power-of-b.
			</para>
		</sect2>
		<sect2 id="factop">
			<title>Factorial operator</title>
			<para>
				<literal>a!</literal>, the '!' sign used as postfix operator.
			</para>
		</sect2>
		<sect2 id="unaryprefixops">
			<title>Unary plus and minus, logical and bitwise NOT, prefix increment and decrement</title>
			<para>
				Unary plus (<literal>+a</literal>), unary minus (<literal>-a</literal>),
				logical NOT (<literal>!a</literal>, '!' used as prefix operator),
				bitwise NOT (<literal>~a</literal>), prefix increment (<literal>++a</literal>)
				and prefix decrement (<literal>--a</literal>).
			</para>
		</sect2>
		<sect2 id="postfixops">
			<title>Postfix increment and decrement</title>
			<para>
				Postfix increment (<literal>a++</literal>) and decrement
				(<literal>a--</literal>).
			</para>
		</sect2>
		<sect2 id="funccalls">
			<title>Function calls and implicit multiplication</title>
			<para>
				Function calls execute a function on operands:
				<literal>function(operand[, ...])</literal>. A function name
				is a single word known by OpenCReports at the time of parsing,
				either as a built-in function, or a user-supplied one.
				The function name cannot have a leading dot or be a
				domain-qualified identifier.
			</para>
			<para>
				Implicit multiplication is when two distinct operands are in
				juxtaposition, in other words they are written side by side
				without any whitespace. In this case, there is an implied
				multiplication between them that acts with higher precedence
				than regular multiplication or division. Implicit multiplication
				is applicable in these situations:
				<itemizedlist>
					<listitem>
						<para>
							A numeric constant juxtaposed with an identifier,
							the numeric constant is the on the left side.
							<programlisting>2x</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							A numeric constant juxtaposed with an expression inside
							parentheses. The constant can be on either side of the
							expression.
							<programlisting>2(a+b)
(a+b)2</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							An identifier juxtaposed with an expression inside
							parentheses, the identifier is on the left side of the
							expression.
							<programlisting>x(a+b)</programlisting>
						</para>
						<para>
							This is only treated as implicit
							multiplication if the identifier name is not known as
							a function name at the time of parsing and there is
							a single expression inside the parentheses.
							No expressions, a single expression with a known function
							name as the identifier, or a series of comma delimited
							series of expressions are treated as a function call and
							the function call validity is checked against the number
							of operands, with a potential parser error. If there's
							an ambiguity between function names and identifiers
							provided by data sources, it can be avoided by using
							dot-prefixed or dot-prefixed and quoted identifiers,
							or fully qualified identifiers in the form of
							<literal>query.identifier</literal>.
						</para>
					</listitem>
					<listitem>
						<para>
							An expression inside parentheses juxtaposed with an identifier
							on the right side.
							<programlisting>(a+b)a</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							Two expressions inside parentheses juxtaposed with each other.
							<programlisting>(a+b)(c+d)</programlisting>
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Implicit multiplication is NOT applicable in these situations,
				besides the exceptions already explained above:
				<itemizedlist>
					<listitem>
						<para>
							An identifier juxtaposed with a numeric constant,
							the numeric constant is the on the right side.
							<programlisting>x2</programlisting>
						</para>
						<para>
							Since an identifier name may include digits as the
							second and subsequent characters, the numeric
							constant, or at least its integer part is simply
							recognized as part of the identifier name itself
							according to the token matching. This can also result
							in syntax errors when not handled with care.
						</para>
					</listitem>
					<listitem>
						<para>
							An identifier juxtaposed with another identifier.
							<programlisting>ab</programlisting>
						</para>
						<para>
							The reason is the same as in the preceding case:
							there is only a single identifier according to
							token matching.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2 id="parens">
			<title>Parentheses</title>
			<para>
				Parenthesized expressions are always computed first.
			</para>
		</sect2>
		<sect2 id="tokmatchandprec">
			<title>Token matching, precendence and syntax errors</title>
			<para>
				Expression parsing works on two levels: token matching (the
				job of Flex) and applying grammar (the job of Bison).
				Token matching breaks up the expression string into tokens
				in a greedy way: without whitepace delimiters, the longest
				possible token is chosen.
			</para>
			<para>
				This may lead to slight confusion when coupled with
				implicit multiplication. For example, the expression
				<literal>2e-1e</literal> is broken up into two tokens:
				<literal>2e-1</literal> juxtaposed with
				<literal>e</literal>. The first token is interpreted as
				a numeric constant using <emphasis>e-notation</emphasis>
				(so that it will mean <literal>2 * 10^(-1)</literal>) and
				the second is the identifier <literal>e</literal>, leading
				to the meaning <literal>0.2 * e</literal>. This is
				unambiguous for the computer, but can be somewhat confusing
				to the the user reading or writing expressions. To avoid
				any confusion, don't use implicit multiplication and use
				whitespace and parentheses gratituously.
			</para>
			<para>
				Expression parsing handles precedence and whitespaces.
				For example, these below do not mean the same thing:
				<programlisting>a++ + ++b
a+++++b
				</programlisting>
				The former is obvious, but the latter may be a little
				surprising: <literal>(a++)++ + b</literal>, but not when
				considering precedence and the Flex lexer behaviour to
				match the the longest known token first. In this case,
				to make the expression unambiguous, whitespace or parenthesis
				should be used. Another ambiguous example:
				<programlisting>a++b
				</programlisting>
				The above may be interpreted as <literal>a + +b</literal>
				but since no whitespace is used, Flex is free to interpret
				it as <literal>a++ b</literal>, because <literal>++</literal>
				is longer than <literal>+</literal>, so the former is matched
				first as an operator token. This is a syntax error and
				expression parsing throws an error for it.
			</para>
		</sect2>
	</sect1>
	<sect1 id="listoffuncs">
		<title>Alphabetical list of functions</title>
		<para>
			Most functions below operate in this way, unless noted otherwise:
			<itemizedlist>
				<listitem>
					<para>
						numeric and bitwise functions with more than two operands
						take their first operand and perform the same operation
						using the second, third, etc. operands repeatedly.
					</para>
				</listitem>
				<listitem>
					<para>
						if any of the operands is an error (resulting from
						runtime processing of a subexpression), then the
						result will use the exact error of the first operand
						that is an error.
					</para>
				</listitem>
				<listitem>
					<para>
						if any of the operands is NULL (e.g. the data source
						is SQL and the field value is SQL NULL) then the
						result will also be NULL.
					</para>
				</listitem>
				<listitem>
					<para>
						Boolean logic functions treat their operands with
						0 being false and anything else (even fractions less
						than 0.5) as true.
					</para>
				</listitem>
				<listitem>
					<para>
						Bitwise functions treat their operands as 64-bit
						numeric values, with rounding if they are fractions.
					</para>
				</listitem>
				<listitem>
					<para>
						String arithmetics operate on UTF-8 encoded strings
						and count in number of UTF-8 characters instead of
						byte length.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<sect2 id="absfunc">
			<title>abs()</title>
			<para>
				Absolute value. Operator <literal>|...|</literal>
				is a shortcut for this function.
				It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="acosfunc">
			<title>acos()</title>
			<para>
				Arc-cosine function. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="addfunc">
			<title>add()</title>
			<para>
				Addition. Operator <literal>+</literal> is a shortcut for
				this function. It takes two or more operands of the same
				type, with all of them being either numeric or string.
				For string operands, it is equivalent with concatenation,
				i.e. <literal>concat()</literal> below.
			</para>
		</sect2>
		<sect2 id="andfunc">
			<title>and()</title>
			<para>
				Bitwise AND. Operator <literal>&amp;</literal> is a shortcut for
				this function. It takes two or more numeric operands.
			</para>
		</sect2>
		<sect2 id="asinfunc">
			<title>asin()</title>
			<para>
				Arc-sine function. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="atanfunc">
			<title>atan()</title>
			<para>
				Arc-tangent function. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="brrownumfunc" xreflabel="Break row number function">
			<title>brrownum()</title>
			<para>
				Current row number of a break since it was last triggered.
				It takes one string operand which is the name of the break.
				The row number restarts from 1 at every break boundary.
			</para>
		</sect2>
		<sect2 id="ceilfunc">
			<title>ceil()</title>
			<para>
				Rounds its operand to the next higher or equal integer.
				It takes one numeric operands.
			</para>
		</sect2>
		<sect2 id="chgdateoffunc">
			<title>chgdateof()</title>
			<para>
				It takes two datetime operands.
				Changes the date part of the first operand to
				the date part of the second operand.
			</para>
		</sect2>
		<sect2 id="chgtimeoffunc">
			<title>chgtimeof()</title>
			<para>
				It takes two datetime operands.
				Changes the time part of the first operand to
				the date part of the second operand.
			</para>
		</sect2>
		<sect2 id="concatfunc">
			<title>concat()</title>
			<para>
				String concatenation. It takes two or more string operands.
			</para>
		</sect2>
		<sect2 id="cosfunc">
			<title>cos()</title>
			<para>
				Cosine function. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="cotfunc">
			<title>cot()</title>
			<para>
				Cotangent function. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="cscfunc">
			<title>csc()</title>
			<para>
				Cosecant function. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="datefunc">
			<title>date()</title>
			<para>
				Returns the current date. It takes zero operands.
			</para>
		</sect2>
		<sect2 id="dateoffunc">
			<title>dateof()</title>
			<para>
				It takes one datetime operand.
				It returns date part of the datetime operand.
			</para>
		</sect2>
		<sect2 id="dayfunc">
			<title>day()</title>
			<para>
				It takes one datetime operand.
				It returns the day of month value as a number.
			</para>
		</sect2>
		<sect2 id="decfunc">
			<title>dec()</title>
			<para>
				Decrement by one. It takes one numeric operand.
				The operator <literal>++</literal> is the shortcut for it,
				either in prefix or postfix uses.
			</para>
		</sect2>
		<sect2 id="dimfunc">
			<title>dim()</title>
			<para>
				It takes one datetime operand. Given the year and month
				values of the datetime, this function returns the
				number of days in the month. E.g. for February in a leap
				year, it returns 29.
			</para>
		</sect2>
		<sect2 id="divfunc">
			<title>div()</title>
			<para>
				Division. Operator <literal>/</literal> is a shortcut for
				this function. It takes two or more numeric operands.
				The way it works is: take the first operand and divide
				it by the second and subsequent operands in sequence.
			</para>
		</sect2>
		<sect2 id="dtosfunc">
			<title>dtos()</title>
			<para>
				Datetime to string. It takes one datetime operand.
				The date part of the datetime is formatted according
				to the date format of the currently set locale.
			</para>
		</sect2>
		<sect2 id="dtosffunc">
			<title>dtosf()</title>
			<para>
				Datetime to formatted string. It takes two operands:
				one datetime and one string. It takes the second (string)
				operand as a format string and formats the datetime
				value according to the format string.
				If the second operand is NULL or empty string,
				this function behaves like <literal>dtos()</literal>.
				Otherwise it behaves like <literal>format()</literal>
				with the operands reversed.
			</para>
		</sect2>
		<sect2 id="eqfunc">
			<title>eq()</title>
			<para>
				Equivalence. Operator <literal>=</literal> and <literal>==</literal>
				are a shortcuts for this function. It takes two operands of
				the same type: numeric, string or datetime.
				The result is numeric value 1 or 0, if the two operands are
				equal or non-equal, respectively.
			</para>
		</sect2>
		<sect2 id="errorfunc">
			<title>error()</title>
			<para>
				Returns an artificially generated error. It takes one
				string operand. The result will use the string operand's
				value as error message. Good for unit testing OpenCReports
				as done in the <literal>ocrpt_expr_test</literal> example.
			</para>
		</sect2>
		<sect2 id="expfunc">
			<title>exp()</title>
			<para>
				It takes one numeric operand and returns the exponential 
				of the operand.
			</para>
		</sect2>
		<sect2 id="exp10func">
			<title>exp10()</title>
			<para>
				It takes one numeric operand and returns 10 to the power
				of the operand.
			</para>
		</sect2>
		<sect2 id="exp2func">
			<title>exp2()</title>
			<para>
				It takes one numeric operand and returns 2 to the power
				of the operand.
			</para>
		</sect2>
		<sect2 id="evalfunc">
			<title>eval()</title>
			<para>
				It takes one string operand, which must be an expression
				string. The expression is parsed. If it's correct, it is
				inserted into the parent expression in place of the
				function call. If there is a syntax error, the error is
				re-thrown for the main expression.
			</para>
			<para>
				This is a pseudo-function. The grammar detects its usage
				and converts the embedded expression string into a regular
				subexpression, like if it was inside parenthesis in the
				parent expression contents. This allows the subexpression
				to be optimized in the parent expression context.
			</para>
			<para>
				Fox example, the expression <literal>3 * eval('1 + 2')</literal>
				is optimized into the numeric constant <literal>9</literal>.
			</para>
			<para>
				Note, that the grammar transformation only takes place if
				there is no user defined function with the same name.
				In this case, the user defined function is used.
			</para>
		</sect2>
		<sect2 id="factorialfunc">
			<title>factorial()</title>
			<para>
				Factorial function. It takes one numeric operand.
				The postfix operator <literal>!</literal> is the alias for
				this function.
			</para>
		</sect2>
		<sect2 id="floorfunc">
			<title>floor()</title>
			<para>
				Rounds its operand to the next lower or equal integer.
				It takes one numeric operands.
			</para>
		</sect2>
		<sect2 id="fmodfunc">
			<title>fmod()</title>
			<para>
				The result to the value of <literal>x - ny</literal>
				(<literal>x</literal> and <literal>y</literal> being
				its two numeric operands), rounded according to the
				report rounding mode set via <literal>ocrpt_set_rounding_mode()</literal>,
				where <literal>n</literal> is the integer quotient of
				<literal>x</literal> divided by <literal>y</literal>,
				<literal>n</literal> is rounded toward zero.
				It takes two numeric operands.
			</para>
		</sect2>
		<sect2 id="formatfunc" xreflabel="format function">
			<title>format()</title>
			<para>
				It takes two operands, the first operand is of any type,
				the second operand is a string. This function formats
				the first value according to the second operand as a
				format string. If the first operand doesn't match the
				expected type in the format string, an error is returned.
			</para>
			<para>
				It an RLIB compatibility function and is a special case
				of the <literal>printf()</literal> function.
				See also <xref linkend="formatting"/>
			</para>
		</sect2>
		<sect2 id="fxpvalfunc">
			<title>fxpval()</title>
			<para>
				Compatibility function for RLIB. It takes two operands.
				The type of the first operand may be string containing
				a numeric value or numeric. If it's a string, then it will
				be converted to numeric first. The type of the second operand
				is numeric. The function divides the value of the first
				operand with 10 to the power of the value of the second
				operand. One use case is that if the data contains prices
				in cents, then <literal>fxpval(data, 2)</literal> puts the
				decimal separator to the correct place.
			</para>
		</sect2>
		<sect2 id="gefunc">
			<title>ge()</title>
			<para>
				Greater-or-equal. It takes two operands of the same type,
				which can be either numeric, string or datetime operands.
				The operator <literal>&gt;=</literal> is the shortcut for
				this function.
			</para>
		</sect2>
		<sect2 id="gettimeinsecsfunc">
			<title>gettimeinsecs()</title>
			<para>
				It takes one datetime operand. It converts the time part
				of the datetime to seconds elapsed from 00:00:00.
			</para>
		</sect2>
		<sect2 id="gtfunc">
			<title>gt()</title>
			<para>
				Greater-than. It takes two operands of the same type,
				which can be either numeric, string or datetime operands.
				The operator <literal>&gt;</literal> is the shortcut for
				this function.
			</para>
		</sect2>
		<sect2 id="iiffunc">
			<title>iif()</title>
			<para>
				Trinary function. It takes three operands of which the first one
				is numeric, the second and third operands can be of any type.
				If the first operand is non-zero (i.e.: "true") then
				the result will be the value of the second operand,
				else it will be the third operand.
				The trinary operator <literal>exp1 ? exp2 : exp3</literal>
				is the shortcut for this function.
			</para>
		</sect2>
		<sect2 id="incfunc">
			<title>inc()</title>
			<para>
				Increment by one. It takes one numeric operand.
				The operator <literal>--</literal> is the shortcut for it,
				either in prefix or postfix uses.
			</para>
		</sect2>
		<sect2 id="intervalfunc">
			<title>interval()</title>
			<para>
				Convert the parameter(s) to an interval subtype of
				the datetime type. It takes either one string operand
				or six numeric operands. In the first case, the string
				is parsed for interval values, like <literal>1 year</literal>
				or <literal>2 months</literal>, etc., and sets the specific
				datetime part values. In the second case, the six numeric
				operands are the values for the datetime parts, in the order
				of years, months, days, hours, minutes and seconds.
			</para>
		</sect2>
		<sect2 id="isnullfunc">
			<title>isnull()</title>
			<para>
				Returns numeric 1 if the operand is NULL, 0 otherwise.
				It takes one operand of any type.
			</para>
		</sect2>
		<sect2 id="landfunc">
			<title>land()</title>
			<para>
				Boolean logic AND. Operator <literal>&amp;&amp;</literal> is a
				shortcut for this function. It takes two or more numeric
				operands that are treated as boolean logic values. The
				function is executed until the result is fully determined,
				i.e. it stops at the first false value.
			</para>
		</sect2>
		<sect2 id="lefunc">
			<title>le()</title>
			<para>
				Less-or-equal. It takes two operands of the same type,
				which can be either numeric, string or datetime operands.
				The operator <literal>&lt;=</literal> is the shortcut for
				this function.
			</para>
		</sect2>
		<sect2 id="leftfunc">
			<title>left()</title>
			<para>
				Returns the leftmost N characters of a string.
				It takes two operands, the first operand is the string,
				the second is the numeric that is handled as an integer
				and used to determine the returned string length.
			</para>
		</sect2>
		<sect2 id="lnfunc">
			<title>ln()</title>
			<para>
				Alias for <literal>log()</literal>.
			</para>
		</sect2>
		<sect2 id="lnotfunc">
			<title>lnot()</title>
			<para>
				Boolean logic NOT. Prefix operator <literal>!</literal> is
				the shortcut for this function. It returns the negated
				boolean value of its operand. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="logfunc">
			<title>log()</title>
			<para>
				Natural logarithm. It takes one nueric operand.
			</para>
		</sect2>
		<sect2 id="log10func">
			<title>log10()</title>
			<para>
				Base-10 logarithm. It takes one nueric operand.
			</para>
		</sect2>
		<sect2 id="log2func">
			<title>log2()</title>
			<para>
				Base-2 logarithm. It takes one nueric operand.
			</para>
		</sect2>
		<sect2 id="lorfunc">
			<title>lor()</title>
			<para>
				Boolean logic OR. Operator <literal>||</literal> is a shortcut for
				this function. It takes two or more numeric operands that
				are treated as boolean logic values, with 0 being false and
				true for anything else. The function is executed until the result is
				determined fully, i.e. it stops at the first true value.
			</para>
		</sect2>
		<sect2 id="lowerfunc">
			<title>lower()</title>
			<para>
				Lowercase conversion. It takes one string operand.
			</para>
		</sect2>
		<sect2 id="ltfunc">
			<title>lt()</title>
			<para>
				Less-than. It takes two operands of the same type,
				which can be either numeric, string or datetime operands.
				The operator <literal>&lt;</literal> is the shortcut for this
				function.
			</para>
		</sect2>
		<sect2 id="midfunc">
			<title>mid()</title>
			<para>
				Return characters from the middle of the string.
				It takes three operands, the first operand is the string,
				the second and third are numeric values that are handled
				as an integers. The second operand is the offset to start
				from and the third operand is the length of the result
				string in UTF-8 characters. The offset is 1-based just like
				in BASIC, with offset value 0 being identical to 1.
				Negative offsets count from the right end of the string,
				i.e. <literal>mid(s,-n,n)</literal> is equivalent to
				<literal>right(s,n)</literal>.
			</para>
		</sect2>
		<sect2 id="modfunc">
			<title>mod()</title>
			<para>
				An alias of <literal>remainder()</literal>.
				It takes two numeric operands.
			</para>
		</sect2>
		<sect2 id="monthfunc">
			<title>month()</title>
			<para>
				Returns the month value of a datetime. It takes one datetime operand.
			</para>
		</sect2>
		<sect2 id="mulfunc">
			<title>mul()</title>
			<para>
				Multiplication. Operator <literal>*</literal> is a shortcut for
				this function. It takes two or more numeric operands.
			</para>
		</sect2>
		<sect2 id="nefunc">
			<title>ne()</title>
			<para>
				Not equal. It takes two operands of the same type,
				which can be either numeric, string or datetime operands.
				The operator <literal>!=</literal> and <literal>&lt;&gt;</literal>
				are shortcuts for it.
			</para>
		</sect2>
		<sect2 id="notfunc">
			<title>not()</title>
			<para>
				Bitwise NOT. Prefix operator <literal>~</literal> is
				the shortcut for this function. It returns the bit-by-bit
				negated value of its operand. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="nowfunc">
			<title>now()</title>
			<para>
				Returns the current timestamp. It is run only once
				during running the report and the same value is used
				everywhere where this function is used. Practically,
				it is the time of generating the report.
				It takes zero operands.
			</para>
		</sect2>
		<sect2 id="nullfunc">
			<title>null()</title>
			<para>
				Generate NULL value using the type of its operand.
				It takes one operand of any type.
			</para>
		</sect2>
		<sect2 id="nulldtfunc">
			<title>nulldt()</title>
			<para>
				Generate NULL of the datetime type. It takes no operands.
			</para>
		</sect2>
		<sect2 id="nullnfunc">
			<title>nulln()</title>
			<para>
				Generate NULL of the numeric type. It takes no operands.
			</para>
		</sect2>
		<sect2 id="nullsfunc">
			<title>nulls()</title>
			<para>
				Generate NULL of the string type. It takes no operands.
			</para>
		</sect2>
		<sect2 id="orfunc">
			<title>or()</title>
			<para>
				Bitwise OR. Operator <literal>|</literal> is a shortcut for
				this function. It takes two or more numeric operands.
			</para>
		</sect2>
		<sect2 id="powfunc">
			<title>pow()</title>
			<para>
				This function raises the first operand to the power of its
				second operand. It takes two numeric operands.
				Operator <literal>^</literal> is the shortcut for
				this function.
			</para>
		</sect2>
		<sect2 id="prevvalfunc">
			<title>prevval()</title>
			<para>
				This function accepts one subexpression and
				returns the subexpression's previous value, i.e.
				the value generated for the previous query row.
				If there is no previous value row, the result
				of this function is an error.
			</para>
			<para>
				This function allows showing carried over values
				e.g. in page headers.
			</para>
		</sect2>
		<sect2 id="printffunc" xreflabel="printf function">
			<title>printf()</title>
			<para>
				This function takes one or more operands. The first
				operand is a string and used as the format string.
				Subsequent operands have to be of the expected type
				according to the format string, otherwise an error
				is returned. If everything is correct, it returns
				the formatted data as a string.
			</para>
		</sect2>
		<sect2 id="properfunc">
			<title>proper()</title>
			<para>
				This function takes one string operand. The function
				returns the string converted lowecase, except the first
				letter of the first word, which will be uppercase.
			</para>
		</sect2>
		<sect2 id="randomfunc">
			<title>random()</title>
			<para>
				Generate a pseudo-random numeric value between 0 and 1.
				It takes no operands.
			</para>
		</sect2>
		<sect2 id="remainderfunc">
			<title>remainder()</title>
			<para>
				The result to the value of <literal>x - ny</literal>
				(<literal>x</literal> and <literal>y</literal> being
				its two numeric operands), rounded according to the
				report rounding mode set via <literal>ocrpt_set_rounding_mode()</literal>,
				where <literal>n</literal> is the integer quotient of
				<literal>x</literal> divided by <literal>y</literal>,
				<literal>n</literal> is rounded toward to the nearest integer.
				It takes two numeric operands.
			</para>
		</sect2>
		<sect2 id="rightfunc">
			<title>right()</title>
			<para>
				Returns the rightmost N characters of a string.
				It takes two operands, the first operand is the string,
				the second is the numeric that is handled as an integer
				and used to determine the returned string length.
			</para>
		</sect2>
		<sect2 id="rintfunc">
			<title>rint()</title>
			<para>
				Rounds its operand using the rounding mode set via
				<literal>ocrpt_set_rounding_mode()</literal>.
				It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="roundfunc">
			<title>round()</title>
			<para>
				Rounds its operand to the nearest representable integer,
				rounding halfway cases away from zero.
				It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="rownumfunc">
			<title>rownum()</title>
			<para>
				It takes either zero operands or one string operand.
				If zero operands are passed, it returns the current
				row number of the dataset. If one string operand is
				passed, then it returns the current row number in
				the named query of the dataset. See the follower
				queries.
			</para>
		</sect2>
		<sect2 id="secfunc">
			<title>sec()</title>
			<para>
				Secant. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="settimeinsecsfunc">
			<title>settimeinsecs()</title>
			<para>
				It takes two operands, the first operand is a datetime,
				the second is numeric. This function returns a datetime
				where the first operand's time part is changed to
				<literal>N</literal> seconds
				after 00:00:00, with <literal>N</literal> being the
				second operand.
			</para>
		</sect2>
		<sect2 id="shlfunc">
			<title>shl()</title>
			<para>
				Bitwise shift left. Shifts the first operand left with the
				number of bits set indicated the second operand. The operand
				<literal>&lt;&lt;</literal> is the shortcut for this
				function. It takes two numeric operands.
			</para>
		</sect2>
		<sect2 id="shrfunc">
			<title>shr()</title>
			<para>
				Bitwise shift right. Shifts the first operand right with the
				number of bits indicated by the second operand. The operand
				<literal>&gt;&gt;</literal> is the shortcut for this
				function. It takes two numeric operands.
			</para>
		</sect2>
		<sect2 id="sinfunc">
			<title>sin()</title>
			<para>
				Sine. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="sqrfunc">
			<title>sqr()</title>
			<para>
				Square. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="sqrtfunc">
			<title>sqrt()</title>
			<para>
				Square root. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="stdwiyfunc">
			<title>stdwiy()</title>
			<para>
				It takes one datetime operand. This function returns
				the  ISO-8601 week number of the operand as a decimal
				number, range 01 to 53, where week 1 is the first week
				that has at least 4 days in the new year.
			</para>
		</sect2>
		<sect2 id="stodfunc">
			<title>stod()</title>
			<para>
				Alias for <literal>stodt()</literal>.
			</para>
		</sect2>
		<sect2 id="stodtfunc">
			<title>stodt()</title>
			<para>
				It takes one string operand. This function parses
				the string and tries to convert it to a datetime value.
				It is smart enough to recognize locale specific formats
				and standard ISO-8601 formats. Handles whole datetime,
				date-only and time-only values in the string.
			</para>
		</sect2>
		<sect2 id="stodtsqlfunc">
			<title>stodtsql()</title>
			<para>
				Alias for <literal>stodt()</literal>.
			</para>
		</sect2>
		<sect2 id="strfunc">
			<title>str()</title>
			<para>
				It takes three numeric operands. The first operand
				is converted to a string with the specified integer and
				decimal numeric digits, according to the second and third
				operands.
			</para>
		</sect2>
		<sect2 id="strlenfunc">
			<title>strlen()</title>
			<para>
				It takes one string operand. The function returns
				the number of (UTF-8) characters in the string.
			</para>
		</sect2>
		<sect2 id="subfunc">
			<title>sub()</title>
			<para>
				Subtraction. Operator <literal>-</literal> is a shortcut for
				this function. It takes two or more numeric operands.
			</para>
		</sect2>
		<sect2 id="tanfunc">
			<title>tan()</title>
			<para>
				Tangent. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="timeoffunc">
			<title>timeof()</title>
			<para>
				It takes one datetime operand.
				It returns time part of the datetime operand.
			</para>
		</sect2>
		<sect2 id="translatefunc" xreflabel="translate()">
			<title>translate()</title>
			<para>
				Translates its operand according to the translation
				and locale settings using <literal>dgettext()</literal>
				from Gettext. It takes one string operand.
			</para>
		</sect2>
		<sect2 id="translate2func" xreflabel="translate2()">
			<title>translate2()</title>
			<para>
				Translates its operands according to the translation
				and locale settings using <literal>dngettext()</literal>
				from Gettext. It takes three operands.
				The first two operands are strings, for the singular
				and plural strings. The third operand is the number
				that determines which translation form is used.
			</para>
		</sect2>
		<sect2 id="truncfunc">
			<title>trunc()</title>
			<para>
				Rounds its operand to the next representable integer toward
				zero. It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="tstodfunc">
			<title>tstod()</title>
			<para>
				Alias for <literal>stodt()</literal>.
			</para>
		</sect2>
		<sect2 id="uminusfunc">
			<title>uminus()</title>
			<para>
				Unary minus. Changes the sign of its numeric operand
				from positive to negative, or vice versa. Operator unary
				<literal>-</literal> is the shortcut of this function.
				It takes one numeric operand.
			</para>
		</sect2>
		<sect2 id="upperfunc">
			<title>upper()</title>
			<para>
				It takes one string operand. This function converts
				the string to uppercase.
			</para>
		</sect2>
		<sect2 id="valfunc">
			<title>val()</title>
			<para>
				Numeric value. If a string operand is given, it returns
				the converted numeric value. The value of a numeric operand
				is passed through as is.
				It takes one numeric or string operand.
			</para>
		</sect2>
		<sect2 id="wiyfunc">
			<title>wiy()</title>
			<para>
				It takes one datetime operand. This function returns
				the week number of the operand as a decimal number,
				range 00 to 53, starting with the first Sunday as
				the first day of week 01.
			</para>
		</sect2>
		<sect2 id="wiy1func">
			<title>wiy1()</title>
			<para>
				It takes one datetime operand. This function returns
				the week number of the operand as a decimal number,
				range 00 to 53, starting with the first Monday as
				the first day of week 01.
			</para>
		</sect2>
		<sect2 id="wiyofunc">
			<title>wiyo()</title>
			<para>
				It takes two operands, one datetime and one numeric.
				This function returns the week number of the first
				operand as a decimal number, range 00 to 53, starting
				with the specified day number as the first day.
				(0 = Sunday, 1 = Monday, 2 = Tuesday, ...)
			</para>
		</sect2>
		<sect2 id="xorfunc">
			<title>xor()</title>
			<para>
				Bitwise exclusive OR. It takes two or more numeric operands.
			</para>
		</sect2>
		<sect2 id="yearfunc">
			<title>year()</title>
			<para>
				It takes one datetime operand. This function returns
				the year value of the operand as a numeric value.
			</para>
		</sect2>
	</sect1>
</chapter>
